<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#1055;&#1086;&#1095;&#1077;&#1084;&#1091; &#1087;&#1077;&#1088;&#1077;&#1087;&#1086;&#1083;&#1085;&#1077;&#1085;&#1080;&#1077; &#1089;&#1090;&#1077;&#1082;&#1072; &#1074; &#1076;&#1086;&#1095;&#1077;&#1088;&#1085;&#1077;&#1084; &#1087;&#1086;&#1090;&#1086;&#1082;&#1077; &#1091;&#1073;&#1080;&#1074;&#1072;&#1077;&#1090; &#1074;&#1077;&#1089;&#1100; &#1087;&#1088;&#1086;&#1094;&#1077;&#1089;&#1089;? | RuSO Archive </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#1055;&#1086;&#1095;&#1077;&#1084;&#1091; &#1087;&#1077;&#1088;&#1077;&#1087;&#1086;&#1083;&#1085;&#1077;&#1085;&#1080;&#1077; &#1089;&#1090;&#1077;&#1082;&#1072; &#1074; &#1076;&#1086;&#1095;&#1077;&#1088;&#1085;&#1077;&#1084; &#1087;&#1086;&#1090;&#1086;&#1082;&#1077; &#1091;&#1073;&#1080;&#1074;&#1072;&#1077;&#1090; &#1074;&#1077;&#1089;&#1100; &#1087;&#1088;&#1086;&#1094;&#1077;&#1089;&#1089;? | RuSO Archive ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../../../../favicon.ico">
    <link rel="stylesheet" href="../../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../../index.html">
                <img id="logo" class="svg" src="../../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">

<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Почему переполнение стека в дочернем потоке убивает весь процесс?</h1>
<p><a href="https://ru.stackoverflow.com/questions/907230/%d0%9f%d0%be%d1%87%d0%b5%d0%bc%d1%83-%d0%bf%d0%b5%d1%80%d0%b5%d0%bf%d0%be%d0%bb%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5-%d1%81%d1%82%d0%b5%d0%ba%d0%b0-%d0%b2-%d0%b4%d0%be%d1%87%d0%b5%d1%80%d0%bd%d0%b5%d0%bc-%d0%bf%d0%be%d1%82%d0%be%d0%ba%d0%b5-%d1%83%d0%b1%d0%b8%d0%b2%d0%b0%d0%b5%d1%82-%d0%b2%d0%b5%d1%81%d1%8c-%d0%bf%d1%80%d0%be%d1%86%d0%b5%d1%81%d1%81">Source</a> - by <a href="https://ru.stackoverflow.com/users/32793/iluxa1810">iluxa1810</a></p>
<blockquote>
<p>Отвечая на этот <a href="https://ru.stackoverflow.com/questions/907181/%D0%92%D0%BE%D0%B7%D0%BD%D0%B8%D0%BA%D0%BD%D0%BE%D0%B2%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA-%D0%B2-%D0%B4%D1%80%D1%83%D0%B3%D0%BE%D0%BC-%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%B5-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-c">вопрос</a> был удивлен, что переполнение стека в дочернем потоке убивает процесс целиком.</p>
<p>Собственно, вопрос:</p>
<p>А почему так происходит? Ведь каждый поток имеет собственный стек, даже, на сколько я помню, Рихтер писал об этом.</p>
<p>Даже <code>StackTrace().FrameCount</code> показывает различное кол-во фреймов в основном потоке и дочернем.</p>
<p>В С++- это обрабатываемое исключение, если верить комментариям из предыдущего вопроса, а в <code>.NET</code> нет, так как возможно, как я понимаю, что СLR, которой нужно что-то сделать, может повредится из-за не хватки стека.</p>
<p><code>CLR</code>, по идее, одна на все приложение и она точно не крутится в дочернем потоке.</p>
<p>Получается, что запуская чужой код, к исходникам которого мы не имеем доступа, хоть в отдельном потоке, хоть в отдельном домене, то мы все равно падаем и в .NET никак нельзя предотвратить это при таком типе исключения?</p>
<p><strong>UPD</strong></p>
<p>Есть какие-то "Области с ограничением выполнения" CER, где можно указать, что метод может поверить процесс. Это никак не оказывает влияния на CLR, что бы она подготовилась и не умерла?</p>
</blockquote>
<h2>Answer 907269</h2>
<p><a href="https://ru.stackoverflow.com/a/907269/">Source</a> - by <a href="https://ru.stackoverflow.com/users/178556/default-locale">default locale</a></p>
<blockquote>
<p>По-моему тут накладываются друг на друга две особенности работы CLR.</p>
<h2>Необработанные исключения в дочерних потоках убивают процесс</h2>
<p>Не только переполнение стека, а вообще любое необработанное исключение в дочернем потоке убивает весь процесс:</p>
<pre><code>static void Main()
{
    var thread = new Thread(Recursive);
    thread.Start();
    while (true)
    {
        Console.WriteLine("I will live forever!");
        Thread.Sleep(1000);
    }
}

static void Recursive()
{
    throw new Exception("RIP Unnamed Process (2018-2018");
}
</code></pre>
<p>Об это <a href="https://docs.microsoft.com/en-us/dotnet/standard/threading/exceptions-in-managed-threads" rel="nofollow noreferrer">говорится в MSDN</a>:</p>
<blockquote>
  <p>Starting with the .NET Framework version 2.0, the common language runtime allows most unhandled exceptions in threads to proceed naturally. In most cases this means that the unhandled exception causes the application to terminate.</p>
</blockquote>
<p>[Спорную] мотивацию такого поведения <a href="https://blogs.msdn.microsoft.com/ericlippert/2010/11/23/asynchrony-in-c-5-part-eight-more-exceptions/" rel="nofollow noreferrer">дает Эрик Липперт</a>:</p>
<blockquote>
  <p>We cannot easily tell the difference between bugs which are missing handlers for vexing/exogenous exceptions, and which are bugs that have caused a program crash because something is broken in the implementation. <strong>The safest thing to do is to assume that every unhandled exception is either a fatal exception or an unhandled boneheaded exception. In both cases, the right thing to do is to take down the process immediately.</strong></p>
  
  <p>This philosophy underlies the implementation of unhandled exceptions in the CLR. Way back in the CLR v1.0 days the policy was that an unhandled exception on the "main" thread took down the process aggressively, but an unhandled exception on a "worker" thread simply killed the thread and left the main thread running. (And an exception on the finalizer thread was ignored and finalizers kept running.) This turned out to be a poor choice; the scenario it leads to is that a server assigns a buggy subsystem to do some work on a bunch of worker threads; all the worker threads go down silently, and the user is stuck with a server that is sitting there waiting patiently for results that will never come because all the threads that produce results have disappeared. It is very difficult for the user to diagnose such a problem; a server that is working furiously on a hard problem and a server that is doing nothing because all its workers are dead look pretty much the same from the outside. The policy was therefore changed in CLR v2.0 such that an unhandled exception on a worker thread also takes down the process by default. You want to be noisy about your failures, not silent.</p>
</blockquote>
<p>Это означает что исключения в потоках нужно обрабатывать намертво, например так:</p>
<pre><code>static void SafeRecursive()
{
    try
    {
        Recursive();
    }
    catch (Exception e)
    {
        //должная обработка, запись в логи и уведомление администраторам
        //ха-ха, так никто не делает, просто глотаем и забываем о потоке
    }
}
</code></pre>
<h2>StackOverflowException нельзя поймать</h2>
<p>Но особенность <a href="https://docs.microsoft.com/en-us/dotnet/api/system.stackoverflowexception?view=netframework-4.7.2#version-considerations" rel="nofollow noreferrer">StackOverflowException</a> в том, что его нельзя поймать, ни в дочернем потоке, ни где-либо еще:</p>
<pre><code>static void Main()
{
    try
    {
        Recursive();
    }
    catch (Exception)
    {
        //не получится
        Console.WriteLine("Catch!");
    }
}
</code></pre>
<p>О чем сказано в документации исключения:</p>
<blockquote>
  <p>Starting with the .NET Framework 2.0, you can’t catch a StackOverflowException object with a try/catch block, and the corresponding process is terminated by default. Consequently, you should write your code to detect and prevent a stack overflow. </p>
</blockquote>
<p>Документация ясно дает понять, что нигде в процессе переполнение стека возникать не должно, вообще нигде.</p>
<p>Есть вырожденные случаи, в которых StackOverflowException все же можно обработать:</p>
<ul>
<li>если Вы сами <a href="https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/9x0wh2z3(v=vs.90)" rel="nofollow noreferrer">загружаете CLR</a>, то может получится ее восстановить;</li>
<li>если StackOverflowException выбрасывается кодом.</li>
</ul>
<p>В .Net 1.0 переполнение стека можно было отловить, с версии 2.0 разработчики заняли жесткую позицию: «Переполнение стека — проблема программиста и его кода, а не CLR». Я не смог найти прямых указаний на то, по какой причине потребовалось внести изменения. Предполагаю, что восстановление после SOE было небеспроблемно и разработчики решили не тратить на эту задачу ресурсы.</p>
<p>Вообще, обе эти особенности CLR вполне укладываются в пуританскую философскую позицию «мертвые программы не врут», которую также освещает Эрик Липперт:</p>
<blockquote>
  <p>I am of the philosophical school that says that sudden, catastrophic failure of a software device is, of course, unfortunate, but in many cases it is preferable that the software call attention to the problem so that it can be fixed, rather than trying to muddle along in a bad state, possibly introducing a security hole or corrupting user data along the way.</p>
</blockquote>
<h2>Обновление: Constrained Execution Regions</h2>
<p>Вопрос в комментариях:</p>
<blockquote>
  <p>А "Области с ограничением выполнения" CER - это что такое? Вот там можно повесить атрибут, что есть возможность того, что будет поврежден процесс. Это на что-то влияет?</p>
</blockquote>
<p>Влияет. <a href="https://docs.microsoft.com/en-us/dotnet/framework/performance/constrained-execution-regions" rel="nofollow noreferrer">CER</a> позволяет защититься от части ошибок, которые могли бы возникнуть при исполнении кода (ошибки загрузки классов, нехватки памяти) и корректно освободить ресурсы.</p>
<p>Тем не менее, переполнение стека с помощью CER обработать не получится. Об этом пишет Рихтер (CLR via C#, Constrained Execution Regions):</p>
<blockquote>
  <p><strong>Note</strong> Even if all the methods are eagerly prepared, a method call could still result in a StackOverflowException. When the CLR is not being hosted, a StackOverflowException causes the process to terminate immediately by the CLR internally calling Environment.FailFast. When hosted, the PreparedConstrainedRegions method checks the stack to see if there is approximately 48 KB of stack space remaining. If there is limited stack space,
  the StackOverflowException occurs before entering the try block.</p>
  
  <p><strong>Внимание:</strong> Даже если все методы были явно подготовлены, вызов метода все еще может привести к StackOverflowException. Если CLR не загружена извне, то StackOverflowException завершает процесс немедленно, вызывая Environment.FailFast. Если CLR загружена извне, то метод PreparedConstrainedRegions  проверяет, осталось ли в стеке примерно 48КБ свободного пространства. Если пространство стека ограничено, то StackOverflowException вызывается перед входом в блок try.</p>
</blockquote>
<p>Т.о. отловить переполнение стека с помощью одного CER не получится. StackOverflowException также отдельно упоминается в <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.runtimehelpers.prepareconstrainedregions?view=netframework-4.7.2" rel="nofollow noreferrer">документации</a>:</p>
<blockquote>
  <p>CERs that are marked using the PrepareConstrainedRegions method do not work perfectly when a StackOverflowException is generated from the try block. For more information, see the ExecuteCodeWithGuaranteedCleanup method.</p>
</blockquote>
<p>Мне никак не удалось заставить метод <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.runtimehelpers.executecodewithguaranteedcleanup?view=netframework-4.7.2" rel="nofollow noreferrer">ExecuteCodeWithGuaranteedCleanup</a> обработать переполнение стека. Судя по обсуждению в <a href="https://stackoverflow.com/questions/2591364/when-does-executecodewithguaranteedcleanup-actually-guarantee-cleanup">вопросе по данному методу</a> он также сработает только если Вы сами захостите CLR. </p>
<h2>Ссылки</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/4284986/catching-unhandled-exception-on-separate-threads">Catching unhandled exception on separate threads</a> — вопрос об обработке исключений в отдельном потоке</li>
<li><a href="https://stackoverflow.com/questions/5983779/catch-exception-that-is-thrown-in-different-thread">catch exception that is thrown in different thread</a> — еще один.</li>
<li><a href="https://stackoverflow.com/questions/206820/how-do-i-prevent-and-or-handle-a-stackoverflowexception">How do I prevent and/or handle a StackOverflowException?</a> — вопрос о предупреждении SOE, рассматриваются разного рода костыли.</li>
<li><a href="https://blogs.msdn.microsoft.com/jaredpar/2008/10/22/when-can-you-catch-a-stackoverflowexception/" rel="nofollow noreferrer">When can you catch a StackOverflowException?</a> — статья о вырожденных случаях, которая только подчеркивает, что SOE поймать нельзя.</li>
<li><a href="https://blogs.msdn.microsoft.com/ericlippert/2010/11/23/asynchrony-in-c-5-part-eight-more-exceptions/" rel="nofollow noreferrer">Asynchrony in C# 5, Part Eight: More Exceptions</a> — статья Эрика Липперта об исключениях в асинхронных функциях, в которой, между делом, рассказывается об истории обработки исключений в дочерних потоках в .Net 1.0 и, в целом, об отношении авторов C# к обработке исключений.</li>
</ul>
</blockquote>
<h2>Answer 908020</h2>
<p><a href="https://ru.stackoverflow.com/a/908020/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<blockquote>
  <p>В С++- это обрабатываемое исключение, если верить комментариям из предыдущего вопроса</p>
</blockquote>
<p>На самом деле все немного не так. Стандартными средствами С++, разумеется, нельзя обработать переполнение стека. Однако, в Windows его можно обработать с помощью механизма SEH. И, что бы ни говорил Эрик Липперт, восстановление после переполнения стека - вполне поддерживаемый сценарий,  иначе зачем бы существовали функции <a href="https://msdn.microsoft.com/ru-ru/library/89f73td2.aspx?f=255&amp;MSPPError=-2147217396" rel="nofollow noreferrer">_resetstkoflw</a> и <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setthreadstackguarantee" rel="nofollow noreferrer">SetThreadStackGuarantee</a>?</p>
<blockquote>
  <p>а в .NET нет, так как возможно, как я понимаю, что СLR, которой нужно что-то сделать, может повредится из-за не хватки стека</p>
</blockquote>
<p>В .NET StackOverflowException не обрабатывается не потому, что это технически невозможно, а потому, что так решили разработчики. В Windows переполнение стека порождает исключение SEH с кодом STATUS_STACK_OVERFLOW (0xC00000FD). CLR перехватывает SEH-исключения и, если видит этот код, принудительно убивает процесс (будучи загруженной с параметрами по умолчанию). При этом куда более опасное Access Violation .NET почему-то разрешает обрабатывать.</p>
<blockquote>
  <p>Получается, что запуская чужой код, к исходникам которого мы не имеем доступа, хоть в отдельном потоке, хоть в отдельном домене, то мы все равно падаем и в .NET никак нельзя предотвратить это при таком типе исключения?</p>
</blockquote>
<p>Только средствами .NET нельзя. Однако в неуправляемом коде нужно написать, по сути, очень немного.</p>
<p>Один из способов обойти это поведение, это создать специальную неуправляемую DLL, единственной целью которой будет обработать SEH-исключение и поменять его код на тот, который CLR "не напугает" (SEH-исключения с неизвестным кодом CLR преобразует в SEHException, которое можно обработать). В приложении на C# загрузить DLL, установить векторный обработчик исключений и увеличить размер зарезервированной области стека с помощью функции SetThreadStackGuarantee.</p>
<p>Конечно, это не обеспечит полное восстановление стека, т.е., чтобы можно было далее в том же потоке снова словить переполнение стека и обработать его. Но если просто позволить потоку завершиться и забыть про него, это не имеет значения:  вновь созданные потоки уже будут иметь корректный стек.</p>
<p>Например, создадим DLL на С++ с таким кодом:</p>
<pre><code>#include &lt;malloc.h&gt;
#include &lt;windows.h&gt;

#ifdef __cplusplus
extern "C"{
#endif

__declspec(dllexport) LONG WINAPI fnCrashHandler(LPEXCEPTION_POINTERS pExceptionInfo)
{   

    if(pExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == STATUS_STACK_OVERFLOW){
        pExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode = 0x1234;
    }

    return EXCEPTION_CONTINUE_SEARCH;
}

#ifdef __cplusplus
}
#endif
</code></pre>
<p>Назовем ее, допустим, CrashHandler.dll, и поместим в каталог с программой. Тогда в C# можно обработать переполнение стека таким образом:</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Runtime.InteropServices;

namespace ConsoleTest
{
     class Program
    {                

        [DllImport("kernel32.dll")]        
        public static extern IntPtr AddVectoredExceptionHandler(
            uint FirstHandler,
            IntPtr VectoredHandler
        );                       

        [DllImport("kernel32.dll")]
        public static extern int SetThreadStackGuarantee(  ref uint StackSizeInBytes);         

        [DllImport("kernel32.dll")]
        public static extern IntPtr LoadLibrary([MarshalAs(UnmanagedType.LPStr)]string lpFileName);

        [DllImport("kernel32.dll", CharSet = CharSet.Ansi, ExactSpelling = true)]
        public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

        static void Recursive()
        {
            Recursive();
        }

        static void Test()
        {            

            //увеличим размер зарезервированной области стека (30 KB должно быть достаточно)
            uint size = 30000; 
            SetThreadStackGuarantee(ref size);   

            try
            {
                Recursive();
            }
            catch (SEHException)
            {
                Console.WriteLine("SEHException. Code: 0x" + Marshal.GetExceptionCode().ToString("X"));                
            }

        }        

        static void Main(string[] args)
        {
            //добавим обработчик исключений
            IntPtr h = LoadLibrary("CrashHandler.dll");
            IntPtr fnAddress = GetProcAddress(h, "_fnCrashHandler@4"); //декорированное имя функции по правилам stdcall           
            AddVectoredExceptionHandler(1, fnAddress);

            //запустим поток
            Thread thread = new Thread(Test);
            thread.Start();
            thread.Join();            

            Console.WriteLine("Press any key...");
            Console.ReadKey();
        }

    }
}
</code></pre>
<p><strong>Примечание.</strong> Целевая архитектура неуправляемой DLL и приложения должны совпадать. Для AnyCPU-приложений понадобится иметь несколько неуправляемых DLL под каждую архитектуру и загружать нужную в зависимости от текущей архитектуры приложения.</p>
</blockquote>
<hr>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>RuSO Archive (published from sources in <a href="https://github.com/MSDN-WhiteKnight/ruso-archive">GitHub repository</a>). Content licensed under <a href="https://github.com/MSDN-WhiteKnight/ruso-archive/blob/master/LICENSE">CC-BY-SA 4.0</a>.<br>Generated by <strong>DocFX</strong></span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../../styles/main.js"></script>
  </body>
</html>
