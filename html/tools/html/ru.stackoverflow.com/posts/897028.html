<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#1047;&#1072;&#1074;&#1080;&#1089;&#1072;&#1077;&#1090; &#1087;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1072;. C# | RuSO Archive </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#1047;&#1072;&#1074;&#1080;&#1089;&#1072;&#1077;&#1090; &#1087;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1072;. C# | RuSO Archive ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../../../../favicon.ico">
    <link rel="stylesheet" href="../../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../../index.html">
                <img id="logo" class="svg" src="../../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">

<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Зависает программа. C#</h1>
<p><a href="https://ru.stackoverflow.com/questions/897028/%d0%97%d0%b0%d0%b2%d0%b8%d1%81%d0%b0%d0%b5%d1%82-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b0-c">Source</a> - by <a href="https://ru.stackoverflow.com/users/313350/%d0%92%d0%bb%d0%b0%d0%b4%d0%b8%d0%bc%d0%b8%d1%80-%d0%9a%d1%80%d0%b5%d0%bc%d0%bb%d0%b5%d0%b2">Владимир Кремлев</a></p>
<blockquote>
<p>Имеется программа. Периодически зависает, не помогает ничего, т.е. только перезапуск. Место зависание в функции отправки запроса.</p>
<pre><code>public async Task&lt;string&gt; PostRequestAsync(string url, string PostData, string Referer, CancellationToken ct)
{
    string Answer;
    ct.ThrowIfCancellationRequested();
    HttpWebRequest Request = (HttpWebRequest)WebRequest.Create(url);
    if (Proxy != null)
    {
        Request.Proxy = Proxy;
    }
    else
    {
        Request.Proxy = null;
    }
    Request.Method = "POST";
    Request.KeepAlive = true;
    Request.Timeout = 10000;
    Request.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;
    Request.Host = BaseUrl.Substring(8);
    Request.KeepAlive = true;
    byte[] bytes = Encoding.UTF8.GetBytes(PostData);
    Request.ContentLength = bytes.Length;
    Request.Accept = "text/html, */*; q=0.01";
    Request.Headers.Add($"Origin: {BaseUrl}");
    Request.Headers.Add("X-Requested-With: XMLHttpRequest");
    Request.UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.168 Safari/537.36 OPR/51.0.2830.40";
    Request.ContentType = "application/x-www-form-urlencoded; charset=UTF-8";
    Request.Referer = Referer;
    Request.Headers.Add("Accept-Encoding: gzip, deflate, br");
    Request.Headers.Add("Accept-Language: ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7");
    Request.CookieContainer = LoginData;
    try
    {
        ct.ThrowIfCancellationRequested();
        using (Stream stream = await Request.GetRequestStreamAsync())
        {
            stream.Write(bytes, 0, bytes.Length);
        }
        WebResponse Response = await Request.GetResponseAsync();
        ct.ThrowIfCancellationRequested();
        using (StreamReader streamReader = new StreamReader(Response.GetResponseStream()))
        {
            Answer = await streamReader.ReadToEndAsync();
        }
        if (Answer.Contains("\\/site\\/logIn"))
        {
            Answer = "1";
            string html = await GetClearRequestAsync(BaseUrl, ct);
            var parser = new HtmlParser();
            var document = parser.Parse(html);
            string name = document.GetElementById("authentification").Children[1].GetAttribute("name").ToLower();
            string value = document.GetElementById("authentification").Children[1].GetAttribute("value").ToLower();
            string PostData1 = $"{name}={value}&amp;login={login}&amp;password={password}&amp;redirection=&amp;isBoxStyle=";
            await LoginRequestAsync(PostData1, ct);
        }
        Request.Abort();
        Response.Close();
    }
    catch
    {
        Request.Abort();
        Answer = "0";
    }
    return Answer;
}
</code></pre>
<p>Пытался разбираться в сути проблемы. Было выявлено, что наиболее часто происходит такая проблема в двух случаях:
а) Плохое соединение с интернетом
б) Слабый ПК (ещё не совсем потверждено)
Случай "а" пытался исправить путем добавление цикла do while с проверкой на положительный ответ от сервера. Не вышло. Была мысль, что это связано с бесконечными попытками открытия соединения и добавил проверку такого рода </p>
<pre><code>if(System.Net.NetworkInformation.NetworkInterface.GetIsNetworkAvailable())
</code></pre>
<p>Тоже мимо. Теперь встал в тупик как же выявлять и присекать подобные случаи. Можно заметить что в функцию передается Cancellationtoken, отменить работу программы с его помощью не удаётся.</p>
<p>P.S. Работа возможно только с HttpWebRequest, остальные средства либо не подходят по удобству реализации, либо некорректно работают с сервером, стабильности добился только при таком подходе.</p>
</blockquote>
<h2>Answer 897089</h2>
<p><a href="https://ru.stackoverflow.com/a/897089/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<p>В вашем коде трудно разобраться, но выглядит как будто вы никак не используете CancellationToken и не реализуете таймаут для сетевых операций. Для асинхронных сетевых операций, в отличие от синхронных, Request.Timeout играет роль только на начальном этапе от отправки заголовка до получения первых байт ответа. При обрыве связи на последующей загрузке они просто тихо умирают (никогда не заканчиваются), поэтому таймаут нужно реализовать вручную, как-то так:</p>
<pre><code>static async Task&lt;string&gt; Download(string url)
{            
        HttpWebRequest Request = (HttpWebRequest)WebRequest.Create(url);
        var resp = await Request.GetResponseAsync();
        var stream = resp.GetResponseStream();
        MemoryStream ms = new MemoryStream();

        using (stream)
        using (ms)
        {
            await stream.CopyToAsync(ms);
            ms.Seek(0, SeekOrigin.Begin);

            var rd = new System.IO.StreamReader(ms);
            return await rd.ReadToEndAsync();
        }            
}

private async void button1_Click(object sender, EventArgs e)
{

    const string url = "http://example.com/";                    

    var res = await Task.WhenAny(Download(url),Task.Delay(10000));

    if (res is Task&lt;string&gt;) textBox1.Text = (res as Task&lt;string&gt;).Result;
    else textBox1.Text = "Timeout expired!";
}
</code></pre>
</blockquote>
<hr>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>RuSO Archive (published from sources in <a href="https://github.com/MSDN-WhiteKnight/ruso-archive">GitHub repository</a>). Content licensed under <a href="https://github.com/MSDN-WhiteKnight/ruso-archive/blob/master/LICENSE">CC-BY-SA 4.0</a>.<br>Generated by <strong>DocFX</strong></span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../../styles/main.js"></script>
  </body>
</html>
