<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#1050;&#1072;&#1082; &#1087;&#1086;&#1089;&#1084;&#1086;&#1090;&#1088;&#1077;&#1090;&#1100; &#1082;&#1086;&#1075;&#1076;&#1072; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1072;&#1103; &#1085;&#1072;&#1093;&#1086;&#1076;&#1080;&#1090;&#1089;&#1103; &#1074; &#1092;&#1072;&#1081;&#1083;&#1077; &#1087;&#1086;&#1076;&#1082;&#1072;&#1095;&#1082;&#1080; &#1072; &#1082;&#1086;&#1075;&#1076;&#1072; &#1074; &#1086;&#1087;&#1077;&#1088;&#1072;&#1090;&#1080;&#1074;&#1085;&#1086;&#1081; &#1087;&#1072;&#1084;&#1103;&#1090;&#1080;? | RuSO Archive </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#1050;&#1072;&#1082; &#1087;&#1086;&#1089;&#1084;&#1086;&#1090;&#1088;&#1077;&#1090;&#1100; &#1082;&#1086;&#1075;&#1076;&#1072; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1072;&#1103; &#1085;&#1072;&#1093;&#1086;&#1076;&#1080;&#1090;&#1089;&#1103; &#1074; &#1092;&#1072;&#1081;&#1083;&#1077; &#1087;&#1086;&#1076;&#1082;&#1072;&#1095;&#1082;&#1080; &#1072; &#1082;&#1086;&#1075;&#1076;&#1072; &#1074; &#1086;&#1087;&#1077;&#1088;&#1072;&#1090;&#1080;&#1074;&#1085;&#1086;&#1081; &#1087;&#1072;&#1084;&#1103;&#1090;&#1080;? | RuSO Archive ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../../../../favicon.ico">
    <link rel="stylesheet" href="../../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../../index.html">
                <img id="logo" class="svg" src="../../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">

<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Как посмотреть когда переменная находится в файле подкачки а когда в оперативной памяти?</h1>
<p><a href="https://ru.stackoverflow.com/questions/923326/%d0%9a%d0%b0%d0%ba-%d0%bf%d0%be%d1%81%d0%bc%d0%be%d1%82%d1%80%d0%b5%d1%82%d1%8c-%d0%ba%d0%be%d0%b3%d0%b4%d0%b0-%d0%bf%d0%b5%d1%80%d0%b5%d0%bc%d0%b5%d0%bd%d0%bd%d0%b0%d1%8f-%d0%bd%d0%b0%d1%85%d0%be%d0%b4%d0%b8%d1%82%d1%81%d1%8f-%d0%b2-%d1%84%d0%b0%d0%b9%d0%bb%d0%b5-%d0%bf%d0%be%d0%b4%d0%ba%d0%b0%d1%87%d0%ba%d0%b8-%d0%b0-%d0%ba%d0%be%d0%b3%d0%b4%d0%b0-%d0%b2-%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%b8%d0%b2%d0%bd%d0%be%d0%b9">Source</a> - by <a href="https://ru.stackoverflow.com/users/321096/sergesama-channel">Sergesama Channel</a></p>
<blockquote>
<p>Мой основной вопрос состоит в том что, возможно ли во время работы программы как-то( с помощью любых средств ) узнавать где находится переменная,хотя бы засечь момент когда она переносится в файл подкачки.
А также у меня вопрос. Правильно ли я понимаю, что файл подкачки используется только когда не хватает места в оперативной памяти или если есть долго не использующиеся переменные?
Можно ли задать адрес переменной,а потом по ходу программы смотреть находится ли эта переменная по заранее заданному адресу в оперативной памяти(на c# с помощью .Net). И соответственно если ее не будет в оперативной памяти, то она находится в файле подкачки. Так ли работает адрес у переменной, или он не меняется вне зависимости от того где находится? </p>
</blockquote>
<h2>Answer 923334</h2>
<p><a href="https://ru.stackoverflow.com/a/923334/">Source</a> - by <a href="https://ru.stackoverflow.com/users/287068/freim">freim</a></p>
<blockquote>
<p>Дело в том, что переменная в памяти всегда находится в файле подкачки и одновременно всегда находится в памяти. Хотя конечно, в файл подкачки она может попасть не сразу, а из памяти может быть временно вытеснена, программно вы это никак не определите. Если переменной в памяти нет, обращение к ней вызовет системное исключение, и в результате этот блок памяти будет подгружен. Причем возможно он будет загружен совсем в другую область физической памяти. Но для программы эта переменная всегда в памяти, всегда по тому же адресу, и всегда доступна.</p>
</blockquote>
<h2>Answer 923409</h2>
<p><a href="https://ru.stackoverflow.com/a/923409/">Source</a> - by <a href="https://ru.stackoverflow.com/users/17974/nick-n-a">nick_n_a</a></p>
<blockquote>
<blockquote>
  <p>возможно ли во время работы программы как-то узнавать где находится
  переменная,</p>
</blockquote>
<p>С уровня софта  - нет. С уровня драйвера, или уровня ядра - можно. (через каталог страниц виртуальной памяти). Как конкретно - это очень специфическая область - нужно копать DDK (Driver Development Kit).</p>
<p>UPD: Виртуальный адрес переменной (я бы назвал обычный), при смене физического адреса - не меняется. Физический адрес нужен для DMA (используется в драйверах HDD, USB, сетевой и звуковой карт). Если адрес существует в физической памяти - он всегда будет иметь физический адрес (но при запросе физического адреса он вероятне всего будет назначен).</p>
<blockquote>
  <p>хотя бы засечь момент когда она переносится в файл подкачки. </p>
</blockquote>
<p>С уровня драйвер - может быть. Возможно в ядре есть обработчик, скидывающий страницу на диск - найти и перехватить его займет какое-то время (от месяца до года), и требует хороших знаний в этой области. </p>
<blockquote>
  <p>А также у меня вопрос. Правильно ли я понимаю, что файл подкачки используется только когда не хватает места в оперативной памяти или если есть долго не использующиеся переменные?</p>
</blockquote>
<p>Алгоритм распределения памяти сложный и сложно-предсказуемый, но есть особенности, я постараюсь все перечислить. Ответ зависит как минимум от двух факторов. Если суммарная памяти всех программ меньше чем обьем оперативки - то да, память может находится в физической памяти. Если нет (сегодня такая ситуация что чаще нет) - то есть большая вероятность, что память может оказаться в файле подкачки. </p>
<p>Так же, в случае когда оперативной памяти на всех не хватает и статистика использовании ноль - память уходит в файл подкачки.</p>
<p>Если область памяти переменной не используется или она забита просто нолями - то такой кусок памяти может пока его не наполнят - вообще нигде не хранится, и не занимать место ни в <em>физической памяти</em> ни в <em>файле подкачки</em>.</p>
<p>Так же вероятность нахождение в файле подкачке зависит от частоты обращений к <em>странице памяти</em> по сравнению с другими программами. Т.е. если вы переменную постоянно пишете/читаете - есть вероятность, что она может оказаться в физической памяти (если других претендетов с более высокой статистикой обращений туда нету).</p>
<p>В некоторых ОС (98/ХР и многих других) можно было отключить файл подкачки - тогда - переменная всегда в оперативке. Боюсь что win10 отключение не переживёт:)</p>
<p>У OS есть специальная метка в памяти - "невыгружаемая память" (например части ядра). Если эту метку получить - память выгружаться не будет, и всегда будет в оперативке. Как - уровень драйвера.</p>
<p>UPD: Важная деталь. Любая память, к которой вот сейчас произошло обращение, и страница под неё отстутствует - то страница выделяется, физическая память добывается (если нет свободной, отбирается у другого процесса, а его скидывается на диск), с <em>файла подкачки</em> считывается, т.е. не видно что её не было. Если это не произошло - тогда это "синий экран смерти", но думаю такого не бывает, там хорошо прописан алгоритм что б этого не случилось. Страница стека, куда указывает esp (rsp) - может быть выгружена, если идет работа с другим процессом, но "по первому требованию" она будет загружена назад. </p>
<p>Как итог, хочу сказать</p>
<p>1) Волноваться за память - не стоит.</p>
<p>2) стоит стараться оптимально использовать память (чем меньше используется тем лучше, но не в ущерб алгоритму)</p>
<p>3) желательно знать сколько вашей программе нужно памяти, и взять сколько нужно, чем брать кусками - тогда OS проще предсказать сколько памяти вам нужно - и ПО будет работать быстрее. </p>
<p>4) Нужно знать что есть размер <em>страницы памяти</em>, он равен 8192 либо 4096(раньше было) (можно узнать через АПИ). Желательно большие структуры выравнивать по границам этого к-ва байт - тогда программа будет работать быстрее.</p>
<p>Ссылка на мой труд, где я обьяснял поведение с массивом <a href="https://ru.stackoverflow.com/questions/844846/%d0%af%d0%b7%d1%8b%d0%ba-c-%d0%b3%d0%bb%d0%be%d0%b1%d0%b0%d0%bb%d1%8c%d0%bd%d1%8b%d0%b5-%d0%bc%d0%b0%d1%81%d1%81%d0%b8%d0%b2%d1%8b/844891">Язык C, глобальные массивы</a></p>
</blockquote>
<h2>Answer 923427</h2>
<p><a href="https://ru.stackoverflow.com/a/923427/">Source</a> - by <a href="https://ru.stackoverflow.com/users/192421/pepsicoca1">pepsicoca1</a></p>
<blockquote>
<blockquote>
  <p>Мой основной вопрос состоит в том что, возможно ли во время работы
  программы как-то( с помощью любых средств ) узнавать где находится
  переменная,хотя бы засечь момент когда она переносится в файл
  подкачки.</p>
</blockquote>
<p>Вопрос интересный. Надо смотреть WinAPI есть ли там какие-нибудь функции на эту тему. Думаю что таких функций нет, поэтому скорее всего для винды невозможно узнать, выгружена ли данная переменная на диск или болтается в памяти. Кстати, чтобы это узнать, надо еще анализировать карту загрузки и листинг. То есть WinAPI функция (буде такая бы и была) должна была бы в качестве параметров принимать не только имя переменной но и карту загрузки и листинг программы. </p>
<p>Думаю, что для линукса такой функции тоже нет. По тем же причинам - никто не будет парсить листинг и карту загрузки в поисках имени, да и формат листинга и карты загрузки не стандартизован. Конечно, в мире линукса есть много затейников. Может быть кто-то и написал нашлепку к ядру, которая отслеживает что-то подобное хотя бы в целях отладки.</p>
<blockquote>
  <p>А также у меня вопрос. Правильно ли я понимаю, что файл подкачки
  используется только когда не хватает места в оперативной памяти или
  если есть долго не использующиеся переменные?</p>
</blockquote>
<p>Теоретически файл подкачки используется, когда не хватает места в оперативной памяти. Практически алгоритм файла подкачки на винде закрыт, поэтому ничего об нем сказать нельзя. Для Линукса алгоритм, конечно, известен матерым линуксоидам.</p>
<p>Кстати, коллега nick_n_a подкинул свежую идею. Если отключить файл подкачки, то все переменные будут сидеть в памяти. :-)</p>
<p>UPD1:</p>
<p>Кстати, да. Есть же еще переменные на стеке. Интересно, а страница стека выгружается в файл подкачки? В любом случае непонятно, если пользователь запросил имя стековой переменной, а эта переменная в данный момент не существует, что должна возвращать WinAPI функция? А может эта стековая переменная и вообще никогда не будет создана в текущем запуске программы?</p>
<p>Вобщем, вопрос довольно странный.</p>
<p>UPD2:</p>
<p>А еще есть такой вариант, что переменная (например структура) имеет размер бОльший, чем страница памяти. Тогда возможен случай, что часть переменной выгружена на диск, а часть нет. Как в этом случае нужно рассматривать переменную - как выгруженную или как не выгруженную? Или если переменная не большая, но лежит на границе страниц.</p>
<p>UPD3:</p>
<p>А еще есть такой вариант, что переменная расположена в куче и опять же непонятно, была она создана или нет в данный момент работы программы и будет ли вообще когда-нибудь создана в этом запуске программы. Вобщем, видимо Вам преподаватель дал такое задание просто чтобы вы подумали над проблемой. Потому, похоже, что технически эта проблема "в общем виде" не решается.</p>
<p>UPD4:</p>
<blockquote>
  <p>Я понял что нужно получить память занимаемую процессом программы в
  которой находится переменная. Но дело в том что я не понимаю как на
  c++ это можно реализовать.</p>
</blockquote>
<p>Sergesama Channel, Вы не стирайте старый вопрос. Просто дописывайте уточнения. Потому что "норот" отвечал на Ваш старый вопрос, Вы его изменили и все ответы выглядят немного шизофренично. :-)</p>
<p>Что касается получения памяти процесса, то мне вспоминается, что на винде это можно получить (выгрузить на диск в двоичном виде). Не знаю уж как это соотносится с безопасностью, но вроде бы такая функция в WinAPI была (но точно не скажу, надо смотреть). Но даже если Вы получили образ памяти процесса, то все равно непонятно, какие страницы в данный момент выгружены на диск, а какие нет.</p>
</blockquote>
<h2>Answer 923475</h2>
<p><a href="https://ru.stackoverflow.com/a/923475/">Source</a> - by <a href="https://ru.stackoverflow.com/users/199925/john-darkman">John Darkman</a></p>
<blockquote>
<p>Технически в современном мире, память делится на виртуальную и физическую. Грубо говоря, физическая память - это набор ячеек и адресов к ним в оперативной памяти. Виртуальная память - отображение адресов физической памяти на некоторые виртуальные адреса с точки зрения процессора. Что это нам дает? Во-первых, отображая физические адреса на виртуальные, мы может изолировать память каждого процесса. Во-вторых, любой процесс может находиться по одинаковому адресу в виртуальной памяти, но всегда в разных местах в физической памяти. В-третьих, мы можем один адрес физической память отображать сразу на несколько адресов виртуальной памяти на каждый процесс, что нам даст возможность разделяемой памяти без лишних дублирований памяти между этими процессами. В-четвертых, благодаря виртуальной памяти, её можно выгружать и загружать обратно при необходимости. Дополнительно виртуальную память можно защищать (например запретить записывать что-то в память с кодом), что было бы невозможно при работе с физической памятью напрямую.</p>
<p>При доступе к отсутствующему / выгруженному адресу виртуальной памяти процессор генерирует прерывание / исключение, которое операционная система перехватывает и загружает на нужный виртуальный адрес ранее выгруженную физическую память и после этого настраивает оборажение физического адреса на виртуальный.</p>
<p>Теперь, что касается вашего вопроса, с точки зрения программы все её переменные хранятся всегда по одним и тем же виртуальным адресам и всегда доступны (если они недоступны, произойдет исключение и ОС загрузит память будто она всегда была загружена, и сделает это незаметно для программы), но адрес в физической памяти может быть разным и меняться в процессе загрузки / выгрузки как угодно. Если вам это действительно нужно, то копать следует в сторону определения физических адресов на которые отображены виртуальные.</p>
<p>Отображение физических адресов на виртуальные происходит настройкой некоторой структуры данных и загрузкой этой структуры в некоторый регистр процессора, после чего процессор делает преобразования между адресами самостоятельно по этой самой структуре. Более подробно можно почитать об этом, найдя информацию по ключевым словам "paging and virtual memory".</p>
</blockquote>
<h2>Answer 923570</h2>
<p><a href="https://ru.stackoverflow.com/a/923570/">Source</a> - by <a href="https://ru.stackoverflow.com/users/232/avp">avp</a></p>
<blockquote>
<p>По крайней мере в Линуксе, если верить <a href="http://man7.org/linux/man-pages/man5/proc.5.html" rel="nofollow noreferrer">man 5 proc</a>
 это возможно.</p>
<p>Cудя по описанию, для известного адреса переменной  вам нужно прочесть  соответствующие 8 байт (<code>uint64_t</code>) (для страниц размером 4k просто сдвиньте адрес на 9, обнулите 3 младших бита и сделайте seek) из файла <strong>/proc/self/pagemap</strong> и посмотреть на бит 62. Если 0, то страница с переменной в swap-е.</p>
<blockquote>
<pre><code>/proc/[pid]/pagemap (since Linux 2.6.25)
          This file shows the mapping of each of the process's virtual
          pages into physical page frames or swap area.  It contains one
          64-bit value for each virtual page, with the bits set as fol‐
          lows:
<pre><code>           63     If set, the page is present in RAM.

           62     If set, the page is in swap space

           61 (since Linux 3.5)
                  The page is a file-mapped page or a shared anony‐
                  mous page.

           60–57 (since Linux 3.11)
                  Zero

           56 (since Linux 4.2)
                  The page is exclusively mapped.

           55 (since Linux 3.11)
                  PTE is soft-dirty (see the kernel source file Doc‐
                  umentation/vm/soft-dirty.txt).

           54–0   If the page is present in RAM (bit 63), then these
                  bits provide the page frame number, which can be
                  used to index /proc/kpageflags and /proc/kpage‐
                  count.  If the page is present in swap (bit 62),
                  then bits 4–0 give the swap type, and bits 54–5
                  encode the swap offset.

      Before Linux 3.11, bits 60–55 were used to encode the base-2
      log of the page size.

      To employ /proc/[pid]/pagemap efficiently, use
      /proc/[pid]/maps to determine which areas of memory are actu‐
      ally mapped and seek to skip over unmapped regions.

      The /proc/[pid]/pagemap file is present only if the CON‐
      FIG_PROC_PAGE_MONITOR kernel configuration option is enabled.

      Permission to access this file is governed by a ptrace access
      mode PTRACE_MODE_READ_FSCREDS check; see ptrace(2).
</code></pre>
<p></code></pre><p>
</blockquote>
</blockquote>
<h2>Answer 925821</h2>
<p><a href="https://ru.stackoverflow.com/a/925821/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<p>В Windows для этого существует функция <a href="https://docs.microsoft.com/ru-ru/windows/desktop/api/psapi/nf-psapi-queryworkingsetex" rel="nofollow noreferrer">QueryWorkingSetEx</a>. "Working set" - это набор страниц виртуальной памяти, загруженных в данный момент в физическую память. Если заданный адрес в него не попадает, то в результате QueryWorkingSetEx для него значение флага Valid будет равно нулю, если попадает - единице. </p>
<p>Пример на С++:</p>
<pre><code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;psapi.h&gt;       

bool IsInPhysicalMemory(PVOID address){
    const UINT FLAG_VALID = 0x1;
    PSAPI_WORKING_SET_EX_INFORMATION info = {0};
    info.VirtualAddress = address;

    BOOL bResult = QueryWorkingSetEx(GetCurrentProcess(),(PVOID)&amp;info,sizeof(info));
    if(bResult == FALSE) {printf("QueryWorkingSetEx failed: %d\n",(int)GetLastError());return false;}

    return ((info.VirtualAttributes.Flags &amp; FLAG_VALID) == FLAG_VALID);
}

int x = 1;

int main(int argc, char* argv[])
{    
    //...   

    bool bResult = IsInPhysicalMemory((PVOID)&amp;x);
    if(bResult == false) printf("In pagefile\n");
    else printf("In physical memory\n");    

    //...   
}
</code></pre>
<p>Пример на C# (требует включения unsafe-кода):</p>
<pre><code>using System;
using System.Text;
using System.Runtime.InteropServices;

namespace ConsoleApp1
{    

    unsafe class Program
    {
        [DllImport("kernel32.dll")]
        static extern IntPtr GetCurrentProcess();

        [DllImport("Psapi.dll")]
        static extern int QueryWorkingSetEx(
            IntPtr hProcess, 
            [In, Out] ref PSAPI_WORKING_SET_EX_INFORMATION pv, 
            uint cb);

        public struct PSAPI_WORKING_SET_EX_INFORMATION
        {
            public IntPtr VirtualAddress;
            public IntPtr VirtualAttributes;
        };

        public static bool IsInPhysicalMemory(IntPtr address)
        {
            PSAPI_WORKING_SET_EX_INFORMATION info = new PSAPI_WORKING_SET_EX_INFORMATION();
            info.VirtualAddress = address;

            int iResult = QueryWorkingSetEx(GetCurrentProcess(), ref info, (uint)Marshal.SizeOf(info));
            if (iResult == 0) throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());

            return (((Int64)info.VirtualAttributes &amp; 0x1) == 0x1);
        }

        static int y = 1;

        static void Main(string[] args)
        {            

            //...   

            fixed (int* p = &amp;y)
            {  
                if (IsInPhysicalMemory((IntPtr)p)) Console.WriteLine("In physical memory");
                else Console.WriteLine("In pagefile");
            }            

            //...   
        }

    }
}
</code></pre>
<blockquote>
  <p>Можно ли задать адрес переменной,а потом по ходу программы смотреть находится ли эта переменная по заранее заданному адресу в оперативной памяти(на c# с помощью .Net). И соответственно если ее не будет в оперативной памяти, то она находится в файле подкачки. Так ли работает адрес у переменной, или он не меняется вне зависимости от того где находится?</p>
</blockquote>
<p>Обычно да, адрес переменной в виртуальной памяти фиксирован и не меняется в ходе работы программы. (В C# переменные, которые хранятся в управляемой куче, имеют переменный адрес, но это связано с деятельностью сборщика мусора, а не с перемещением в файл подкачки.)</p>
<p>Адрес страницы в физической памяти, соответствующей данному адресу в виртуальной памяти, конечно меняется в ходе того как ОС перемещает страницы. Соответствие физического и виртуального адреса можно получить в windbg в режиме отладки ядра (см. <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-vtop" rel="nofollow noreferrer">vtop</a>), но программно в usermode, насколько я знаю, нельзя.</p>
</blockquote>
<hr>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>RuSO Archive (published from sources in <a href="https://github.com/MSDN-WhiteKnight/ruso-archive">GitHub repository</a>). Content licensed under <a href="https://github.com/MSDN-WhiteKnight/ruso-archive/blob/master/LICENSE">CC-BY-SA 4.0</a>.<br>Generated by <strong>DocFX</strong></span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../../styles/main.js"></script>
  </body>
</html>
