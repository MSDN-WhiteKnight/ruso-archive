<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#1050;&#1072;&#1082; &#1084;&#1086;&#1078;&#1085;&#1086; &#1079;&#1072;&#1087;&#1088;&#1077;&#1090;&#1080;&#1090;&#1100; &#1076;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1090;&#1100; &#1074; &#1087;&#1088;&#1086;&#1077;&#1082;&#1090; &#1074;&#1099;&#1079;&#1086;&#1074;&#1099; &#1085;&#1077;&#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1093; &#1084;&#1077;&#1090;&#1086;&#1076;&#1086;&#1074;? | RuSO Archive </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#1050;&#1072;&#1082; &#1084;&#1086;&#1078;&#1085;&#1086; &#1079;&#1072;&#1087;&#1088;&#1077;&#1090;&#1080;&#1090;&#1100; &#1076;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1090;&#1100; &#1074; &#1087;&#1088;&#1086;&#1077;&#1082;&#1090; &#1074;&#1099;&#1079;&#1086;&#1074;&#1099; &#1085;&#1077;&#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1093; &#1084;&#1077;&#1090;&#1086;&#1076;&#1086;&#1074;? | RuSO Archive ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../../../../favicon.ico">
    <link rel="stylesheet" href="../../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../../index.html">
                <img id="logo" class="svg" src="../../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">

<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Как можно запретить добавлять в проект вызовы некоторых методов?</h1>
<p><a href="https://ru.stackoverflow.com/questions/875165/%d0%9a%d0%b0%d0%ba-%d0%bc%d0%be%d0%b6%d0%bd%d0%be-%d0%b7%d0%b0%d0%bf%d1%80%d0%b5%d1%82%d0%b8%d1%82%d1%8c-%d0%b4%d0%be%d0%b1%d0%b0%d0%b2%d0%bb%d1%8f%d1%82%d1%8c-%d0%b2-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82-%d0%b2%d1%8b%d0%b7%d0%be%d0%b2%d1%8b-%d0%bd%d0%b5%d0%ba%d0%be%d1%82%d0%be%d1%80%d1%8b%d1%85-%d0%bc%d0%b5%d1%82%d0%be%d0%b4%d0%be%d0%b2">Source</a> - by <a href="https://ru.stackoverflow.com/users/22836/4per">4per</a></p>
<blockquote>
<p>Есть какие-либо приёмы запрещающие добавлять в код проекта, вызовы определенных методов? Кроме организационных, конечно.
В частности, хочу убрать возможность использовать все перегрузки <code>System.Windows.Forms.MessageBox.Show()</code> не содержащие параметр <code>IWin32Window owner</code>:</p>
<pre><code>Show(String)
Show(String, String)
Show(String, String, MessageBoxButtons)
Show(String, String, MessageBoxButtons, MessageBoxIcon)
Show(String, String, MessageBoxButtons, MessageBoxIcon, MessageBoxDefaultButton)
Show(String, String, MessageBoxButtons, MessageBoxIcon, MessageBoxDefaultButton, MessageBoxOptions)
Show(String, String, MessageBoxButtons, MessageBoxIcon, MessageBoxDefaultButton, MessageBoxOptions, Boolean)
Show(String, String, MessageBoxButtons, MessageBoxIcon, MessageBoxDefaultButton, MessageBoxOptions, String)
Show(String, String, MessageBoxButtons, MessageBoxIcon, MessageBoxDefaultButton, MessageBoxOptions, String, HelpNavigator)
Show(String, String, MessageBoxButtons, MessageBoxIcon, MessageBoxDefaultButton, MessageBoxOptions, String, HelpNavigator, Object)
Show(String, String, MessageBoxButtons, MessageBoxIcon, MessageBoxDefaultButton, MessageBoxOptions, String, String)
</code></pre>
</blockquote>
<h2>Answer 875173</h2>
<p><a href="https://ru.stackoverflow.com/a/875173/">Source</a> - by <a href="https://ru.stackoverflow.com/users/179921/petr-abdulin">Petr Abdulin</a></p>
<blockquote>
<p>Стандартно нет. А вот например в решарпере есть <a href="https://www.jetbrains.com/help/resharper/Code_Analysis__External_Annotations.html" rel="noreferrer">External Annotations</a> которые позволят добавить атрибуты, например <a href="https://docs.microsoft.com/en-us/dotnet/api/system.obsoleteattribute?view=netframework-4.7.2" rel="noreferrer">Obsolete</a>, к стороннему коду.</p>
</blockquote>
<h2>Answer 875964</h2>
<p><a href="https://ru.stackoverflow.com/a/875964/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<p>Можно написать свою программу для этих целей, воспользовавшись <a href="https://ru.stackoverflow.com/questions/866161/%D0%9D%D0%B0%D0%B9%D1%82%D0%B8-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0-%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B8-%D0%B4%D1%80%D1%83%D0%B3%D0%BE%D0%B3%D0%BE-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0">существующими наработками по парсингу MSIL-кода</a>. Напишем вот такую программу, принимающую на вход путь к сборке, и возвращающую код 0, если она не содержит вызовов запрещенных методов, или код 1 при их наличии (код неэффективный по производительности, воспринимайте только как пример):</p>
<pre><code>//Утилита для проверки сборки на наличие вызовов запрещенных методов
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reflection;
using System.Reflection.Emit;

namespace AssValidator
{
    class Program
    {

        public static OpCode FindOpCode(short val)
        {
            OpCode ret = OpCodes.Nop;
            FieldInfo[] mas = typeof(OpCodes).GetFields();
            for (int i = 0; i &lt; mas.Length; i++)
            {
                if (mas[i].FieldType == typeof(OpCode))
                {
                    OpCode opcode = (OpCode)mas[i].GetValue(null);
                    if (opcode.Value == val)
                    {
                        ret = opcode;
                        break;
                    }
                }
            }
            return ret;
        }

        //получает список методов, вызываемых указанным методом
        public static List&lt;MethodBase&gt; GetCalledMethods(MethodBase mi)
        {
            MethodBody mb = null;

            //получаем тело метода
            try
            {
                mb = mi.GetMethodBody();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.GetType().ToString() + " " + ex.Message);                
            }
            if (mb == null) return new List&lt;MethodBase&gt;();

            //получаем IL-код
            var msil = mb.GetILAsByteArray();

            //получаем модуль, в котором расположен метод
            var module = mi.Module;

            List&lt;MethodBase&gt; methods = new List&lt;MethodBase&gt;();

            short op;
            int n = 0;

            //парсим IL-код...
            while (true)
            {
                if (n &gt;= msil.Length) break;

                //получаем код операции
                if (msil[n] == 0xfe)
                    op = (short)(msil[n + 1] | 0xfe00);
                else
                    op = (short)(msil[n]);

                //найдем имя операции
                OpCode opcode = FindOpCode(op);
                string str = opcode.Name;
                int size = 0;

                //найдем размер операции
                switch (opcode.OperandType)
                {
                    case OperandType.InlineBrTarget: size = 4; break;
                    case OperandType.InlineField: size = 4; break;
                    case OperandType.InlineMethod: size = 4; break;
                    case OperandType.InlineSig: size = 4; break;
                    case OperandType.InlineTok: size = 4; break;
                    case OperandType.InlineType: size = 4; break;
                    case OperandType.InlineI: size = 4; break;
                    case OperandType.InlineI8: size = 8; break;
                    case OperandType.InlineNone: size = 0; break;
                    case OperandType.InlineR: size = 8; break;
                    case OperandType.InlineString: size = 4; break;
                    case OperandType.InlineSwitch: size = 4; break;
                    case OperandType.InlineVar: size = 2; break;
                    case OperandType.ShortInlineBrTarget: size = 1; break;
                    case OperandType.ShortInlineI: size = 1; break;
                    case OperandType.ShortInlineR: size = 4; break;
                    case OperandType.ShortInlineVar: size = 1; break;
                    default:
                        throw new Exception("Unknown operand type.");
                }
                size += opcode.Size;

                int token = 0;
                if (str == "call" || str == "callvirt")
                {
                    //если это вызов метода, найдем токен
                    token = (((msil[n + 1] | (msil[n + 2] &lt;&lt; 8)) |
                        (msil[n + 3] &lt;&lt; 0x10)) | (msil[n + 4] &lt;&lt; 0x18));

                    //найдем метод в модуле по токену
                    try
                    {
                        var method = module.ResolveMethod(token);
                        if (!methods.Contains(method)) methods.Add(method);
                    }
                    catch (Exception ex)
                    {
                        //MessageBox.Show(ex.ToString());
                        Console.WriteLine(ex.GetType().ToString() + " " + ex.Message);
                    }
                }

                n += size; //пропускаем нужное число байтов
            }

            return methods;
        }

        //получает список методов, вызываемых всеми классами в указанной сборке
        public static List&lt;MethodBase&gt; GetCalledMethods(Assembly ass)
        {
            List&lt;MethodBase&gt; methods = new List&lt;MethodBase&gt;();
            var types = ass.GetTypes();

            StringBuilder sb = new StringBuilder();
            foreach (var t in types)
            {                
                //поиск по методам...
                var mlist = t.GetMethods(BindingFlags.Public | BindingFlags.NonPublic |
                    BindingFlags.Instance | BindingFlags.Static);
                foreach (var m in mlist)
                {
                    var arr = GetCalledMethods(m);
                    foreach (var x in arr)
                    {
                        if (!methods.Contains(x)) methods.Add(x);
                    }
                }

                //поиск по конструкторам...
                var clist = t.GetConstructors(BindingFlags.Public | BindingFlags.NonPublic |
                    BindingFlags.Instance | BindingFlags.Static);
                foreach (var m in clist)
                {
                    var arr = GetCalledMethods(m);
                    foreach (var x in arr)
                    {
                        if (!methods.Contains(x)) methods.Add(x);
                    }
                }


            }
            return methods;
        }

        //проверяет указанную сборку на наличие вызовов запрещенных методов
        static bool ValidateAssembly(string path)
        {            

            Assembly ass = Assembly.LoadFrom(path); //загружаем сборку

            var methods = GetCalledMethods(ass); //получаем все вызываемые методы

            foreach (var x in methods)
            {
                var pars = x.GetParameters();

                //вызов метода System.Windows.Forms.MessageBox.Show(string) запрещен
                if (x.DeclaringType.ToString() == "System.Windows.Forms.MessageBox"
                    &amp;&amp; x.Name == "Show"
                    &amp;&amp; pars.Length == 1
                    &amp;&amp; pars[0].ParameterType.Name == "String"
                    )
                {
                    Console.WriteLine("Method call not allowed: MessageBox.Show(String)");
                    return false;
                }
            }

            return true; //не найдено запрещенных методов
        }

        //AssValidator - точка входа
        static void Main(string[] args)
        {

            if (args.Length == 0)
            {
                Console.WriteLine("Error: too few arguments!");                
                Environment.Exit(0xff);
            }

            Console.WriteLine("Validating "+args[0]+" ...");

            try
            {
                bool res = ValidateAssembly(args[0]);
                if (!res) { Console.WriteLine("Assembly is invalid"); Environment.Exit(1); }
                else { Console.WriteLine("Assembly is valid"); Environment.Exit(0); }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Validation error!");
                Console.WriteLine(ex.ToString());
                Environment.Exit(0xff);
            }
        }
    }
}
</code></pre>
<p>Соберем ее (желательно в режиме Release, так как процесс довольно тяжелый), и разместим полученный файл так, что путь к нему будет, допустим, <code>D:\Distr\AssValidator\AssValidator.exe</code>. </p>
<p>В свойствах проекта, на вкладке "События построения", зададим событие после построения: </p>
<pre><code>"D:\Distr\AssValidator\AssValidator.exe" $(TargetPath)
</code></pre>
<p>Теперь, при попытке собрать проект с запрещенным методом получим ошибку построения </p>
<pre><code>error MSB3073: выход из команды ""D:\Distr\AssValidator\AssValidator.exe" d:\...\WindowsFormsApplication1.exe" с кодом 1.
</code></pre>
<p>Выглядит это как-то так:</p>
<p><a href="https://i.stack.imgur.com/a0lQ3.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/a0lQ3.png" alt="VS screeshots"></a></p>
<p>Протестировано для .NET 4.5 / VS 2012.</p>
<p>Недостатки способа:</p>
<ul>
<li><p>В ходе проверки сборки может быть выполнен код из нее (например, статические конструкторы). В том числе, этот код может упасть с исключением и нарушить все.</p></li>
<li><p>Чтобы работало для не-<em>AnyCPU</em> проектов, понадобится две версии проверяющей программы (32-битная и 64-битная)</p></li>
<li><p>Хотя при непрохождении проверки построение завершается с ошибкой, сам скомпилированный файл сборки остается. Опять же, можно создать BAT-файл, удаляющий сборку при неудачном результате проверки.</p></li>
</ul>
</blockquote>
<h2>Answer 876456</h2>
<p><a href="https://ru.stackoverflow.com/a/876456/">Source</a> - by <a href="https://ru.stackoverflow.com/users/10105/vladd">VladD</a></p>
<blockquote>
<p>Здесь упоминалось решение с Roslyn API, его тоже несложно сделать.</p>
<p>Для начала, создадим анализатор, как показано в <a href="https://ru.stackoverflow.com/a/756891/10105">этом ответе</a>. Мы не можем придумать разумный code fix, поэтому у нас будет лишь анализ и подсвечивание красной волнистой линией.</p>
<p>Код нашего анализатора такой:</p>
<pre><code>using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace OverloadAnalyzer
{
    [DiagnosticAnalyzer(LanguageNames.CSharp)]
    public class OverloadAnalyzerAnalyzer : DiagnosticAnalyzer
    {
        public const string DiagnosticId = "OverloadAnalyzer";

        private static readonly string Title = "MessageBox.Show only with owner";
        private static readonly string MessageFormat = "Use overload with owner";
        private static readonly string Description =
            "You must always specify an owner for MessageBox.Show";
        private const string Category = "Framework usage";

        // соберём описание нашего правила
        private static DiagnosticDescriptor Rule = new DiagnosticDescriptor(
            DiagnosticId, Title, MessageFormat, Category,
            DiagnosticSeverity.Error, // укажен, что это ошибка, а не предупреждение
            isEnabledByDefault: true, description: Description);

        // список диагностик, которые мы выдаём
        public override ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics =&gt;
            ImmutableArray.Create(Rule);

        // при инициализации подпишемся на анализ всех команд вызова функции
        public override void Initialize(AnalysisContext context)
        {
            context.RegisterSyntaxNodeAction(AnalyzeSymbol,
                                             SyntaxKind.InvocationExpression);
        }

        // сам анализатор
        private static void AnalyzeSymbol(SyntaxNodeAnalysisContext context)
        {
            // получаем синтаксический узел, приводим его к типу «вызов функции»
            var invocationNode = (InvocationExpressionSyntax)context.Node;

            // мелкая эвристика для ускорения: если среди имён в выражении нет Show,
            // дальнейший дорогой семантический анализ не имеет смысла
            if (!invocationNode.DescendantNodes()
                               .OfType&lt;IdentifierNameSyntax&gt;()
                               .Any(n =&gt; n.Identifier.ValueText == "Show"))
                return;

            // получаем символ у семантической модели
            var symInfo = context.SemanticModel.GetSymbolInfo(invocationNode);
            var methodSymbol = (IMethodSymbol)symInfo.Symbol;
            // если его нет (например, у нас некомпилирующийся код), отваливаем
            if (methodSymbol == null)
                return;

            // проверяем, что это действительно вызов MessageBox.Show
            if (methodSymbol.ContainingAssembly.Name != "System.Windows.Forms")
                return;
            if (methodSymbol.ContainingType.ToDisplayString() !=
                    "System.Windows.Forms.MessageBox")
                return;

            // если в списке параметров есть параметр с типом IWin32Window, всё хорошо
            if (methodSymbol.Parameters.Any(p =&gt; p.Type.Name == "IWin32Window"))
                return;

            // иначе говорим юзеру «атата!»
            var diagnostic = Diagnostic.Create(Rule, invocationNode.GetLocation());
            context.ReportDiagnostic(diagnostic);
        }
    }
}
</code></pre>
<p>Получаем вот такое поведение:</p>
<p><a href="https://i.stack.imgur.com/LtMNL.gif" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/LtMNL.gif" alt="а я Roslyn ещё больше ку!"></a></p>
<p>Если вы хотите ещё и проверять код во время построения (а то вдруг программист отключит анализатор или не использует Visual Studio?), вам нужно будет написать ещё и анализатор командной строки, аналогично тому, как описано <a href="https://ru.stackoverflow.com/a/810044/10105">здесь</a>, и запускать его при построении на build-сервере (или в post-build step).</p>
<p>У меня получился вот такой анализатор командной строки:</p>
<pre><code>using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

using Microsoft.Build.Locator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Symbols;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.MSBuild;

namespace CommandLineOverloadAnalyzer
{
    class Program
    {
        static void Usage()
        {
            Console.WriteLine("Usage: CommandLineOverloadAnalyzer.exe SolutionPath" +
                              " MSBuildPath [\"batch\"]");
            Console.WriteLine("if batch specified, no extra output is done");
            Console.WriteLine("if no batch specified, MSBuildPath may be omitted" +
                              " and will be asked for if needed");
        }

        static async Task&lt;int&gt; Main(string[] args)
        {
            if ((args.Length &lt; 1 || args.Length &gt; 3) ||
                (args.Length == 3 &amp;&amp; args[2] != "batch"))
            {
                Usage();
                return 1;
            }
            var solutionPath = args[0];
            var msBuildPath = (args.Length &gt; 1) ? args[1] : null;
            bool batchMode = args.Length == 3;

            // найдём версию MSBuild
            var visualStudioInstances =
                MSBuildLocator.QueryVisualStudioInstances().ToArray();
            var instance =
                // указан путь, выбираем его
                (msBuildPath != null) ? visualStudioInstances.SingleOrDefault(
                                                   i =&gt; i.MSBuildPath == msBuildPath) :
                // только одна студия, выбираем её
                visualStudioInstances.Length == 1 ? visualStudioInstances[0] :
                // в пакетном режиме? падаем
                batchMode ? null :
                // спрашиваем у юзера
                SelectVisualStudioInstance(visualStudioInstances);
            if (instance == null)
            {
                Console.WriteLine("Cannot determine MSBuild path");
                return 1;
            }

            void Out(string s)
            {
                if (!batchMode)
                    Console.WriteLine(s);
            }

            Out($"Using MSBuild at '{instance.MSBuildPath}' to load projects.");

            // Экземпляр MSBuildLocator должен быть зарегистрирован
            // перед MSBuildWorkspace.Create(), иначе MEF-композиция не сработает
            MSBuildLocator.RegisterInstance(instance);

            bool hadProblems = false;
            using (var workspace = MSBuildWorkspace.Create())
            {
                // Напечатаем сообщение при приходе WorkspaceFailed, чтобы
                // помочь с диагностикой проблем загрузки проектов
                workspace.WorkspaceFailed += (o, e) =&gt; Out(e.Diagnostic.Message);

                Out($"Loading solution '{solutionPath}'");

                // печатаем прогресс при интерактивной загрузке
                var solution = await workspace.OpenSolutionAsync(solutionPath,
                    batchMode ? null : new ConsoleProgressReporter());
                Out($"Finished loading solution '{solutionPath}'");

                foreach (var project in solution.Projects)
                {
                    Out($"Processing project {project.Name}");
                    var compilation = await project.GetCompilationAsync();

                    // для каждого файла в проекте отдельное синтаксическое дерево
                    foreach (var syntaxTree in compilation.SyntaxTrees)
                    {
                        var root = await syntaxTree.GetRootAsync();
                        // создаём семантический анализатор
                        var model = compilation.GetSemanticModel(syntaxTree);
                        // получаем все типы переменных
                        foreach (var invocationNode in root.DescendantNodes()
                                             .OfType&lt;InvocationExpressionSyntax&gt;())
                        {
                            if (!invocationNode.DescendantNodes()
                                               .OfType&lt;IdentifierNameSyntax&gt;()
                                               .Any(n =&gt; n.Identifier.ValueText == "Show"))
                                continue;

                            var symInfo = model.GetSymbolInfo(invocationNode);
                            var methodSymbol = (IMethodSymbol)symInfo.Symbol;
                            if (methodSymbol == null)
                                continue;
                            if (methodSymbol.ContainingAssembly.Name !=
                                    "System.Windows.Forms")
                                continue;
                            if (methodSymbol.ContainingType.ToDisplayString() !=
                                    "System.Windows.Forms.MessageBox")
                                continue;

                            if (methodSymbol.Parameters.Any(p =&gt; p.Type.Name ==
                                    "IWin32Window"))
                                continue;

                            var location = invocationNode.GetLocation().GetLineSpan();
                            Console.WriteLine(
                                $"MessageBox.Show usage is wrong, location = {location}");
                            hadProblems = true;
                        }
                    }
                }
            }

            return hadProblems ? 1 : 0;
        }

        private static VisualStudioInstance SelectVisualStudioInstance(
            VisualStudioInstance[] visualStudioInstances)
        {
            Console.WriteLine("Multiple installs of MSBuild detected, please select one:");
            for (int i = 0; i &lt; visualStudioInstances.Length; i++)
            {
                Console.WriteLine($"Instance {i + 1}");
                Console.WriteLine($"    Name: {visualStudioInstances[i].Name}");
                Console.WriteLine($"    Version: {visualStudioInstances[i].Version}");
                Console.WriteLine(
                    $"    MSBuild Path: {visualStudioInstances[i].MSBuildPath}");
            }

            while (true)
            {
                var userResponse = Console.ReadLine();
                if (int.TryParse(userResponse, out int instanceNumber) &amp;&amp;
                    instanceNumber &gt; 0 &amp;&amp;
                    instanceNumber &lt;= visualStudioInstances.Length)
                {
                    return visualStudioInstances[instanceNumber - 1];
                }
                Console.WriteLine("Input not accepted, try again.");
            }
        }

        private class ConsoleProgressReporter : IProgress&lt;ProjectLoadProgress&gt;
        {
            public void Report(ProjectLoadProgress loadProgress)
            {
                var projectDisplay = Path.GetFileName(loadProgress.FilePath);
                if (loadProgress.TargetFramework != null)
                {
                    projectDisplay += $" ({loadProgress.TargetFramework})";
                }

                Console.WriteLine(
                    $"{loadProgress.Operation,-15}" +
                    $" {loadProgress.ElapsedTime,-15:m\\:ss\\.fffffff}" +
                    $" {projectDisplay}");
            }
        }

        private class SilentProgressReporter : IProgress&lt;ProjectLoadProgress&gt;
        {
            public void Report(ProjectLoadProgress loadProgress) { }
        }
    }
}
</code></pre>
<p>В Post-Build step укажите просто</p>
<pre><code>"&lt;путь к анализатору&gt;\CommandLineOverloadAnalyzer.exe" "$(SolutionPath)" "$(MSBuildBinPath)" batch
</code></pre>
<p>У меня при пробном пробеге вывело:</p>
<blockquote>
  <p>MessageBox.Show usage is wrong, location = &lt;полный путь>\RoslynTest\SampleApp\Program.cs: (13,12)-(13,46)</p>
</blockquote>
</blockquote>
<hr>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>RuSO Archive (published from sources in <a href="https://github.com/MSDN-WhiteKnight/ruso-archive">GitHub repository</a>). Content licensed under <a href="https://github.com/MSDN-WhiteKnight/ruso-archive/blob/master/LICENSE">CC-BY-SA 4.0</a>.<br>Generated by <strong>DocFX</strong></span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../../styles/main.js"></script>
  </body>
</html>
