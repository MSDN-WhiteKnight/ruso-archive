<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#1041;&#1077;&#1079;&#1086;&#1087;&#1072;&#1089;&#1085;&#1086;&#1089;&#1090;&#1100; &#1080;&#1089;&#1087;&#1086;&#1083;&#1100;&#1079;&#1086;&#1074;&#1072;&#1085;&#1080;&#1103; &#1084;&#1077;&#1090;&#1086;&#1076;&#1086;&#1074; &#1088;&#1072;&#1089;&#1096;&#1080;&#1088;&#1077;&#1085;&#1080;&#1103; | RuSO Archive </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#1041;&#1077;&#1079;&#1086;&#1087;&#1072;&#1089;&#1085;&#1086;&#1089;&#1090;&#1100; &#1080;&#1089;&#1087;&#1086;&#1083;&#1100;&#1079;&#1086;&#1074;&#1072;&#1085;&#1080;&#1103; &#1084;&#1077;&#1090;&#1086;&#1076;&#1086;&#1074; &#1088;&#1072;&#1089;&#1096;&#1080;&#1088;&#1077;&#1085;&#1080;&#1103; | RuSO Archive ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../../../../favicon.ico">
    <link rel="stylesheet" href="../../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../../index.html">
                <img id="logo" class="svg" src="../../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">

<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Безопасность использования методов расширения</h1>
<p><a href="https://ru.stackoverflow.com/questions/906663/%d0%91%d0%b5%d0%b7%d0%be%d0%bf%d0%b0%d1%81%d0%bd%d0%be%d1%81%d1%82%d1%8c-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f-%d0%bc%d0%b5%d1%82%d0%be%d0%b4%d0%be%d0%b2-%d1%80%d0%b0%d1%81%d1%88%d0%b8%d1%80%d0%b5%d0%bd%d0%b8%d1%8f">Source</a> - by <a href="https://ru.stackoverflow.com/users/315948/%d0%9f%d0%b0%d0%b4%d0%b6%d0%b5%d1%80%d1%81">Паджерс</a></p>
<blockquote>
<p>Как я понимаю, методы самого класса в приоритете перед методами расширения.</p>
<p>Возникает закономерный вопрос:</p>
<p>А что будет, если я вот наплодил методы расширения, а потом через какое-то время выходит новая версия библиотеки, где определен точно такой же метод в классе. Выходит, он будет в приоритете и может работать несколько иначе — все поломается.</p>
<p>Получается, методы расширения — это опасная штука?</p>
<p>Вот пример:</p>
<pre><code>public class Person
{
    public void Say()
    {
        Console.WriteLine("1");
    }
}

public static class Test
{
    public static void Say(this Person p)
    {
        Console.WriteLine("2");
    }
}

class Program
{         
    static void Main(string[] args)
    {
        var t = new Person();
        t.Say();
    } 
}
</code></pre>
<p>Допустим, мы реализовали метод <code>Say</code> в виде расширения и он выводил нам <code>2</code>, затем приходит обновление либы и тут бац и выводится <code>1</code>. Никаких предупреждений компилятор не выдает, хотя он выдает предупреждение в том случае если мы наследуемся и объявляем метод с такой же сигнатурой и он просит написать <code>new</code>.</p>
<p>Еще забавно, что нельзя контролировать вызов конкретного метода-расширения, если есть пересечения между пространствами имен. В этом случае единственный вариант- это вызов через статику, что убивает удобство использования расширений.</p>
</blockquote>
<h2>Answer 948204</h2>
<p><a href="https://ru.stackoverflow.com/a/948204/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<blockquote>
  <p>Получается, методы расширения — это опасная штука?</p>
</blockquote>
<p>Да, это несомненно так. Методы расширения — грубый хак, нарушающий принципы объектно-ориентированного программирования, и помимо проблемы неконтролируемого скрытия членами расширяемого класса они также страдают от проблемы конфликтов между самими собой (ведь разные библиотеки могут создавать методы расширения для одного класса). Чрезмерно использовать их не стоит. </p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/extension-methods" rel="noreferrer">Framework Design Guidelines</a> явно не рекомендуют это:</p>
<blockquote>
  <p><strong>AVOID</strong> frivolously defining extension methods, especially on types you don’t own. </p>
</blockquote>
<p>Там же упоминают два случая, когда использование методов расширения оправдано:</p>
<ul>
<li><p>Добавление какого-либо функционала во все типы, реализующие определенный интерфейс. В этом случае опасность несколько ниже, ведь в интерфейсы обычно не добавляют новые методы (так как это требовало бы переписывания кода кучи классов, которые уже реализуют этот интерфейс). Именно таким образом работает LINQ.</p></li>
<li><p>Методы, завязанные на типы, определенные в вашем собственном коде. Допустим, вы создаете метод расширения к классу <code>String</code>, принимающий аргумент типа <code>Person</code>, определенного в вашем проекте. В этом случае описанного конфликта также не будет, ведь даже если MS добавят новый метод в класс <code>String</code>, он точно никак не будет использовать класс из вашего кода.  </p></li>
</ul>
<p>К сожалению, следование этим рекомендациям все равно полностью не решает проблемы, так как остаются конфликты между самими методами расширений из разных библиотек. Именно <a href="https://github.com/morelinq/MoreLINQ/issues/351" rel="noreferrer">с этой проблемой</a> столкнулись разработчики библиотеки MoreLinq. </p>
<p>Конечно, Framework Design Guidelines — это рекомендации для разработчиков публичных API библиотек, а не любого кода в приложениях. Но сути это мало меняет, так как нужно стремиться делать любой код пригодным к повторному использованию. Проекты имеют тенденцию расти, разделяться и т.п; какой-то код, который раньше использовался только в одном проекте, впоследствии захочется вынести в общую библиотеку. Поэтому эти рекомендации во многом можно распространить и на код приложений.</p>
</blockquote>
<hr>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>RuSO Archive (published from sources in <a href="https://github.com/MSDN-WhiteKnight/ruso-archive">GitHub repository</a>). Content licensed under <a href="https://github.com/MSDN-WhiteKnight/ruso-archive/blob/master/LICENSE">CC-BY-SA 4.0</a>.<br>Generated by <strong>DocFX</strong></span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../../styles/main.js"></script>
  </body>
</html>
