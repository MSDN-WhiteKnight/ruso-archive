<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#1040;&#1085;&#1072;&#1083;&#1086;&#1075; PtrToStructure &#1076;&#1083;&#1103; &#1082;&#1083;&#1072;&#1089;&#1089;&#1086;&#1074; | RuSO Archive </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#1040;&#1085;&#1072;&#1083;&#1086;&#1075; PtrToStructure &#1076;&#1083;&#1103; &#1082;&#1083;&#1072;&#1089;&#1089;&#1086;&#1074; | RuSO Archive ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../../../../favicon.ico">
    <link rel="stylesheet" href="../../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../../index.html">
                <img id="logo" class="svg" src="../../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">

<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Аналог PtrToStructure для классов</h1>
<p><a href="https://ru.stackoverflow.com/questions/880130/%d0%90%d0%bd%d0%b0%d0%bb%d0%be%d0%b3-ptrtostructure-%d0%b4%d0%bb%d1%8f-%d0%ba%d0%bb%d0%b0%d1%81%d1%81%d0%be%d0%b2">Source</a> - by <a href="https://ru.stackoverflow.com/users/248572/kir-antipov">Kir_Antipov</a></p>
<blockquote>
<p>Товарищи, стал мне интересен следующий вопрос:</p>
<p>Положим, есть у нас примера ради структура <code>System.Drawing.Point</code><br>
Мы спокойно можем баловаться с ней следующим образом:</p>
<pre><code>// Инициализируем нашу структурку
Point point = new Point(2, 3);

// Получаем ее адрес
Point* pointer = &amp;point;

// Получим ее данные
int x = ((int*)pointer)[0]; // 2
int y = ((int*)pointer)[1]; // 3

// Получаем ту же структуру, разыменовав указатель
Point copied = *pointer;

// Или так (получаем нулевую `Point` по указателю)
copied = pointer[0];

// Или даже так
copied = Marshal.PtrToStructure&lt;Point&gt;(new IntPtr(pointer));
</code></pre>
<p>В общем, имея указатель, мы спокойно можем получить <strong>структуру</strong> в явном виде</p>
<hr>
<p>Теперь же отойдем от <em>типов значения</em> и перейдем к типам <em>ссылочным</em>, то есть поговорить я хочу о подобных механизмах для <strong>классов</strong></p>
<p>Оперируя инстансами классов, мы на деле оперируем их ссылками, то есть, получив указатель, мы получим указатель на ссылку на определенный участок памяти, где как раз и можно найти данные объекта</p>
<p>То есть следующий псевдо-код:</p>
<pre><code>// Обозначим instance'ы классов
MyClass my0 = new MyClass { A = 2 };
MyClass my1 = new MyClass { A = 3 };

// Некоторые действия
IntPtr* ptr0 = ...;
IntPtr* ptr1 = ...;

IntPtr tmp = *ptr0;

ptr0[0] = ptr1[0];
ptr1[0] = tmp;

Console.WriteLine(my0.A); // 3
Console.WriteLine(my1.A); // 2
</code></pre>
<p>На деле аналогичен простой смене переменных местами</p>
<hr>
<p>И вот теперь главный вопрос: каким образом, имея указатель, я могу также, как и в случае со структурой, получить объект?</p>
<p>Проблема в том, что </p>
<ul>
<li>Создание указателя на класс - невозможно (ошибка <a href="https://docs.microsoft.com/ru-ru/dotnet/csharp/misc/cs0208" rel="nofollow noreferrer">CS0208</a>)</li>
<li>А <a href="https://msdn.microsoft.com/ru-ru/library/system.runtime.interopservices.marshal.ptrtostructure%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396" rel="nofollow noreferrer">Marshal.PtrToStructure</a> также рассчитан только на структуры</li>
</ul>
<p>То есть я ищу нечто такое:</p>
<pre><code>IntPtr* pointer = ...;
// Я знаю, что это не работает, это просто псевдо-код
MyClass my = *((MyClass*)pointer);
my = Marshal.PtrToClass&lt;MyClass&gt;(new IntPtr(pointer));
</code></pre>
<hr>
<p>Собственно, <strong>возможно ли</strong> такое в <code>C#</code> (не думаю, что прямо совсем никак) и, если да, то <strong>как</strong>?</p>
<p>Приветствуются даже самые безумные идеи!</p>
</blockquote>
<h2>Answer 1004583</h2>
<p><a href="https://ru.stackoverflow.com/a/1004583/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<blockquote>
  <p>Создание указателя на класс - невозможно (ошибка CS0208)</p>
</blockquote>
<p>Создание указателя на класс невозможно напрямую, так как он управляется сборщиком мусора и может быть перемещен в памяти. Однако, класс можно закрепить с помощью Pinned GCHandle и получить указатель на закрепленный объект - но для этого класс должен состоять только из простых типов и иметь атрибут <code>[StructLayout(LayoutKind.Sequential)]</code> (несмотря на название, его можно применить и к классу).</p>
<blockquote>
  <p>А Marshal.PtrToStructure также рассчитан только на структуры</p>
</blockquote>
<p>Строго говоря, это не так. Marshal.PtrToStructure работает и c классами, если они удовлетворяют тем же условиям: состоят только из простых типов и имеют атрибут <code>[StructLayout(LayoutKind.Sequential)]</code>.</p>
<p>Вот пример использования указателей на класс:</p>
<pre><code>    [StructLayout(LayoutKind.Sequential)]
    class MyClass
    {
        public int A;            

        public override string ToString()
        {
            return A.ToString();
        }
    }

    static void Main(string[] args)
    {
        MyClass my0 = new MyClass { A = 2 };
        MyClass my1 = new MyClass { A = 3 };                       

        //закрепим объекты в памяти
        GCHandle h0 = GCHandle.Alloc(my0, GCHandleType.Pinned);
        GCHandle h1 = GCHandle.Alloc(my1, GCHandleType.Pinned);

        try
        {
            //получим адреса объектов
            IntPtr ptr0 = h0.AddrOfPinnedObject();
            IntPtr ptr1 = h1.AddrOfPinnedObject();

            //убедимся, что адреса реальные и по ним можно считать данные (первое поле класса)
            Console.WriteLine("Значение по ptr0: " + Marshal.ReadInt32(ptr0));
            Console.WriteLine("Значение по ptr1: " + Marshal.ReadInt32(ptr1));

            IntPtr tmp = ptr0;
            ptr0 = ptr1;
            ptr1 = tmp;

            my0 = Marshal.PtrToStructure&lt;MyClass&gt;(ptr0);
            my1 = Marshal.PtrToStructure&lt;MyClass&gt;(ptr1);

            Console.WriteLine("my0.A=" + my0);
            Console.WriteLine("my1.A=" + my1);
        }
        finally
        {
            //вернем объекты в управление GC
            h0.Free();
            h1.Free();
        }           

        Console.ReadLine();
    }
</code></pre>
<p>В отличие от принятого ответа, здесь используется указатель на сами данные класса, а не на заголовок объекта. Также при вызове Marshal.PtrToStructure создается новая копия объекта, вместо разыменования указателя на существующий объект. </p>
</blockquote>
<h2>Answer 880147</h2>
<p><a href="https://ru.stackoverflow.com/a/880147/">Source</a> - by <a href="https://ru.stackoverflow.com/users/9784/zergatul">Zergatul</a></p>
<blockquote>
<p>Есть несколько причин, почему это невозможно.</p>
<p><code>Marshal.PtrToStructure&lt;Point&gt;</code> создает копию структуры. Например,
   если вы присвоите результат в локальную переменную, копия
   структуры переместится в стек. После вызова этого метода, вы можете
   изменять память, откуда была скопирована структура, и с вашей копией
   ничего не случиться. Как видно, сама операция безопасна с точки зрения целостности программы.</p>
<p>Под <code>Marshal.PtrToClass&lt;MyClass&gt;</code> вы скорее всего подразумеваете разыменование указателя (по аналогии с С++). Сборщик мусора может остановить выполнение целой программы в любом месте, и переместить объекты в памяти. Может случиться что-то такое:</p>
<pre><code>IntPtr ptr = получить_указатель_на_экземпляр_класса();
// здесь сборщик мусора остановил потоки, и переместил класс в новое место
MyClass instance = Marshal.PtrToClass&lt;MyClass&gt;(ptr); // ptr указывает непонятно куда
</code></pre>
<p><code>Marshal.PtrToStructure</code> был придуман для взаимодействия с нативным кодом. <code>.NET</code>-классы не могут в обычном понимании существовать в нативном коде, поэтому <code>PtrToClass</code> не существует.</p>
<p>Так же есть простой способ при помощи <code>GCHandle</code>, который запрещает перемещение объектов в памяти.</p>
<p>Но на C# можно и такое сделать:</p>
<pre><code>private static unsafe T PtrToClass&lt;T&gt;(IntPtr ptr)
{
    T temp = default(T);
    TypedReference tr = __makeref(temp);
    Marshal.WriteIntPtr(*(IntPtr*)(&amp;tr), ptr);

    T instance = __refvalue(tr, T);
    return instance;
}
</code></pre>
<p>Пример использования:</p>
<pre><code>class MyClass
{
    public int Value;
}
static unsafe void Main(string[] args)
{
    var instance1 = new MyClass { Value = 123 };
    var instance2 = new MyClass { Value = 321 };

    // запрещаем перемещение объектов в памяти
    var gh1 = GCHandle.Alloc(instance1, GCHandleType.Pinned);
    var gh2 = GCHandle.Alloc(instance2, GCHandleType.Pinned);

    TypedReference tr1 = __makeref(instance1);
    TypedReference tr2 = __makeref(instance2);

    IntPtr ptr1 = **(IntPtr**)(&amp;tr1);
    IntPtr ptr2 = **(IntPtr**)(&amp;tr2);

    var instance3 = PtrToClass&lt;MyClass&gt;(ptr1);
    var instance4 = PtrToClass&lt;MyClass&gt;(ptr2);
    Console.WriteLine(instance3.Value);
    Console.WriteLine(instance4.Value);

    // разрешаем GC перемещать объекты
    gh1.Free();
    gh2.Free();
}
</code></pre>
</blockquote>
<h2>Answer 880322</h2>
<p><a href="https://ru.stackoverflow.com/a/880322/">Source</a> - by <a href="https://ru.stackoverflow.com/users/178779/pavel-mayorov">Pavel Mayorov</a></p>
<blockquote>
<p>Вы не можете превратить указатель в объект по той простой причине что вам неоткуда взять указатель на объект: .net просто не дает такой возможности.</p>
<p>Но если на самом деле вам не нужен именно указатель на объект, а достаточно лишь IntPtr - можно использовать GCHandle.</p>
<p>Создание GCHandle:</p>
<pre><code>GCHandle.Alloc(obj).ToIntPtr()
</code></pre>
<p>Удаление GCHandle (если не сделать - будет утечка памяти!)</p>
<pre><code>GCHandle.FromIntPtr(ptr).Free()
</code></pre>
<p>Преобразование в объект:</p>
<pre><code>GCHandle.FromIntPtr(ptr).Target
</code></pre>
</blockquote>
<hr>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>RuSO Archive (published from sources in <a href="https://github.com/MSDN-WhiteKnight/ruso-archive">GitHub repository</a>). Content licensed under <a href="https://github.com/MSDN-WhiteKnight/ruso-archive/blob/master/LICENSE">CC-BY-SA 4.0</a>.<br>Generated by <strong>DocFX</strong></span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../../styles/main.js"></script>
  </body>
</html>
