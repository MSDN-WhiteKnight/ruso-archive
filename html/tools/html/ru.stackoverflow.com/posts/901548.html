<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#1047;&#1072;&#1095;&#1077;&#1084; &#1085;&#1091;&#1078;&#1085;&#1072; &#1076;&#1080;&#1085;&#1072;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1072;&#1103; &#1090;&#1080;&#1087;&#1080;&#1079;&#1072;&#1094;&#1080;&#1103;? | RuSO Archive </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#1047;&#1072;&#1095;&#1077;&#1084; &#1085;&#1091;&#1078;&#1085;&#1072; &#1076;&#1080;&#1085;&#1072;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1072;&#1103; &#1090;&#1080;&#1087;&#1080;&#1079;&#1072;&#1094;&#1080;&#1103;? | RuSO Archive ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../../../../favicon.ico">
    <link rel="stylesheet" href="../../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../../index.html">
                <img id="logo" class="svg" src="../../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">

<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Зачем нужна динамическая типизация?</h1>
<p><a href="https://ru.stackoverflow.com/questions/901548/%d0%97%d0%b0%d1%87%d0%b5%d0%bc-%d0%bd%d1%83%d0%b6%d0%bd%d0%b0-%d0%b4%d0%b8%d0%bd%d0%b0%d0%bc%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%b0%d1%8f-%d1%82%d0%b8%d0%bf%d0%b8%d0%b7%d0%b0%d1%86%d0%b8%d1%8f">Source</a> - by <a href="https://ru.stackoverflow.com/users/32793/iluxa1810">iluxa1810</a></p>
<blockquote>
<p>Есть класс языков, где типизация динамическая, например JavaScript, VB и т д.</p>
<p>Мне как приверженцу строгой типизации не понятен сакральный смысл этого.</p>
<p>Ну да, вроде, прикольно на ходу строить класс в JavaScript. Однако, какой в этом смысл? Ведь я могу здесь и сейчас все объявить и построить необходимые модели, ведь я заранее должен знать с чем мне придется работать.</p>
<p>В T-SQL динамические запросы обоснованы, но опять же все сводится к конечному множеству каких-нибудь фильтров фильтров.</p>
<p>По моему одни минусы:</p>
<ol>
<li>IDE, как правило, не может во время запуска тут же выдать ошибки</li>
<li>Криво работает автоподстановка вариантов, так как переменная динамическая</li>
<li>Да и в голове нужно помнить, что вот эта переменная имеет такой-то тип, а тут она поменяла тип на другой...</li>
</ol>
</blockquote>
<h2>Answer 903657</h2>
<p><a href="https://ru.stackoverflow.com/a/903657/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<p>Компактность кода, в основном. Допустим, у нас есть несколько классов, занимающих совершенно разное место в иерархии наследования, но объединенных наличием общего метода SaveToFile, принимающего один строковый аргумент (путь к файлу). Затем мы хотим написать функцию, которая будет сохранять в файл все элементы из массива произвольных объектов.</p>
<p>На языке со статической типизацией нам нужно будет объявить интерфейс, пометить все классы с методом SaveToFile как реализующие его, и использовать приведение типов:</p>
<pre><code>interface ISaveable{
  void SaveToFile(string path);
}

void SaveAll(object[] array, string path){
    for(int i=0; i&lt;array.Length; i++){
       ((ISaveable)array[i]).SaveToFile(path + '_' + i.ToString());
    }
}
</code></pre>
<p>На языке с динамической типизацией все будет намного короче:</p>
<pre><code>function SaveAll(array, path){
    for(i=0; i&lt;array.length; i++){
       array[i].SaveToFile(path + '_' + i);
    }
}
</code></pre>
<p>Краткость кода не всегда приветствуется, но для скриптовых языков, на которых часто пишутся программы "на один раз", или когда важна экономия на размере исходного кода (браузерный JavaScript), это преимущество может выходить на первый план. </p>
<p>Подробнее по сравнению динамической и статической типизации: <a href="https://softwareengineering.stackexchange.com/questions/246762/is-there-a-real-advantage-to-dynamic-languages">Is there a real advantage to dynamic languages?</a></p>
</blockquote>
<h2>Answer 904210</h2>
<p><a href="https://ru.stackoverflow.com/a/904210/">Source</a> - by <a href="https://ru.stackoverflow.com/users/213977/%d0%93%d0%be%d0%bd%d1%87%d0%b0%d1%80%d0%be%d0%b2-%d0%90%d0%bb%d0%b5%d0%ba%d1%81%d0%b0%d0%bd%d0%b4%d1%80">Гончаров Александр</a></p>
<blockquote>
<p>Дело в том, что отсутствие типов убивает сразу много зайцев. Главные - это читаемость кода, и повышение простоты программирования в целом. Первое - это очень важно стратегически, чтобы при большом объёме кода, долгой разработке проект по прежнему был читаем и расширяем, второе - тактически - чтобы быстро решать задачи. Но приверженец строгой типизации может не почувствовать этих плюсов на первых порах, например я сам перешёл когда-то с C++ на JS и PHP - и наверное ещё год негодовал. Постараюсь объяснить..</p>
<p><strong>Ресурсы мозга</strong>. Присутствие типов в коде создаёт дополнительную неслабую смысловую нагрузку, и требует серьёзных мозговых затрат на запоминание иерархии, на чтение кода, на то чтобы эти самые типы прописывать при каждом "чихе" в коде. В компилируемом коде типы раньше несли за собой главный их смысл - максимальную скорость работы программы, минимальный расход ОП. Для скриптовых языков такой цели как правило не стоит (да и современные компиляторы уже не слишком много отъедают при отсутствии типов), и поэтому решающие факторы типизации языка - именно восприятие типов мозгами программистов в контексте задач скриптового языка.</p>
<p><strong>Структурная сложность</strong>.  В скриптах делается упор на возможную сложность скрипта, при высокой читаемости. И тут JS приуспел - читая любой JS-код можно увидеть, как уводится внимание от объектно-типовой составляеющей, и фокусируется внимание на структурной составляющей: вложенные замыкания, функциональное программирование, асинхронное программирование. И были бы в JS типы - такого эффекта восприятия кода конечно бы не было. </p>
<p><strong>Читаемость</strong>. Если грамотно именовать, переменные в коде JS - то код будет читаться как книга, несмотря на структурную сложность. Но когда к переменным добавляются типы - читаемость сильно теряет: читающий программист получает много лишней информации. Вот в быту мы говорим <code>Убери яблоко в холодильник</code> а не <code>Убери красное круглое яблоко в большой серебристый холодильник</code>, так как первое проще воспринимается. Например, чтение JS кода любой широко-распостраннённой библиотеки я бы сравнил с чтением стихов Пушкина, тогда как чтение типизированного C++ кода с чтением Иллиады Гомера (теперь уже).</p>
<p><strong>Про простоту программирования без типов</strong>. Выходит так, что без типов, и с развитыми функциональными инструментами: половина паттернов не нужна, вторая половина паттернов записывается в три строчки вместо 15-ти. Классическая реализация старых паттернов GoF в типизированных языках сегодня больше похожа на костыли, которые просто есть, чтобы компенсировать недостаток гибкости при наличии строгой типизации - соответственно они нечитаемы, с ними надо серьёзнее разбираться, забивать себе голову вопросами "зачем это?" "это фасад или адаптер?", и.т.п. В JS же появляются плюс к старым совсем другие подходы, основанные на замыканиях, инкапсуляции, и ФП. При реализации одной-и-той же задачи в стиле ООП-классики на TS, и в стиле ФП на JS, что выходит в итоге:  </p>
<ol>
<li>Код на JS получается компактнее раза в 3, и читаемее, чем код со строгой типизацией на том-же TS.  </li>
<li>Программист реализует задачу быстрее, пропорционально объёму кода.  </li>
</ol>
<p>Плюс JS работает в основном с древовидной базой данных под названием DOM - и его задача, это в основном управление этим DOM в динамике. То есть никаких серьёзных ООП структур не требуется, встроенного хватает с лихвой: обработки DOM событий, асинхронных возможностей JS. Это вкупе с отсутсвием типизации делает JS-код "квинтэссенцией управляющей логики". "Простота программирования" - это не значит, что у программистов JS будет халява, это значит что хороший программист успеет сделать в 3 раза больше.</p>
<p><strong>Что теряет JS без типов?</strong><br>
<em>Первое, что теряет JS</em> - автоматическую валидацию входящих параметров функции - это почти главная роль которую исполняют типы в современных скриптовых языках. Параметры можно валидировать вручную в JS, но это делают крайне редко, разве что часто бывают проверки на пустоту вида <code>if (!param1) return false;</code>. Почему не делают? Да потому что JS проносит в себе стиль кода, в котором <strong>тип - это не главная характиристика переменной</strong> - и программисты быстро это понимают.<br>
<em>Второе что теряет JS</em> - отсутствие возможности строить классическую ООП архитектуру. Нет, костылями и велосипедами конечно можно делать сильное подобие ООП - когда-то (далеко до ES6) этим вопросом задались создатели mootools, и сегодня 90% программистов JS, сталкивающихся с mootools считают его худшим фреймворком всех времён и народов) Почему? Да потому что в JS богатейший функционал, в том числе касаемо инкапсуляции(так необходимой для крупных проектов), множество способов делать "безопасные" для программы точки расширения, множество "своих паттернов", ООП ему не не нужен, чтобы сделать качественную расширяемую программу любого масштаба. Типизация, тем более строгая - есть локомотив "дедовского ООП" - и соответственно угнетатель гибких способов построения программ.<br>
<em>Последнее</em> - это при работе в IDE автокомплит и "переход к классу" работают плохо. Это бывает, но если вы всё-таки решили писать ООП-подобный код в js, то воспользуйтесь <a href="http://usejsdoc.org/" rel="nofollow noreferrer">JSDoc</a> , чтобы помочь IDE. В то-же время плохая навигация, это проблема самого IDE, например PhpStorm( WebStorm ) - работает с навигацией в JS хорошо и без JSDoc, и обещает, что скоро станет отлично.</p>
<p>Описал своими словами, как мог, но сложно объяснить множество плюсов отсутствия типов программисту на строго-типизированных языках: это почти что донести буддисту, что христианство это круто :) </p>
<p><strong>UPD</strong> но дабы не превращать ответ в злостный холивар, надо заметить - что типы тоже полезны для той-же читаемости кода, например в аргументах функций. Но когда типы используются иногда, а не в 100% кода. Но если разрешить в JS пусть только типы в аргументах (например как в TS), программисты тут-же начнут злоупотреблять ООП, и убьют сформировавшуюся стилистику языка, и вместе с этим все плюсы JS - думаю это причина идеологии типизации EcmaScript. Бесполезна и даже вредна именно строгая типизация, но только если речь не идёт о максимальной производительности: тогда нет вопросов, строгая типизация выйграет.</p>
</blockquote>
<h2>Answer 910399</h2>
<p><a href="https://ru.stackoverflow.com/a/910399/">Source</a> - by <a href="https://ru.stackoverflow.com/users/201364/sanmai">sanmai</a></p>
<blockquote>
<blockquote>
  <p>Языки высокого уровня изобретены для того, чтобы ускорить процесс достижения конечного результата.</p>
</blockquote>
<p><a href="https://habr.com/post/430706/" rel="nofollow noreferrer">Цитата отсюда.</a> Языки с динамической типизации нужны именно для того же: чтобы быстрей получить работающий результат. </p>
<p>Работающий - значит зарабатывающий деньги. Программирование ведь практическая дисциплина, а значит так или иначе сводящаяся или к экономии времени пользователя или разработчика, или к заработанным или сэкономленным деньгам.</p>
</blockquote>
<hr>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>RuSO Archive (published from sources in <a href="https://github.com/MSDN-WhiteKnight/ruso-archive">GitHub repository</a>). Content licensed under <a href="https://github.com/MSDN-WhiteKnight/ruso-archive/blob/master/LICENSE">CC-BY-SA 4.0</a>.<br>Generated by <strong>DocFX</strong></span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../../styles/main.js"></script>
  </body>
</html>
