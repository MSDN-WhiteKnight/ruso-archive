<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#1055;&#1086;&#1095;&#1077;&#1084;&#1091; &#1085;&#1072; java &#1084;&#1085;&#1086;&#1075;&#1086; &#1087;&#1088;&#1080;&#1083;&#1086;&#1078;&#1077;&#1085;&#1080;&#1081; &#1087;&#1086;&#1076; android &#1080; &#1086;&#1095;&#1077;&#1085;&#1100; &#1084;&#1072;&#1083;&#1086; &#1087;&#1086;&#1076; windows? | RuSO Archive </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#1055;&#1086;&#1095;&#1077;&#1084;&#1091; &#1085;&#1072; java &#1084;&#1085;&#1086;&#1075;&#1086; &#1087;&#1088;&#1080;&#1083;&#1086;&#1078;&#1077;&#1085;&#1080;&#1081; &#1087;&#1086;&#1076; android &#1080; &#1086;&#1095;&#1077;&#1085;&#1100; &#1084;&#1072;&#1083;&#1086; &#1087;&#1086;&#1076; windows? | RuSO Archive ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../../../../favicon.ico">
    <link rel="stylesheet" href="../../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../../index.html">
                <img id="logo" class="svg" src="../../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">

<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Почему на java много приложений под android и очень мало под windows?</h1>
<p><a href="https://ru.stackoverflow.com/questions/1034758/%d0%9f%d0%be%d1%87%d0%b5%d0%bc%d1%83-%d0%bd%d0%b0-java-%d0%bc%d0%bd%d0%be%d0%b3%d0%be-%d0%bf%d1%80%d0%b8%d0%bb%d0%be%d0%b6%d0%b5%d0%bd%d0%b8%d0%b9-%d0%bf%d0%be%d0%b4-android-%d0%b8-%d0%be%d1%87%d0%b5%d0%bd%d1%8c-%d0%bc%d0%b0%d0%bb%d0%be-%d0%bf%d0%be%d0%b4-windows">Source</a> - by <a href="https://ru.stackoverflow.com/users/186671/andrew-kachalin">Andrew Kachalin</a></p>
<blockquote>
<p>Уважаемые коллеги! Два + два состыковать не могу. По вакансиям на java предлагают в основном писать либо веб-сервера, либо под android. К примеру, запрос на <code>hh.ru</code> <code>javaFx</code> (gui библиотека) выводит твёрдый ноль вакансий. </p>
<p>Получается некоторая странность - приложения под windows на <code>java</code> практически не пишут, потому что на нативных языках (таких как <code>С/C++</code>) всё работает быстрее. Но однако же, android разработка - практически вся на <code>java</code>. Разработчиков похоже не смущает, что <code>java</code> медленнее, чем нативные языки. </p>
<p><strong>Вопрос:</strong>  как, почему и для чего случился такой перекос между <code>windows</code> и <code>andoid</code>'ом? На <code>android</code> всё на <code>java</code>, на <code>windows</code> - практически нечего. Какие особенности <code>android</code>а (по сравнению с <code>windows</code>) делают приоритетной разработку на <code>java</code> перед нативными языками? </p>
</blockquote>
<h2>Answer 1034798</h2>
<p><a href="https://ru.stackoverflow.com/a/1034798/">Source</a> - by <a href="https://ru.stackoverflow.com/users/351278/tankred">Tankred</a></p>
<blockquote>
<p>Дело не в скорости или удобстве языка, а в деньгах.<br></p>
<p>Что мы понимаем под приложением под Windows? Типичный десктоп который нужно установить, обновить, подружить с антивирусом и фаерволом. Не забудьте проверить лицензию. А еще может придется с бубном потанцевать, может там шамана вызвать чтобы оно заработало. Да и вообще ваше железо для нашей программы устарело - покупайте новое.<br></p>
<p>Так зачем мне, дяде с деньгами, это все надо? Есть же web, который в современном исполнении может делать все то же самое и при этом затраты на поддержку в разы меньше. Не нужны могучие компы, не нужны смены админов пропорциональные числу пользователей.</p>
<p>Вы не видите вакансий JavaFx потому что 95% рынка это энтерпрайс разработка и там десктоп уже давно не нужен, так как почти все задачи (документооборот, логистика, ERP) выгоднее сделать в вебе. </p>
<p>Ну а про андроид и говорить нечего, там в принципе на чем то отличном от Java (или конвертируемом в java байт код) писать нельзя.</p>
</blockquote>
<h2>Answer 1034827</h2>
<p><a href="https://ru.stackoverflow.com/a/1034827/">Source</a> - by <a href="https://ru.stackoverflow.com/users/232949/dsh">dSH</a></p>
<blockquote>
<p>java дает очень сильное абстрагирование от "железа" - поэтому удивляться. что это основной язык под Android. учитывая количество разных устройств, вряд ли стоит. 
Причем, этот язык выбрали изначально для системы Android - поэтому и доминирует там. </p>
<p>java дает сильное абстрагирование еще и от операционной системы - а это большой плюс корпорациям, которые не хотят быть привязанными к одному поставщику. Java в корпоративной среде используется для написания прежде всего программ, которые будут работать десятилетия, переживая смену поколений железа и операционных систем. 
Десктопные приложения на java менее распространены - потому что сложнее делать интеграцию с возможностями самой ОС в отношении GUI, java пришла на уже занятый рынок (C++, Delphi, потом C#) Поэтому и доля меньше. Но если Вам надо написать приложение, которое работает на десктопе в разных ОС, то вариантов на самом деле не так уж и много - а если не хотите долго изучать С++ - то еще меньше. Но такие задачи не так часты. </p>
</blockquote>
<h2>Answer 1035214</h2>
<p><a href="https://ru.stackoverflow.com/a/1035214/">Source</a> - by <a href="https://ru.stackoverflow.com/users/192421/pepsicoca1">pepsicoca1</a></p>
<blockquote>
<blockquote>
  <p>Какие особенности androidа (по сравнению с windows) делают
  приоритетной разработку на java перед нативными языками?</p>
</blockquote>
<p>Ответ очень прост - эти особенности суть мультиплатформенность андроид и моноплатформенность винды.  </p>
<p>То есть если Вы пишете на С++ для винды, то Вы отдаете пользователю экзешник и все работает на всех виндах. Если Вы пишите на С++ для андроида, то Вы должны перетранслировать свой экзешник для всех мобильных платформ, на которых сейчас живет андроид, а их (если мне не изменяет память) уже сейчас пять штук. Также Вам придется перетранслировать свою программу под новую платформу в случае, если андроид будет портирован на какую-то еще платформу (что происходит с завидной регулярностью).  </p>
<p>Вместе с тем, если Вы пишите на Яве, то Вы делаете только один файл с байт-кодом для Ява-машины. А при запуске на конкретной платформе Ява-машина либо интерпретирует Ваш байт-код. Либо JIT-компилятор в андроиде на конкретной платформе конвертирует Ваш байт-код в нативный код и запускает его. Таким образом, при использовании Явы, Вам не надо делать экзешники для всех целевых платформ, на которых живет (и будет жить в будущем) андроид.  </p>
<p>Есть вариант генерировать байт-код после С++ трансляции. И вроде-бы даже есть такие системы. Но они не в мейнстриме. Пока что мобильные приложения не особо нагруженные и производительности Явы вполне хватает, чтобы открыть окно, нарисовать 5-10 кнопок, обратиться к диску, обратиться к сети и запустить веселую анимацию.</p>
<p>UPD1:</p>
<p>Мобильные платформы это на чем сейчас делают мобильные гаджеты, все эти смартфоны, планшеты, навигаторы и прочее. Имеется ввиду, какие процессоры используются в мобильных гаджетах. Если поглядеть в Википедии, то можно узнать, что: "Android доступен для различных аппаратных платформ, таких как ARM, MIPS, x86". Но даже архитектура ARM это не один процессор, а куча разных процессоров, у которых наращивалась система команд начиная от ARMv6 и до современных Cortex-ов. Так что внутри разных мобильных устройств стоят довольно разные процессоры. И использование Ява-машин позволяет не делать экзешники для всего этого зоопарка, а обойтись одним файлом байт-кода.</p>
<p>UPD2:</p>
<blockquote>
  <p>но windows тоже ставят на компьютеры с разными процессорами. Из вики
  "Windows работает на платформах x86, x86-64, IA-64 и ARM.</p>
</blockquote>
<p>Ставить-то ставят, но без байт-кода невозможно иметь переносимый между платформами исполняемый файл. Приходится транслировать программу для всех возможных вариантов аппаратной платформы, что неудобно. О чем, собственно, и идет речь в Вашем вопросе и моем ответе. </p>
<p>Кроме того, Windows для ARM и прочих это не Windows, а Windows CE. Там от Windows осталось только название, а все API другое. Из той же Википедии:</p>
<blockquote>
  <p>Windows Embedded — это семейство операционных систем реального
  времени, которое было специально разработано для применения в
  различных встраиваемых системах. Ядро системы имеет общее с семейством
  ОС Windows CE и поддерживает процессоры ARM, MIPS, SuperH и x86.</p>
</blockquote>
<p>Что касается платформ x86, x86-64, IA-64, то </p>
<ol>
<li>IA-64 - фактически умерла</li>
<li>x86, x86-64 имеют разные разрядности. Не думаю, что даже байт-код может осуществить переносимость программ разной разрядности, то есть байт-код в данном случае бесполезен.</li>
</ol>
<p>Тем не менее мы видим, что Микрософт на платформе .Net тоже стал работать с байт-кодом в виде Common Language Runtime и Common Intermediate Language. То есть Микрософт пытается в своих технологиях на будущее тоже заложиться на многоплатформенность. Конечно, сама Windows намертво привязана к архитектуре x86 в том числе и на уровне вызовов функций API с параметрами-регистрами процессора Intel и вряд-ли Windows получится запустить на другой платформе. Так что все эти Common Intermediate Language это задел на будущее, ну или может быть им удастся применить Common Intermediate Language для обеспечения переносимости веб-технологий.</p>
<p>Вместе с тем GCC генерирует код под Windows x86, x86-64 сразу нативный, без всякого байт-кода и горя не знает.</p>
<p>И да, как раз на примере Windows мы видим что отсутствие байт-кода усложняет поддержку многоплатформенности Windows. А наличие байт-кода упрощает поддержку многоплатформенности. Для мобильных устройств многоплатформенность актуальна, поэтому Ява с ее байт-кодом стала популярна для Андроида и поддерживается производителем Андроида.</p>
<p>Просто когда начинался DOS, а потом Windows как преемник DOS, то никто не думал ни о каких других платформах, да и ресурсов для байт-кода и всяких JIT-компиляторов не было. Потом, когда все поумнели, и выяснилось, что процессоры могут быть не только от Intel, то от программных технологий стали требовать и поддержку многоплатформенности, чему Ява с ее байт-кодом отвечает в гораздо большей степени, чем генерация сразу нативного кода.</p>
<p>Вместе с тем, когда начиналась ОС Unix, поддержка многоплатформенности обеспечивалась не байт-кодом и JIT-компилятором, а тем, что приходилось переписывать примерно 10% кода при портировании ОС Unix на новую платформу, включая переписывание кодогенерации транслятора. Но это уже к собственно вопросу не имеет отношения, просто экскурс в историю как пример того, что многоплатформенность можно обеспечивать или быстро и дешево (байт-кодом) или медленно и дорого (переписывая код под другую аппаратную платформу или перетранслируя программы под другую аппаратную платформу).</p>
</blockquote>
<h2>Answer 1035556</h2>
<p><a href="https://ru.stackoverflow.com/a/1035556/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<p>Другие ответы объяснили, почему Java хорошо подходит для Android. Попробую объяснить одну из причин, почему Java плохо подходит для десктоп-разработки под Windows. На мой взгляд, это мало связано со скоростью, а скорее с тем, что в Java достаточно неудобное взаимодействие с нативными библиотеками. </p>
<p>Когда мы пишем приложение, заточенное под Windows (в противоположность кроссплатформенному), мы, очевидно, хотим использовать некоторые специфические ее API: например, DirectX для графики, Shell API для интеграции с проводником, или Raw Input для продвинутого взаимодействия с клавиатурой и мышью. В противном случае, зачем было бы заморачиваться. Эти все API - нативные ("native" - т.е., выполнены как бинарники в машинном коде текущей архитектуры и взаимодействуют с внешним миром через C-интерфейс на функциях, или с помощью Component Object Model). Более того, когда нужно взаимодействовать с каким нибудь особым устройством, типа фискального регистратора или сканера штрих-кодов, библиотека от производителя для этого, как правило, тоже нативная. Проблема в том, что механизм взаимодействия с нативным кодом в Java (JNI) требует создания довольно громоздких оберток на С++ с объявлениями JNICALL для всех вызываемых функций, тогда как в C# например достаточно добавить объявления P/Invoke в одну строчку в самом коде на C#. Кроме того, в Java вовсе нет аналога указателей на функций (делегаты в C#), это также большой минус в том случае, когда нативная библиотека использует их. При использовании COM разница еще более велика. В С/С++ взаимодействие с нативными библиотеками еще проще по понятным причинам.</p>
<p>Эти проблемы, конечно, малозначимы для веб-приложений или простых консольных утилит, поэтому они и под Windows могут писаться на Java. Но сложные десктопные приложения под Windows обычно используют С/С++ или .NET-языки. </p>
</blockquote>
<hr>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>RuSO Archive (published from sources in <a href="https://github.com/MSDN-WhiteKnight/ruso-archive">GitHub repository</a>). Content licensed under <a href="https://github.com/MSDN-WhiteKnight/ruso-archive/blob/master/LICENSE">CC-BY-SA 4.0</a>.<br>Generated by <strong>DocFX</strong></span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../../styles/main.js"></script>
  </body>
</html>
