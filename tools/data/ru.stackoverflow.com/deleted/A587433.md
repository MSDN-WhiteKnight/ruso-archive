---
title: "Ответ Vlad from Moscow на \"Можно ли как-то выйти из цикла...\""
se.owner.user_id: 183394
se.owner.display_name: "Vlad from Moscow"
se.owner.link: "https://ru.stackoverflow.com/users/183394/"
se.is_accepted: false
se.answer_id: 587433
se.link: "https://ru.stackoverflow.com/a/587433/240512"
se.question_id: 587384
---

*6 нояб. 2016*

Вы должны себе отдавать отчет, что в программировании находится разная публика, чаще всего которая не блистает интеллектом и не умеет программировать. Но, к сожалению, в программировании, как и в жизни, решающим является не талант, а наличии денег.

Java изобрели очень слабые программисты, которые не умели писать код, когда создавали свой язык. Недаром Java считается реинкарнацией Basic.

Java существует лишь по одной причине: туда гиганты софтверной индустрии вбухали большие деньги. А сделали они это также по одной причине, чтобы запустить с шумихой новую "технологию", и тем самым отбить пользователей у своих конкурентов. А когда пользователи разберутся, с какой поделкой они имеют дело, будет уже поздно, так как они в свою очередь уже затратили много денег в том числе и на обучение кадров.

Что касается вашего конкретного примера, то лучше всего использовать логическую переменную во внешнем цикле, а в теле цикла или внутри switch устанавливать значение этой переменной.

Что касается Java, то она предоставляет корявую конструкцию с `break` или `continue` предложением с меткой, которые просто являются замаскированным `goto` предложением, только еще более запутанные, чем `goto` предложение, так как они передают управление не на предложение после помеченного управляющего или иного предложения, а на начало этого управляющего предложения, что **без всяких сомнений**  только запутывает читающего код программиста.

Рассмотрите данный пример кода из оригинальной документации по Java (раздел документации 14.15 The break Statemen)

    class Graph {
         int edges[][];
         public Graph(int[][] edges) { this.edges = edges; } 
     
        public Graph loseEdges(int i, int j) { 
            int n = edges.length;
            int[][] newedges = new int[n][];
            for (int k = 0; k < n; ++k) {
     edgelist: {
                 int z;
     search: {
                 if (k == i) {
                     for (z = 0; z < edges[k].length; ++z) {
                         if (edges[k][z] == j) break search;
                     }
                 } else if (k == j) {
                     for (z = 0; z < edges[k].length; ++z) {
                         if (edges[k][z] == i) break search;
                     }
                 } 
     
                // No edge to be deleted; share this list.
                 newedges[k] = edges[k];
                 break edgelist; }
     //search 
     
                // Copy the list, omitting the edge at position z.
                 int m = edges[k].length - 1;
                 int ne[] = new int[m];
                 System.arraycopy(edges[k], 0, ne, 0, z);
                 System.arraycopy(edges[k], z+1, ne, z, m-z);
                 newedges[k] = ne; }
     //edgelist
             }
             return new Graph(newedges);
         }
     }


Это просто что-то страшное! Это "спагетти" невозможно читать и невозможно понять. Сразу же можно сделать вывод о квалификации разработчиков Java.:)

Недаром Microsoft создала свой язык C#, который по качеству и по стилю резко отличается от Java. C# создавали высококвалифицированные программисты, а Java создавали неучи с завышенным самомнением, которые расплодили точно таких же неучей, которые не умеют писать код.

Итак, надеюсь, вы уже поняли, что в Java есть исковерканное  **goto** предложение, замаскированное под `break` и `continue`, которые передают управление, фактически, неизвестно куда, так как интуитивно вы предполагаете, что если надо выйти из управляющего блока, то управление должно быть передано в предложение, которые следует за управляющим блоком, а на самом деле вы видите, что управление передается в начало управляющего блока.

Вот фрагмент код из вышеприведенного примера из документации по Java

     edgelist: {
                 int z; search: {
                 if (k == i) {
                     for (z = 0; z < edges[k].length; ++z) {
                         if (edges[k][z] == j) break search;
                     }
                 } else if (k == j) {
                     for (z = 0; z < edges[k].length; ++z) {
                         if (edges[k][z] == i) break search;
                     }
                 } 
     
                // No edge to be deleted; share this list.
                 newedges[k] = edges[k];
                 break edgelist; }
     //search 

И куда передает управление предложение?

                 break edgelist; }

Покажите этот код человеку, который ранее не имел дело с Java, и увидите, что он будет в замешательстве.:)

Вы также можете написать, например

    Rxit: while ( true )
    {
        switch( expression )
        {
            //...
            default: break Exit;
        }
    }

Только не думайте, что цикл `while` сновав начнет выполняться по второму разу. На самом деле логически это выглядит как будто бы метка стоит после цикла

    while ( true )
    {
        switch( expression )
        {
            //...
            default: break Exit;
        }
    }
    Exit:
    //...
