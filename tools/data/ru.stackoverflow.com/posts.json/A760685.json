{"owner":{"reputation":64807,"user_id":182825,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/89a4da7af5bf1558b7d2704309f1f118?s=128&d=identicon&r=PG","display_name":"AnT","link":"https://ru.stackoverflow.com/users/182825/ant"},"is_accepted":false,"score":5,"last_activity_date":1513726188,"last_edit_date":1513726188,"creation_date":1513713701,"answer_id":760685,"question_id":760436,"body":"<p>В современном С++ более предпочтительным считается именно второй вариант. Т.е. если вы знаете, что вам в любом случае понадобится копия, то лучше чтобы эту копию для вас делал компилятор, а не вы сами.</p>\n\n<p>Однако традиционное обоснование, приводящееся для этого утверждения, рассчитывает на типы, которые \"тяжелы\" для копирования не потому, что велики по размеру сами по себе, а потому, что требуют <em>глубокого</em> (deep) копирования. Т.е. речь идет о типах, которые являются компактными на <em>мелком</em> (shallow) уровне, но владеют дополнительными ресурсами через указатели/хендлы. Вся идея тут в том, что компилятор будет в состоянии заменить копирование на перемещение в ситуациях, когда исходное значение является временным/переместимым.</p>\n\n<p>Например, если в вашем случае заменить <code>S</code> на <code>std::string</code>, то при вызове <code>test(\"abc\")</code> второй вариант при подготовке аргументов обойдется без глубокого копирования вообще, в то время как в первом варианте вы сами безусловно выполните глубокое копирование.</p>\n\n<p>(Еще более эффективным может быть вариант с двумя отдельными функциями - для параметра <code>const std::string &amp;</code> и для параметра <code>std::string &amp;&amp;</code>, но если вы не пытаетесь выжать последние такты процессора, то одна функция с параметром <code>std::string</code> часто выглядит привлекательнее.)</p>\n\n<p>В случае же, когда \"тяжесть\" объекта встроена непосредственно в сам объект, как в вашем примере, сэкономить на копировании не удастся. Я бы ожидал одинаковой производительности от обоих вариантов. </p>\n\n<p>Некоторым нюансом является то, что, согласно абстрактной семантике языка, создание копии во втором варианте делается в контексте <em>вызывающего</em> кода. Некоторые реализации следуют этой семантике буквально - они выполняют создание копии и резервирование памяти для нее в контексте вызывающего кода. При этом память может резервироваться заранее, независимо от того, будет ли фактически вызываться функция в процессе выполнения. Т.е. написав, скажем, вот такую рекурсивную функцию</p>\n\n<pre><code>void recursive(unsigned n, const S &amp;s)\n{\n  if (n &gt; 0)\n    recursive(n - 1, s);\n  else\n    test(s);\n}\n</code></pre>\n\n<p>вы можете с удивлением обнаружить, что при использовании второго варианта функции <code>test</code> память в стеке для копии <code>s</code> выделяется на <em>каждом</em> уровне рекурсии, в то время как фактически эта память нужна только на самом дне рекурсии. Первый вариант <code>test</code> будет свободен от этого недостатка.</p>\n\n<p>Другие реализации могут поступать более экономно: даже при использовании второго варианта <code>test</code> выполнять резервирование памяти только если функция действительно вызывается.</p>\n"}