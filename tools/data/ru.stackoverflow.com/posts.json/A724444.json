{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1506620229,"creation_date":1506620229,"answer_id":724444,"question_id":668189,"body":"<p><strong>Введение</strong></p>\n\n<p>Раз уж <a href=\"https://ru.stackoverflow.com/q/696725/240512\">подняли тему звуковых устройств и отображения их имени</a>, имеет смысл написать ответ и здесь. Если динамики и наушники представлены в системе отдельными конечными устройствами (Endpoint), задача решается довольно просто с помощью любого аудио-API. С помощью того-же BASS.NET это делается примерно так:</p>\n\n<pre><code>BASS_DEVICEINFO[] devices=Bass.BASS_GetDeviceInfos();\n\nforeach(BASS_DEVICEINFO dev in devices)\n{\n    if(dev.IsDefault)textBox1.Text=(\"Текущее устройство вывода звука: \"+dev.name+\" - \"+dev.type.ToString());\n}\n</code></pre>\n\n<p>Если нужно реагировать на изменения в устройствах в реальном времени, можно воспользоваться техникой, описанной <a href=\"https://ru.stackoverflow.com/a/652517/240512\">здесь</a>, только вместо DBT_DEVICEARRIVAL обрабатывать DBT_DEVNODES_CHANGED (0x0007).</p>\n\n<p>Однако, это не всегда работает. Проблема в том, что в современных аудио-адаптерах обычно все аналоговые выходы представлены для системы одним конечным устройством, и переключение между динамиками и наушниками осуществляется либо автоматически драйвером, либо через утилиту производителя. В этом случае код выше бесполезен, так как он всегда будет выдавать одно и то же. Надежного решения тут нет, так как не все разъемы обладают системой детектирования кабеля, но можно попробовать использовать для определения активных разъемов Multimedia API и Device Topology API.</p>\n\n<p><strong>Используемые API</strong></p>\n\n<p>Для решения задачи нам понадобится <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/dd316556(v=vs.85).aspx\" rel=\"nofollow noreferrer\">Windows Multimedia Device API</a> - для получения текущего конечного устройства вывода, и <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/dd370825(v=vs.85).aspx\" rel=\"nofollow noreferrer\">Device Topology API</a> - для получения информации о разъемах. Необходимые классы определены в файлах <code>Objbase.h</code>, <code>Shobjidl.h</code>, <code>MMDeviceAPI.h</code> и <code>Devicetopology.h</code>. Поскольку это все COM-объекты, нам понадобятся декларации для использования их в управляемом коде. Их можно взять <a href=\"https://smallsoft2.blogspot.ru/2017/09/windows.html\" rel=\"nofollow noreferrer\">в данной статье</a>, или получить Interop Assemblies самостоятельно с помощью средств Windows SDK. Для этого используются примерно такие команды:</p>\n\n<blockquote>\n  <p>midl /out c:\\tmp /header \"C:\\Program Files (x86)\\Microsoft\n  SDKs...\\Include\\mmdeviceapi.h\" \"C:\\Program Files (x86)\\Microsoft\n  SDKs...\\Include\\mmdeviceapi.idl\"   </p>\n  \n  <p>tlbimp /out:MMDevAPI.Interop.dll mmdeviceapi.tlb</p>\n</blockquote>\n\n<p>Первая получает файл IDL, а вторая - сборку для подключения непосредственно к коду .NET. </p>\n\n<p><strong>Пример программы</strong></p>\n\n<p>Для вывода текущего устройства и его разъемов можно использовать такой код:</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Text;\nusing System.Windows.Forms;\nusing System.Runtime.InteropServices;\nusing System.ComponentModel;\n\nnamespace com_test\n{\n    public partial class Form1 : Form\n    {\n        //вывод информации об устройстве\n        string PrintDevice(IMMDevice dev)\n        {\n            IPropertyStore propertyStore = null;\n            IDeviceTopology pDeviceTopology = null;\n            IConnector pConnFrom = null;\n            IConnector pConnTo = null;\n            IPart pPart = null;\n            IKsJackDescription pJackDesc = null;\n            KSJACK_DESCRIPTION desc = new KSJACK_DESCRIPTION();\n\n            StringBuilder res = new StringBuilder(300);            \n            object o = null;\n\n            int state = 0;\n            uint con_count = 0;            \n\n            try\n            {\n                //имя устройства\n                dev.OpenPropertyStore(0/*STGM_READ*/, out o);                \n                propertyStore = o as IPropertyStore;\n\n                PropVariant friendlyName = new PropVariant();\n                propertyStore.GetValue(Native.PKEY_Device_FriendlyName, out friendlyName);                \n                res.AppendLine(friendlyName.Value.ToString());\n\n\n                //form factor \n                PropVariant FormFactor = new PropVariant();\n                propertyStore.GetValue(Native.PKEY_AudioEndpoint_FormFactor, out FormFactor);                \n                EndpointFormFactor f=EndpointFormFactor.UnknownFormFactor;\n                Enum.TryParse&lt;EndpointFormFactor&gt;(FormFactor.Value.ToString(), out f);\n                res.AppendLine(\"Form factor: \" + f.ToString());                \n\n                //состояние устройства\n                dev.GetState(ref state);                \n\n                string str=\"\";\n                switch (state)\n                {                    \n                    case Native.DEVICE_STATE_DISABLE: str = (\"Отключено\"); break;\n                    case Native.DEVICE_STATE_NOTPRESENT: str = (\"Отсутствует\"); break;\n                    case Native.DEVICE_STATE_UNPLUGGED: str = (\"Отключено\"); break;\n                }\n                if(str!=\"\")res.AppendLine(str);\n\n\n                /* DEVICE TOPOLOGY */\n                Guid iidDeviceTopology = new Guid(\"2A07407E-6497-4A18-9787-32F79BD0D98F\");\n                dev.Activate(ref iidDeviceTopology, (uint)CLSCTX.CLSCTX_ALL, IntPtr.Zero, out o);                \n                pDeviceTopology = o as IDeviceTopology;\n\n                pDeviceTopology.GetConnector(0, out pConnFrom);                \n\n                try\n                {\n                    o = null;\n                    pConnFrom.GetConnectedTo(out o);\n                    pConnTo = o as IConnector;                    \n\n                    pPart = (IPart)pConnTo;//QueryInterface\n\n                    Guid iidKsJackDescription = new Guid(\"4509F757-2D46-4637-8E62-CE7DB944F57B\");\n                    pPart.Activate((uint)CLSCTX.CLSCTX_INPROC_SERVER, ref iidKsJackDescription, out o);                    \n                    pJackDesc = (IKsJackDescription)o;\n\n                    if (pJackDesc != null)\n                    {\n                        con_count = 0;\n                        pJackDesc.GetJackCount(out con_count);\n                        if (con_count &gt; 0)\n                        {\n                            StringBuilder sb ;\n\n                            //отобразить информацию о разъемах\n                            for (uint i = 0; i &lt; con_count; i++)\n                            {\n                                pJackDesc.GetJackDescription(i, ref desc);\n\n                                if (desc.IsConnected == 0) continue;\n                                sb= new StringBuilder(100);\n                                EPcxConnectionType con_type = (EPcxConnectionType)desc.ConnectionType;\n                                EPcxGeoLocation loc = (EPcxGeoLocation)desc.GeoLocation;\n                                res.Append(\"* \");\n\n                                switch (con_type)\n                                {\n                                    case EPcxConnectionType.eConnType3Point5mm: sb.Append(\"Разъем 3.5 мм \");\n                                        break;\n                                    case EPcxConnectionType.eConnTypeAtapiInternal: sb.Append(\"Разъем ATAPI \");\n                                        break;\n                                    case EPcxConnectionType.eConnTypeRCA: sb.Append(\"Разъем RCA \");\n                                        break;\n                                    case EPcxConnectionType.eConnTypeQuarter: sb.Append(\"Разъем 1/2 дюйма \");\n                                        break;\n                                    case EPcxConnectionType.eConnTypeOtherAnalog: sb.Append(\"Аналоговый разъем \");\n                                        break;\n                                    case EPcxConnectionType.eConnTypeOtherDigital: sb.Append(\"Цифровой разъем \");\n                                        break;\n                                    default: sb.Append(con_type.ToString()+\" \");\n                                        break;\n                                }\n\n                                switch (loc)\n                                {\n                                    case EPcxGeoLocation.eGeoLocFront: sb.Append(\"- Передняя панель\");\n                                        break;\n                                    case EPcxGeoLocation.eGeoLocRear: sb.Append(\"- Задняя панель\");\n                                        break;\n                                    case EPcxGeoLocation.eGeoLocHDMI: sb.Append(\"- HDMI\");\n                                        break;\n                                    case EPcxGeoLocation.eGeoLocNotApplicable: sb.Append(\"- Расположение не определено\");\n                                        break;\n                                    default: sb.Append(\"- \"+loc.ToString());\n                                        break;\n                                }\n\n\n                                res.AppendLine(sb.ToString());\n\n\n                            }//end for\n                        }\n                        else\n                        {\n                            res.AppendLine(\"* Нет разъемов\");                            \n                        }\n\n                    }\n                    else\n                    {\n                        res.AppendLine(\"* Не удалось получить информацию о разъемах\");                        \n                    }\n                    ;\n\n\n                }\n                catch (COMException ex)\n                {\n                    if ((uint)ex.HResult == 0x80070490 /*E_NOTFOUND*/)\n                    {\n                        res.AppendLine(\"Не подключен\");                        \n                    }\n                    else\n                    {\n                        res.AppendLine(\"COM error: \" + ex.Message);                        \n                    }\n                }\n                catch (Exception ex)\n                {\n                    res.AppendLine(\"Не удалось получить информацию о разъемах: \" + ex.Message);                    \n                }                \n\n            }\n            finally\n            {\n                //clean up resources                \n                if (dev != null) Marshal.ReleaseComObject(dev);\n                if (propertyStore != null) Marshal.ReleaseComObject(propertyStore);\n\n                if (pDeviceTopology != null) { Marshal.ReleaseComObject(pDeviceTopology); pDeviceTopology = null; }\n                if (pConnFrom != null) { Marshal.ReleaseComObject(pConnFrom); pConnFrom = null; }\n                if (pConnTo != null) { Marshal.ReleaseComObject(pConnTo); pConnTo = null; }\n                if (pPart != null) { Marshal.ReleaseComObject(pPart); pPart = null; }\n                if (pJackDesc != null) { Marshal.ReleaseComObject(pJackDesc); pJackDesc = null; }                \n            }\n\n            return res.ToString();\n        }\n\n\n        public Form1()\n        {\n            InitializeComponent();  \n        }\n\n        private void button_Click(object sender, EventArgs e)\n        {\n            MMDeviceEnumerator devenum = new MMDeviceEnumerator();//Create CoClass\n            IMMDeviceEnumerator deviceEnumerator = (IMMDeviceEnumerator)devenum;\n\n            IMMDevice defDevice = null;\n            IPropertyStore propertyStore = null;\n\n            try\n            {\n                object o = null;\n\n                // * default device *                \n                deviceEnumerator.GetDefaultAudioEndpoint(EDataFlow.eRender, ERole.eConsole, out o);\n                defDevice = o as IMMDevice;\n\n                textBox1.Text = \"Текущее устройство вывода звука: \" + Environment.NewLine + Environment.NewLine;\n                textBox1.Text += PrintDevice(defDevice);\n                textBox1.Select(0, 0);\n\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.ToString());\n            }\n            finally\n            {\n                //clean up resources\n                if (devenum != null) Marshal.ReleaseComObject(devenum);\n                if (deviceEnumerator != null) Marshal.ReleaseComObject(deviceEnumerator);                \n                if (defDevice != null) Marshal.ReleaseComObject(defDevice);\n                if (propertyStore != null) Marshal.ReleaseComObject(propertyStore);\n            }\n        }\n\n\n    }\n}\n</code></pre>\n\n<p>Здесь интерфейс <code>IMMDeviceEnumerator</code> используется для определения текущего устройства вывода. Затем делается попытка для него получить <code>IKsJackDescription</code> и вывести для всех активных разъемов тип и место размещения. Понятно, невозможно достоверно отличить динамики от наушников (потому что разъемы у них совершенно одинаковые), но какие-то выводы из этого можно извлечь.</p>\n"}