{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":4,"last_activity_date":1554703556,"creation_date":1554703556,"answer_id":966828,"question_id":965328,"body":"<p>В .NET Core начиная с версии 3.0 поддерживается <a href=\"https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability-howto\" rel=\"nofollow noreferrer\">выгрузка DLL без использования доменов приложений</a>. В .NET Framework для того, чтобы DLL можно было выгрузить, ее необходимо загрузить в отдельный домен приложений и осуществлять любое взаимодействие с ней через класс-обертку, производный от MarshalByRefObject. Как-то так:</p>\n\n<pre><code>using System;\nusing System.Collections;\nusing System.Reflection;\nusing System.Diagnostics;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void PrintLibs()\n        {\n            Process pr = Process.GetCurrentProcess();            \n\n            using (pr)\n            {\n                pr.Refresh();\n\n                foreach (ProcessModule mod in pr.Modules)\n                {\n                    if(mod.ModuleName.EndsWith(\".ni.dll\"))Console.WriteLine(mod.ModuleName);\n                }         \n            }            \n        }        \n\n        static void Main(string[] args)\n        {\n            //создаем домен приложений\n            AppDomain domain = AppDomain.CreateDomain(\"MyDomain\");\n\n            //создаем обертку для удаленных вызовов\n            Type type = typeof(Wrapper);\n            Wrapper wrapper = (Wrapper)domain.CreateInstanceAndUnwrap(\n                type.Assembly.FullName,\n                type.FullName);\n\n            //вызываем метод в MyDomain\n            string s = wrapper.Invoke(\"SELECT Name FROM Win32_Processor\", \"Name\");\n            Console.WriteLine(s);\n\n            Console.WriteLine(\"*** Загруженные библиотеки до выгрузки домена: ***\");\n            PrintLibs();\n\n            //выгружаем MyDomain\n            AppDomain.Unload(domain);\n            GC.Collect();\n            GC.WaitForPendingFinalizers();\n\n            Console.WriteLine(\"*** Загруженные библиотеки после выгрузки домена: ***\");\n            PrintLibs();\n\n            Console.ReadKey();\n        }\n\n    }\n\n    public class Wrapper : MarshalByRefObject\n    {\n        public string Invoke(string query, string property)\n        {\n            string assemblyPath = \"C:\\\\Windows\\\\Microsoft.NET\\\\Framework\\\\v4.0.30319\\\\System.Management.dll\";\n            Assembly ass = Assembly.LoadFile(assemblyPath);\n            Type t = ass.GetType(\"System.Management.ManagementObjectSearcher\");\n\n            object obj = Activator.CreateInstance(t, query);\n            IEnumerable moc = (obj as dynamic).Get();\n            foreach (object item in moc)\n            {\n                return (item as dynamic).Properties[property].Value.ToString();\n            }\n\n            return \"\";\n        }\n    }\n}\n\n/* Результат:\n\nIntel(R) Core(TM) i5-6400 CPU @ 2.70GHz\n*** Загруженные библиотеки до выгрузки домена: ***\nmscorlib.ni.dll\nSystem.ni.dll\nSystem.Core.ni.dll\nMicrosoft.CSharp.ni.dll\nSystem.Management.ni.dll\nSystem.Dynamic.ni.dll\n*** Загруженные библиотеки после выгрузки домена: ***\nmscorlib.ni.dll\nSystem.ni.dll \n*/\n</code></pre>\n"}