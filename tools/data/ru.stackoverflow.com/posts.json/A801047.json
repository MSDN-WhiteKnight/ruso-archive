{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1521445430,"last_edit_date":1521445430,"creation_date":1521389102,"answer_id":801047,"question_id":798256,"body":"<p>Пользоваться консолью в не-консольных приложениях, как ни странно, можно (ну, оставляя в стороне практическую целесообразность такой \"методики\"). Из какого потока обращаться к консоли совершенно неважно - все операции на консоли потокобезопасны, так как синхронизируются блокировками на глобальном объекте. Приведенный в вопросе код почти рабочий, он не учитывает только одну деталь: после уничтожения и пересоздания консоли прямым вызовом API-функций внутри класса <em>Console</em> остаются объекты <em>TextReader</em>/<em>TextWriter</em> с протухшими файловыми дескрипторами, которые необходимо пересоздать. </p>\n\n<p>Нужно заменить вызов <em>AllocConsole</em> на вызов приведенного ниже метода <em>CreateConsole</em>:</p>\n\n<pre><code>[DllImport(\"kernel32.dll\", SetLastError = true)]\n[return: MarshalAs(UnmanagedType.Bool)]\nprivate static extern bool AllocConsole();\n\n[DllImport(\"kernel32.dll\", SetLastError = true)]\ninternal static extern uint GetConsoleCP();\n\npublic static bool CreateConsole()\n{\n    bool res = AllocConsole();\n    if (res == false) return false;\n    uint cp = GetConsoleCP();\n\n    //Пересоздаем stdout\n    StreamWriter wr = new StreamWriter(\n        System.Console.OpenStandardOutput(),Encoding.GetEncoding((int)cp));\n    wr.AutoFlush = true;            \n    System.Console.SetOut(wr);\n\n    //Пересоздаем stdin\n    TextReader read = new StreamReader(\n        System.Console.OpenStandardInput(), Encoding.GetEncoding((int)cp));\n    System.Console.SetIn(read);\n\n    return true;\n}\n</code></pre>\n\n<p>И поправить клавиатурный цикл (выкинуть ужасный код со <em>Thread.Abort</em> и сделать хотя бы что-то похожее на нормальную синхронизацию):</p>\n\n<pre><code>private static volatile bool StartConsole = false;\npublic static void Console()\n{  \n    if (CreateConsole())\n    {\n        /*Работа с консолью...*/\n        FreeConsole();            \n    }\n    StartConsole = false;          \n}\n\npublic static void SetConsole()\n{\n    while (true)\n        if (/*условие входа*/ &amp;&amp; !StartConsole)\n        {\n            StartConsole = true;\n            Thread ConsoleThread = new Thread(Console);\n            ConsoleThread.Start();                    \n        } \n}\n</code></pre>\n\n<p>Тогда все заработает.</p>\n\n<p>Основано на коде из данной темы: <a href=\"https://social.msdn.microsoft.com/Forums/vstudio/en-US/38444d15-0e1d-4baa-baf7-a692f5a41074/console-error-after-freeconsole-is-called?forum=csharpgeneral\" rel=\"nofollow noreferrer\">Console error after FreeConsole is called</a></p>\n"}