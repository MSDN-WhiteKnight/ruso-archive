{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":4,"last_activity_date":1554875305,"creation_date":1554875305,"answer_id":967735,"question_id":967722,"body":"<blockquote>\n  <p>К примеру есть файл .cpp, в нем есть метод, который не относится не к какому пространству method(wchar_t ch) { .. } куда этот метод по факту может относиться, если переводить его на c#, создание отдельного статического класса для таких групп методов?</p>\n</blockquote>\n\n<p>В C# нет глобальных методов, так что да, метод должен быть объявлен как статический член класса. Однако, начиная с C# 6.0, можно использовать using static, чтобы обращаться к статическому методу без указания типа:</p>\n\n<pre><code>public static class MyClass\n{    \n    public static int Foo(int x,int y)\n    {\n        return x + y;\n    }\n}\n</code></pre>\n\n<hr>\n\n<pre><code>using static ConsoleApplication1.MyClass;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(Foo(1, 2));\n    }       \n}\n</code></pre>\n\n<blockquote>\n  <p>Есть класс, он описан и тд, но я заметил в нем есть \"вызова\" методов, без всякого описания, то есть даже значения не передаются ... но эти методы описываются ниже класса не в каком либо namespace ... как это работает например в c#?</p>\n</blockquote>\n\n<p>В С++ разделение объявления и реализации используется, чтобы вынести в заголовочный файл только объявления методов. Это необходимо в связи с правилами языка касательно повторного определения функций (заголовочные файлы включаются во многих местах программы, а не-inline функция может быть определена только один раз). В C# нет необходимости разделять объявление и реализацию, так как нет понятия заголовочных файлов и вообще не используются forward declarations; язык устроен по другому. Реализации методов пишутся прямо в объявлении класса.</p>\n\n<p>Если все же хочется объявить метод без реализации (например, заготовку на будущее), существуют <a href=\"https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/partial-method\" rel=\"nofollow noreferrer\">partial-методы</a>:</p>\n\n<pre><code>public static partial class MyClass\n{\n    static partial void Bar();\n}\n</code></pre>\n\n<hr>\n\n<pre><code>public static partial class MyClass\n{\n    static partial void Bar()\n    {\n        Console.WriteLine(\"Hello\");\n    }\n}\n</code></pre>\n"}