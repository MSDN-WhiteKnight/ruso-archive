{"tags":["c#","рефлексия","ienumerable","ienumerator"],"owner":{"reputation":2227,"user_id":298154,"user_type":"registered","profile_image":"https://i.stack.imgur.com/0YvNK.jpg?s=128&g=1","display_name":"NewView","link":"https://ru.stackoverflow.com/users/298154/newview"},"is_answered":true,"view_count":86,"accepted_answer_id":926484,"answer_count":3,"score":0,"last_activity_date":1546153526,"creation_date":1545990377,"last_edit_date":1545997448,"question_id":926467,"link":"https://ru.stackoverflow.com/questions/926467/%d0%9e%d1%87%d0%b8%d1%81%d1%82%d0%ba%d0%b0-%d0%be%d0%b1%d1%8a%d0%b5%d0%ba%d1%82%d0%b0-%d1%82%d0%b8%d0%bf%d0%b0-ienumerable-%d0%bf%d0%be%d0%bb%d1%83%d1%87%d0%b5%d0%bd%d0%bd%d1%8b%d0%b9-%d1%87%d0%b5%d1%80%d0%b5%d0%b7-propertyinfo","title":"Очистка объекта типа IEnumerable полученный через PropertyInfo","body":"<p>Проблема в очистки списка приведенному к IEnumerable полученный через рефлексию с помощью <code>PropertyInfo</code></p>\n\n<p>часть кода получения и приведения к типу:</p>\n\n<pre><code>PropertyInfo[] p = ele.GetType().GetProperties();\n\nObject obj = p[i].GetValue(ele, null);\n\nif (obj is IEnumerable&lt;Object&gt;)\n{\n    IEnumerable&lt;Object&gt; ie = (obj as IEnumerable&lt;Object&gt;);\n    if (ie == null)\n           return;\n\n    // часть 1-я: чистит локально, поскольку копия, в структуре данные сохраняются\n    ie.ToList().Clear();\n    // часть 2-я: Создание нового объекта и замещение\n    var x = new IEnumerable&lt;object&gt;();\n    p[i].SetValue(ele, x, null);\n// Вот тут происходит exception про несоответствие типов,\n// например Ienumerable&lt;object&gt; невозможно преобразовать в List&lt;string&gt;\n}\n</code></pre>\n\n<p>Как правильно очистить IEnumerable/List через рефлексию? При чем тип <code>&lt;ХХХ&gt;</code> может быть разный.\nВозможно надо как то более тонко детерминировать тип, а не приводить к <code>IEnumerable&lt;object&gt;</code>?</p>\n"}