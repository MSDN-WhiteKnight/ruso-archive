{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":1,"last_activity_date":1563355329,"creation_date":1563355329,"answer_id":1003779,"question_id":1003049,"body":"<p>По моим тестам, в Visual C++ результат вывода <code>type_info.hash_code()</code> не меняется при внесении изменений в код функций класса (он меняется только при изменении его имени). Так что идея уже сомнительная.</p>\n\n<p>Хэш самого тела функции можно получить, скажем, как-то так:</p>\n\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;tchar.h&gt;\n#include &lt;Windows.h&gt;\n#include &lt;DbgHelp.h&gt;\n\n#pragma comment(lib, \"Dbghelp.lib\")\n\nstruct Function {\n    const char* name;   \n    uint64_t addr;\n    unsigned int size;\n    bool success;\n};\n\nBOOL CALLBACK EnumSymProc(PSYMBOL_INFO pSymInfo, ULONG SymbolSize, PVOID context) {\n\n    Function* pfstruct = (Function*)context; \n\n    if (strcmp(pSymInfo-&gt;Name, pfstruct-&gt;name) == 0) {      \n        pfstruct-&gt;addr = pSymInfo-&gt;Address; \n        pfstruct-&gt;size = SymbolSize;\n        pfstruct-&gt;success = true;\n        return FALSE; //закончить поиск\n\n    }\n    return TRUE; //продолжить поиск\n}\n\nbool GetFuncBounds(const char* fname, uint64_t&amp; addr, unsigned int&amp; size) {\n\n    bool ret;\n    Function fstruct;\n    fstruct.name = fname;\n    fstruct.size = 0;\n    fstruct.success = false;\n\n    HANDLE hProcess = GetCurrentProcess(); //текущий процесс\n    char Mask[] = \"*!*\"; \n    BOOL status;\n\n    status = SymInitialize(hProcess, NULL, TRUE); //загрузка символов\n    if (status == FALSE)\n    {\n        printf(\"SymInitialize failed. Error code: 0x%x\\n\", (UINT)GetLastError());\n        return false;\n    }\n\n    //поиск символов\n    if (SymEnumSymbols(hProcess, 0, Mask, &amp;EnumSymProc, (void*)&amp;fstruct))\n    {\n        if (fstruct.success != false) {\n\n            //возвращаем адрес и размер функции\n            addr = fstruct.addr;\n            size = fstruct.size; \n            ret = true;\n        }\n        else {\n            printf(\"Symbol [%s] not found\\n\", fname);\n            ret = false;\n        }\n    }\n    else\n    {\n        printf(\"SymEnumSymbols failed. Error code: 0x%x\\n\", (UINT)GetLastError());\n        ret = false;\n    }\n\n    SymCleanup(hProcess);\n    return ret;\n}\n\nuint32_t GetMemHash(uint64_t addr, int size) {\n\n    uint32_t hash = 1234;\n    uint32_t k = 9870;\n\n    for (int i=0; i &lt; size; i+=sizeof(uint32_t)) {\n        uint32_t* p = (uint32_t*)((char*)addr + i);\n        hash = hash * k + (*p);\n    }\n\n    hash += size;\n    return hash;\n}\n\n//**********************************\n\nvoid Func() {   \n    printf(\"Hello, World!\\n\");  \n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{   \n    uint64_t addr = 0;\n    unsigned int size = 0;\n    UINT hash;  \n\n    if (GetFuncBounds(\"Func\", addr, size)) {\n        hash = GetMemHash(addr, size);\n        printf(\"Hash: 0x%x\\n\", (UINT)hash);\n    }\n    else {\n        printf(\"Cannot calculate hash!\\n\");\n    }\n\n    getchar();\n    return 0;\n}\n</code></pre>\n\n<p>Но я не думаю, что это поможет решить задачу. Значение этого хэша в большинстве случаев будет меняться даже при простой пересборке проекта без изменений, так как компилятор каждый раз генерирует новые адреса объектов, что приводит к различиям в машинном коде.</p>\n\n<hr>\n\n<p>Как же решить задачу? Если вам нужно отслеживать изменения в исходном коде, то и зайти логичнее со стороны исходного кода. Сделайте, чтобы тело всех функций, изменения в которых надо отслеживать, было вынесено в отдельный файл, подключаемый через include. Напишите программу, которая будет считать хэши от содержимого этих файлов, и записывать результат в XML-файл. Прикрутите ее к вашим инструментам сборки (например, в Visual Studio - Custom build step), и распространяйте получаемый XML-файл с хэшами функций вместе с программой, тогда вы всегда можете определить, какая функция изменилась. Для проверки, что XML-файл действительно соответствует текущему бинарнику, можно включить в него и хэш от бинарника.</p>\n"}