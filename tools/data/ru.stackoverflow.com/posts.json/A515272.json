{"owner":{"reputation":1294,"user_id":17836,"user_type":"registered","accept_rate":100,"profile_image":"https://i.stack.imgur.com/6WwHZ.jpg?s=128&g=1","display_name":"LXA","link":"https://ru.stackoverflow.com/users/17836/lxa"},"is_accepted":false,"score":1,"last_activity_date":1461178653,"creation_date":1461178653,"answer_id":515272,"question_id":513736,"body":"<p>Попробую резюмировать: легче избежать проблемы (продумав детально арифметику), чем потом ее (неприятно) обнаруживать и обрабатывать.</p>\n\n<p>Решения с перехватом либо зависят от компилятора, либо представляют собой отказ от непосредственно встроенных типов. Полагаю, подходящим решением (кроме работы с памятью и коллекциями, разрешающими индексацию) может стать использование чисел с плавающей запятой, т.к. они более приближены к естественной арифметике (в плане бесконечностей, деления на 0).</p>\n\n<p>В книге \"24 смертных греха компьютерной безопасности\" Ховарда, Лебланка, Вьеги встретил такое решение:</p>\n\n<ul>\n<li>учет размеров типов (см. другие ответы);</li>\n<li>простота кода;</li>\n<li>явное преобразование типов;</li>\n<li>использование <a href=\"http://safeint.codeplex.com/\" rel=\"nofollow\">SafeInt</a> (by Дэвид Лебланк)</li>\n<li>при использовании <code>gcc</code>, компилировать с флагом <code>-ftrapv</code> (при переполнении знаковых целочисленных вызывается <code>abort()</code>);</li>\n<li>использование беззнаковых целых для работы с памятью и индексами массивов (слегка облегчает последствия);</li>\n</ul>\n"}