{"owner":{"reputation":16068,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":2,"last_activity_date":1533059841,"last_edit_date":1533059841,"creation_date":1533056764,"answer_id":862686,"question_id":861674,"body":"<p>Буквально поставленная задача решается с помощью Reflection в сочетании с функциональностью сериализации коллекций в XML-тип <code>ArrayOfAnyType</code>. Как-то так:</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Reflection;\nusing System.IO;\nusing System.Xml;\nusing System.Xml.Serialization;\n\nnamespace WinformsTest\n{\n    public static class WorkingClass\n    {\n        //несколько полей разных типов для примера...\n        public static int a=0;\n        public static string b = \"Hello\";\n        public static List&lt;string&gt; c = new List&lt;string&gt; { \"Петр\",\"Мария\",\"Александр\" };\n\n        //Сохраняет состояние всех статических полей текущего класса в XML-файл\n        public static void Save(string file)\n        {\n            List&lt;object&gt; values = new List&lt;object&gt;(); \n            List&lt;Type&gt; types = new List&lt;Type&gt;(); \n            types.Add(typeof(string));\n\n            //найдем все статические поля\n            FieldInfo[] vars = typeof(WorkingClass).GetFields(\n                    BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static\n                    );\n\n            //занесем все в коллекцию и найдем все возможные типы\n            foreach (FieldInfo x in vars)\n            {\n                values.Add(x.Name);\n                values.Add(x.GetValue(null)); \n                if (!types.Contains(x.FieldType)) types.Add(x.FieldType); \n            }\n\n            //сериализуем коллекцию в файл \n            XmlSerializer ser = new XmlSerializer(typeof(List&lt;object&gt;), types.ToArray());\n\n            Stream s = new FileStream(file, FileMode.Create);\n\n            using (s)\n            {\n                ser.Serialize(s, values);\n            }\n        }\n\n        //Считывает состояние всех статических полей текущего класса из XML-файла\n        public static void Load(string file)\n        {\n            List&lt;object&gt; values;\n            List&lt;Type&gt; types = new List&lt;Type&gt;();\n            types.Add(typeof(string));\n\n            //найдем все статические поля\n            FieldInfo[] vars = typeof(WorkingClass).GetFields(\n                    BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static\n                    );\n\n            //найдем все возможные типы\n            foreach (FieldInfo x in vars)\n            {                \n                if(!types.Contains(x.FieldType)) types.Add(x.FieldType);\n            }\n\n            //загружаем коллекцию из файла\n            XmlSerializer ser = new XmlSerializer(typeof(List&lt;object&gt;), types.ToArray());\n            Stream s = new FileStream(file, FileMode.Open);\n\n            using (s)\n            {\n                values = (List&lt;object&gt;)ser.Deserialize(s);\n            }            \n\n            for(int i =0 ; i&lt;values.Count;i+=2)\n            {\n                var item = vars.Where(x =&gt; x.Name == (string)values[i]).First(); //найдем поле по имени\n\n                if (item != null)\n                {\n                    item.SetValue(null, values[i + 1]); //установим значение поля\n                }\n            }\n\n        }\n    }\n}\n</code></pre>\n\n<p>Получаемый XML выглядит так:</p>\n\n<pre class=\"lang-xml prettyprint-override\"><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;ArrayOfAnyType xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt;\n  &lt;anyType xsi:type=\"xsd:string\"&gt;a&lt;/anyType&gt;\n  &lt;anyType xsi:type=\"xsd:int\"&gt;0&lt;/anyType&gt;\n  &lt;anyType xsi:type=\"xsd:string\"&gt;b&lt;/anyType&gt;\n  &lt;anyType xsi:type=\"xsd:string\"&gt;Hello&lt;/anyType&gt;\n  &lt;anyType xsi:type=\"xsd:string\"&gt;c&lt;/anyType&gt;\n  &lt;anyType xsi:type=\"ArrayOfString\"&gt;\n    &lt;string&gt;Петр&lt;/string&gt;\n    &lt;string&gt;Мария&lt;/string&gt;\n    &lt;string&gt;Александр&lt;/string&gt;\n  &lt;/anyType&gt;\n&lt;/ArrayOfAnyType&gt;\n</code></pre>\n\n<hr>\n\n<p>Однако, на практике принято все делать немного по другому. Использование статических открытых переменных для хранения данных предметной области, помимо наличия обычных для \"глобального состояния\" проблем с масштабируемостью приложения, затрудняет синхронизацию доступа из разных потоков и разработку GUI. Вместо этого, лучше сделать нормальный класс и специальное статическое поле для \"основного\" экземпляра:</p>\n\n<pre><code>public class WorkingClass\n{\n    public bool a {get;set;}\n    public int b {get;set;}\n    public Book c {get;set;}\n    //....\n\n    static WorkingClass _Instance = new WorkingClass();\n\n    public static WorkingClass Instance \n    {\n      get { return _Instance; }\n    }\n}\n</code></pre>\n\n<p>Тогда можно сериализовывать экземпляр <em>_Instance</em> штатными средствами. Обращаться к переменным из любого места программы можно через <code>WorkingClass.Instance.a</code>. Раз любой доступ к данным осуществляется через геттер одного свойства, при таком подходе легко обеспечить синхронизацию потоков и уведомление GUI об изменениях.</p>\n"}