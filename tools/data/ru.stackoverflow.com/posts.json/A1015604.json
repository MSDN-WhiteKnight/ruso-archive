{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":3,"last_activity_date":1566323821,"creation_date":1566323821,"answer_id":1015604,"question_id":1014944,"body":"<p>Не каждый процессор возвращает в CPUID уникальный серийный номер. Чтобы уникально идентифицировать компьютер, имеет смысл использовать составной аппаратный идентификатор, состоящий из нескольких значений, например:</p>\n\n<ul>\n<li>CPUID</li>\n<li>SMBIOS System UUID </li>\n<li>Серийный номер системника</li>\n<li>Серийный номер материнской платы</li>\n</ul>\n\n<p>Все эти значения можно программно получить из <a href=\"https://www.dmtf.org/standards/smbios\" rel=\"nofollow noreferrer\">таблицы SMBIOS</a>. MAC-адреса сетевых интерфейсов, конечно, тоже можно добавить, но следует помнить, что компьютер может иметь несколько сетевых интерфейсов, нельзя просто взять первый попавшийся - он может быть виртуальным.</p>\n\n<p>Пример для Windows (код для чтения таблицы SMBIOS взят из проекта <a href=\"https://github.com/cavaliercoder/sysinv/blob/master/smbios.cpp\" rel=\"nofollow noreferrer\">sysinv</a>):</p>\n\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n#include &lt;tchar.h&gt;\n\n// SMBIOS Table Type numbers\n#define SMB_TABLE_BIOS              0\n#define SMB_TABLE_SYSTEM            1\n#define SMB_TABLE_BASEBOARD         2\n#define SMB_TABLE_CHASSIS           3\n#define SMB_TABLE_PROCESSOR         4\n#define SMB_TABLE_MEMCTRL           5\n#define SMB_TABLE_MEMMODULES        6\n#define SMB_TABLE_PORTS             8\n#define SMB_TABLE_SLOTS             9\n#define SMB_TABLE_OEM_STRINGS       11\n#define SMB_TABLE_SYS_CFG_OPTIONS   12\n#define SMB_TABLE_MEM_ARRAY         16\n#define SMB_TABLE_MEM_DEVICE        17\n#define SMB_TABLE_END_OF_TABLE      127\n\n// 64bit Word type\ntypedef unsigned long long QWORD;\n\n/*\n* Structures\n*/\ntypedef struct _RawSmbiosData\n{\n    BYTE    Used20CallingMethod;\n    BYTE    SMBIOSMajorVersion;\n    BYTE    SMBIOSMinorVersion;\n    BYTE    DmiRevision;\n    DWORD   Length;\n    BYTE    SMBIOSTableData[1];\n} RAW_SMBIOS_DATA, * PRAW_SMBIOS_DATA;\n\ntypedef struct _SmbiosStructHeader\n{\n    BYTE Type;\n    BYTE Length;\n    WORD Handle;\n} SMBIOS_STRUCT_HEADER, *PSMBIOS_STRUCT_HEADER;\n\n// Structures\ntypedef struct _NODE {\n    wchar_t *Name;                      // Name of the node\n    struct _NODE_ATT_LINK *Attributes;  // Array of attributes linked to the node\n    struct _NODE *Parent;               // Parent node\n    struct _NODE_LINK *Children;        // Array of linked child nodes\n    int Flags;                          // Node configuration flags\n} NODE, * PNODE;\n\ntypedef struct _NODE_LINK {\n    struct _NODE *LinkedNode;           // Node attached to this node\n} NODE_LINK, * PNODE_LINK;\n\ntypedef struct _NODE_ATT {\n    wchar_t *Key;                       // Attribute name\n    wchar_t *Value;                     // Attribute value string (may be null separated multistring if NAFLG_ARRAY is set)\n    int Flags;                          // Attribute configuration flags\n} NODE_ATT, *PNODE_ATT;\n\ntypedef struct _NODE_ATT_LINK {\n    struct _NODE_ATT *LinkedAttribute;  // Attribute linked to this node\n} NODE_ATT_LINK, *PNODE_ATT_LINK;\n\n\n/********************************************************************/\n\nPRAW_SMBIOS_DATA GetSmbiosData()\n{\n    DWORD bufferSize = 0;\n\n    PRAW_SMBIOS_DATA smbios = NULL;\n\n    // Get required buffer size\n    bufferSize = GetSystemFirmwareTable('RSMB', 0, NULL, 0);\n    if (bufferSize) {\n        smbios = (PRAW_SMBIOS_DATA)LocalAlloc(LPTR, bufferSize);\n        bufferSize = GetSystemFirmwareTable('RSMB', 0, (PVOID)smbios, bufferSize);\n    }\n\n    return smbios;\n}\n\nPSMBIOS_STRUCT_HEADER GetNextStructure(PRAW_SMBIOS_DATA smbios,PSMBIOS_STRUCT_HEADER previous)\n{\n    PSMBIOS_STRUCT_HEADER next = NULL;\n    PBYTE c = NULL;\n\n\n    // Return NULL is no data found\n    if (NULL == smbios)\n        return NULL;\n\n    // Return first table if previous was NULL\n    if (NULL == previous)\n        return (PSMBIOS_STRUCT_HEADER)(&amp;smbios-&gt;SMBIOSTableData[0]);\n\n    // Move to the end of the formatted structure\n    c = ((PBYTE)previous) + previous-&gt;Length;\n\n    // Search for the end of the unformatted structure (\\0\\0)\n    while (true) {\n        if ('\\0' == *c &amp;&amp; '\\0' == *(c + 1)) {\n            /* Make sure next table is not beyond end of SMBIOS data\n             * (Thankyou Microsoft for ommitting the structure count\n             * in GetSystemFirmwareTable\n             */\n            if ((c + 2) &lt; ((PBYTE)smbios-&gt;SMBIOSTableData + smbios-&gt;Length))\n                return (PSMBIOS_STRUCT_HEADER)(c + 2);\n            else\n                return NULL; // We reached the end\n        }\n\n        c++;\n    }\n\n    return NULL;\n}\n\nPSMBIOS_STRUCT_HEADER GetNextStructureOfType(PRAW_SMBIOS_DATA smbios,PSMBIOS_STRUCT_HEADER previous, DWORD type)\n{\n    PSMBIOS_STRUCT_HEADER next = previous;\n    while (NULL != (next = GetNextStructure(smbios,next))) {\n        if (type == next-&gt;Type)\n            return next;\n    }\n\n    return NULL;\n}\n\nPSMBIOS_STRUCT_HEADER GetStructureByHandle(PRAW_SMBIOS_DATA smbios,WORD handle)\n{\n    PSMBIOS_STRUCT_HEADER header = NULL;\n\n    while (NULL != (header = GetNextStructure(smbios,header)))\n        if (handle == header-&gt;Handle)\n            return header;\n\n    return NULL;\n}\n\nLPTSTR GetSmbiosString(PSMBIOS_STRUCT_HEADER table, BYTE index)\n{\n    DWORD i = 0;\n    DWORD len = 0;\n    LPTSTR unicode = _wcsdup(_T(\"\"));\n\n    if (0 == index)\n        return unicode;\n\n    char *c = NULL;\n\n    for (i = 1, c = (char *)table + table-&gt;Length; '\\0' != *c; c += strlen(c) + 1, i++) {\n        if (i == index) {\n            LocalFree(unicode);\n\n            len = MultiByteToWideChar(CP_UTF8, 0, c, -1, NULL, 0);\n            unicode = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR)* len);\n\n            MultiByteToWideChar(CP_UTF8, 0, c, -1, unicode, len);\n            break;\n        }\n    }\n\n    return unicode;\n}\n\n//вывод значения числового параметра таблицы SMBIOS по указанному смещению\nvoid PrintBiosValue(PRAW_SMBIOS_DATA smbios,DWORD type,DWORD offset, DWORD size)\n{\n    PSMBIOS_STRUCT_HEADER head; \n    head=NULL;\n    PBYTE cursor = NULL; \n\n    head = GetNextStructureOfType(smbios,head, type);\n    if (NULL == head){ printf(\"PrintBiosValue Error!\\n\");return;}\n\n    cursor=((PBYTE)head+offset);\n\n    //value           \n    for(int i=0;i&lt;size;i++) {\n        printf(\"%02x\",(unsigned int) *cursor);     \n        cursor++;\n    }\n    printf(\"\\n\");\n}\n\n//вывод значения строкового параметра таблицы SMBIOS по указанному смещению\nvoid PrintBiosString(PRAW_SMBIOS_DATA smbios,DWORD type,DWORD offset)\n{\n    PSMBIOS_STRUCT_HEADER head; \n    head=NULL;\n    PBYTE cursor = NULL;\n\n    LPTSTR unicode = NULL;      \n\n    head = GetNextStructureOfType(smbios,head, type);\n    if (NULL == head){printf(\"PrintString Error!\\n\");return;}\n    cursor=((PBYTE)head+offset);\n    BYTE val=*cursor;\n\n    unicode = GetSmbiosString((head), *cursor);\n    //  value           \n    wprintf(unicode);\n    printf(\"\\n\");      \n    LocalFree(unicode); \n}\n\nint main(){\n\n    PRAW_SMBIOS_DATA data = GetSmbiosData();\n\n    if(data==NULL){\n        printf(\"Can't get SMBIOS data!\"); \n        return 1;\n    }   \n\n    printf(\"System UUID: \");\n    PrintBiosValue(data,SMB_TABLE_SYSTEM,8, 16); \n\n    printf(\"Chassis serial: \");\n    PrintBiosString(data,SMB_TABLE_CHASSIS,7);\n\n    printf(\"Motherboard serial: \");\n    PrintBiosString(data,SMB_TABLE_BASEBOARD,7);        \n\n    printf(\"CPUID: \");\n    PrintBiosValue(data,SMB_TABLE_PROCESSOR,8, 8);  //Таблица SMBIOS содержит только 2 DWORD-значения CPUID из 4, но этого обычно достаточно\n\n    getchar();\n}\n</code></pre>\n"}