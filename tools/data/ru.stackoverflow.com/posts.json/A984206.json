{"owner":{"reputation":22894,"user_id":32793,"user_type":"registered","accept_rate":48,"profile_image":"https://i.stack.imgur.com/6Vktl.jpg?s=128&g=1","display_name":"iluxa1810","link":"https://ru.stackoverflow.com/users/32793/iluxa1810"},"is_accepted":true,"score":3,"last_activity_date":1559139950,"last_edit_date":1559139950,"creation_date":1558515206,"answer_id":984206,"question_id":984189,"body":"<p>Имхо, нужно создать абстрактный класс <code>Shape</code> и от него пронаследовать <code>Square</code> и <code>Rectangle</code>.</p>\n\n<p>А причина проста: полиморфизм.</p>\n\n<p>Допустим, мы пронаследовали <code>Rectangle</code> от <code>Square</code> и создали метод <code>public CalcSome(Square square)</code>.</p>\n\n<p>Мы абсолютно легитимно можем в него передать <code>Rectangle</code> так как он является наследником.</p>\n\n<p>Так вот, когда пользователь будет пользоваться этим чудо-методом, то он будет полагать, что работает с квадратом и ожидать поведения квадрата, а по факту туда может попасть Rectangle.</p>\n\n<p>И как следствии логично иметь абстрактный класс <code>Shape</code>, который не дает пользователю ложные предположения.</p>\n\n<p>Кстати, вот <a href=\"https://blog.byndyu.ru/2009/10/blog-post_29.html\" rel=\"nofollow noreferrer\">тут</a> прямо в первом примере описывается почти ваша ситуация и говорится, что это противоречит Принцип замещения Лисков</p>\n"}