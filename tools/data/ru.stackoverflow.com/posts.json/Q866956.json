{"tags":["c#","wpf","многопоточность","изображения","imagesource"],"owner":{"reputation":1149,"user_id":277742,"user_type":"registered","accept_rate":71,"profile_image":"https://www.gravatar.com/avatar/72c778f378a1deb6c46e008fdac61eaa?s=128&d=identicon&r=PG","display_name":"Rootware","link":"https://ru.stackoverflow.com/users/277742/rootware"},"is_answered":true,"view_count":217,"accepted_answer_id":868062,"answer_count":2,"score":2,"last_activity_date":1534314739,"creation_date":1533893068,"last_edit_date":1534314063,"question_id":866956,"link":"https://ru.stackoverflow.com/questions/866956/wpf-%d0%bd%d0%b5%d0%b2%d0%be%d0%b7%d0%bc%d0%be%d0%b6%d0%bd%d0%be-%d0%be%d0%b1%d0%bd%d0%be%d0%b2%d0%b8%d1%82%d1%8c-%d1%8d%d0%bb%d0%b5%d0%bc%d0%b5%d0%bd%d1%82-%d0%be%d0%ba%d0%bd%d0%b0","title":"WPF невозможно обновить элемент окна","body":"<p>Использовал слайдер на <code>DispatcherTimer</code> внутри кода окна. Но после переноса в отдельный Singleton класс потоков управляющих кэшированием картинок и смены слайда выскакивает ошибка.</p>\n\n<p>Помогите побороть эту ошибку возникающую при передачи изображения в форму. Не понимаю, что делаю не так. Вроде оформил доступ к окну через делегат. И вроде подобные структуры работают нормально с текстовыми полями формы, но с изображением нет.</p>\n\n<p>Код MainWindow.xaml.cs:</p>\n\n<pre><code>public partial class MainWindow : Window\n{\n    private delegate void slideCacheUpdateDelegate(int slide, BitmapImage image);\n\n    public MainWindow()\n    {\n        SlideCache.getInstance.init();\n\n        InitializeComponent();\n\n        // Initial slide cache updater delegate.\n        SlideCache.OnRefresh += (s, i) =&gt;\n        {\n            if (Dispatcher.CheckAccess())\n                changeToNextSlide(s, i);\n            else\n                Dispatcher.BeginInvoke(new slideCacheUpdateDelegate(changeToNextSlide), new object[] { s, i });\n        };\n\n        SlideCache.getInstance.startSlideShow();\n    }\n\n    private void changeToNextSlide(int slide, BitmapImage image)\n    {\n        switch (slide)\n        {\n            case 1:\n                this.imageSlide2.Source = image;\n                DoubleAnimation animationSlide1 = new DoubleAnimation();\n                animationSlide1.From = 0;\n                animationSlide1.To = 1;\n                animationSlide1.Duration = TimeSpan.FromMilliseconds(500);\n                this.imageSlide2.BeginAnimation(Canvas.OpacityProperty, animationSlide1);\n                break;\n\n            case 2:\n                this.imageSlide1.Source = image;\n                DoubleAnimation animationSlide2 = new DoubleAnimation();\n                animationSlide2.From = 1;\n                animationSlide2.To = 0;\n                animationSlide2.Duration = TimeSpan.FromMilliseconds(500);\n                this.imageSlide2.BeginAnimation(Canvas.OpacityProperty, animationSlide2);\n                break;\n        }\n    }\n}\n</code></pre>\n\n<p>Код MainWindow.xaml:</p>\n\n<pre><code>&lt;Window x:Class=\"SlideShow.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        Title=\"MainWindow\" Height=\"350\" Width=\"525\"&gt;\n    &lt;Grid&gt;\n        &lt;StackPanel Width=\"200\" Height=\"100\" Background=\"Black\"&gt;\n            &lt;Image Name=\"imageSlide1\" Stretch=\"Fill\"/&gt;\n            &lt;Image Name=\"imageSlide2\" Stretch=\"Fill\"/&gt;\n        &lt;/StackPanel&gt;\n    &lt;/Grid&gt;\n&lt;/Window&gt;\n</code></pre>\n\n<p>Код SlideCache.cs:</p>\n\n<pre><code>public class SlideCache\n{\n    public delegate void Slider(int slide, BitmapImage holder);\n    public static event Slider OnRefresh;\n\n    private static volatile SlideCache INSTANCE;\n    private static object syncRoot = new Object();\n\n    private Thread _threadCache;\n    private Thread _threadSlide;\n\n    private Dictionary&lt;int, BitmapHolder&gt; _images;\n\n    private int _currentSlide;\n\n    private Boolean _isFirstImage;\n\n    private SlideCache()\n    {\n        // Do nothing.\n    }\n\n    public void init()\n    {\n        initDictionary();\n\n        _currentSlide = 0;\n        _isFirstImage = true;\n\n        _threadCache = new Thread(slideCache);\n        _threadCache.IsBackground = true;\n        _threadCache.SetApartmentState(ApartmentState.MTA);\n        _threadCache.Start();\n    }\n\n    private void slideShow()\n    {\n        while (true)\n        {\n            ++_currentSlide;\n            if (_images[_currentSlide] != null)\n            {\n                slideUpdate(_isFirstImage ? 1 : 2, _images[_currentSlide].getImage());\n                _isFirstImage = !_isFirstImage;\n            }\n\n            Thread.Sleep(3000);\n        }\n    }\n\n    private void slideCache()\n    {\n        while (true)\n        {\n            DateTime timestamp = DateTime.Now;\n            for (int i = 0; i &lt; 10; i++ )\n            {\n                int slideId = i + 1;\n                BitmapHolder holder = _images[slideId];\n                if (holder == null || holder.getTimestamp() &lt; timestamp)\n                {\n                    BitmapImage image = new BitmapImage();\n                    image.BeginInit();\n                    image.UriSource = new Uri(\"http://example.com/slide_\" + slideId);\n                    image.EndInit();\n\n                    if (holder != null &amp;&amp; holder.getImage() != null &amp;&amp; image.PixelWidth == 1)\n                        continue;\n\n                    _images[slideId] = new BitmapHolder(timestamp.AddSeconds(new Random().Next(180, 600)), image);\n                }\n            }\n\n            Thread.Sleep(1000);\n        }\n    }\n\n    private void initDictionary()\n    {\n        _images = new Dictionary&lt;int, BitmapHolder&gt;(10);\n\n        for (int i = 0; i &lt; 10; i++)\n            _images.Add((i + 1), null);\n    }\n\n    private void slideUpdate(int slide, BitmapImage image)\n    {\n        OnRefresh.Invoke(slide, image);\n    }\n\n    public void startSlideShow()\n    {\n        _threadSlide = new Thread(slideShow);\n        _threadSlide.IsBackground = true;\n        _threadSlide.SetApartmentState(ApartmentState.MTA);\n        _threadSlide.Start();\n    }\n\n    public void stopSlideShow()\n    {\n        _threadSlide.Abort();\n    }\n\n    public void changeToNextSlide(int slide)\n    {\n        _currentSlide = slide;\n        slideUpdate(_isFirstImage ? 1 : 2, _images[_currentSlide].getImage());\n        _isFirstImage = !_isFirstImage;\n    }\n\n    public Boolean slideShowEnabled()\n    {\n        return _threadSlide.ThreadState == ThreadState.Running;\n    }\n\n    public static SlideCache getInstance\n    {\n        get\n        {\n            if (INSTANCE == null)\n            {\n                lock (syncRoot)\n                {\n                    if (INSTANCE == null)\n                        INSTANCE = new SlideCache();\n                }\n            }\n\n            return INSTANCE;\n        }\n    }\n}\n</code></pre>\n\n<p>Код BitmapHolder.cs:</p>\n\n<pre><code>public class BitmapHolder\n{\n    private DateTime _timestamp;\n    private BitmapImage _image;\n\n    public BitmapHolder(DateTime timestamp, BitmapImage image)\n    {\n        _timestamp = timestamp;\n        _image = image;\n    }\n\n    public DateTime getTimestamp()\n    {\n        return _timestamp;\n    }\n\n    public BitmapImage getImage()\n    {\n        return _image;\n    }\n}\n</code></pre>\n\n<p>При запуске приложение зависает и выскакивает следущая ошибка в VS:</p>\n\n<blockquote>\n  <p><strong>System.InvalidOperationException не обработано пользовательским кодом</strong> Вызывающий поток не может получить доступ к данному объекту,\n  так как владельцем этого объекта является другой поток.</p>\n</blockquote>\n\n<p><strong>Решение проблемы:</strong></p>\n\n<pre><code>BitmapImage image = new BitmapImage();\nimage.BeginInit();\nimage.CacheOption = BitmapCacheOption.OnLoad;\nimage.StreamSource = new MemoryStream(new WebClient().DownloadData(\"http://example.com/Slide_\" + slideId + \".png\"));\nimage.EndInit();\nimage.Freeze();\n</code></pre>\n\n<p>Спасибо <a href=\"https://ru.stackoverflow.com/users/240512/msdn-whiteknight\">MSDN.WhiteKnight</a> за помощь с проверкой локальных ресурсов. Ваш ответ был ближе всего к решению проблемы.</p>\n\n<p>P.S. Сама проблема была не с доступом к элементу UI из другого потока, а с блокированным ресурсом который поток из <code>Singleton</code> класса пытался передать в UI. Т.е. нужно было взять картинку как стрим поток и на основании его создать ресурс. А далее как в MSDN описании <code>Freeze()</code> для совместного использования. Надеюсь кому-то пригодится, т.к. проблема не единичная, по крайней мере, на EN SO.</p>\n"}