{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":0,"last_activity_date":1492659648,"last_edit_date":1492659648,"creation_date":1492633128,"answer_id":655882,"question_id":654754,"body":"<p>Нашел один способ принудительного завершения задачи без нарушения работы приложения. Данный способ позволяет завершить задачу, запущенную с параметром <em>TaskCreationOptions.LongRunning</em>, зная ID рабочего потока. Основан на вызове функции <em>ExitThread</em> в контексте целевого потока с помощью недокументированной функции <em>RtlRemoteCall</em>. Способ не работает, если поток бесконечно находится в состоянии ожидания, можно завершить только работающий поток. Т.е это не на 100% надежно, но, я полагаю, получше чем <em>Thread.Abort</em>. </p>\n\n<p>Если задача исполняет ваш собственный код, ID рабочего потока легко получить, вызывая из нее функцию GetCurrentThreadId и сохраняя результат в переменной. Если задача исполняет чужой код (например, подгружаемый из внешней DLL), можно его узнать только выборкой из потоков по времени старта задачи.</p>\n\n<p><strong>Основной класс:</strong></p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\n\nnamespace TaskTest\n{\n    public class TaskKiller\n    {\n        const int THREAD_ACCESS_TERMINATE = (0x0001);\n        const int SYNCHRONIZE = (0x00100000);\n        const int STANDARD_RIGHTS_REQUIRED = (0x000F0000);\n        const int THREAD_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFFF);\n\n        [DllImport(\"kernel32.dll\")]\n        public static extern IntPtr OpenThread(uint dwDesiredAccess, bool bInheritHandle,\n           uint dwThreadId);\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool CloseHandle(IntPtr hObject);\n\n\n        [DllImport(\"kernel32.dll\")]\n        public static extern uint GetCurrentThreadId();       \n\n\n        [DllImport(\"kernel32.dll\")]\n        public static extern IntPtr GetCurrentProcess();\n\n        [DllImport(\"kernel32.dll\")]\n        public static extern IntPtr GetCurrentThread();\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        public static extern IntPtr GetModuleHandle(string lpModuleName);\n\n        [DllImport(\"kernel32\", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]\n        public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);        \n\n        [DllImport(\"ntdll.dll\", ExactSpelling = true, EntryPoint = \"RtlRemoteCall\")]\n        static extern int RtlRemoteCall(\n    IntPtr Process,\n    IntPtr Thread,\n    IntPtr CallSite,\n    uint ArgumentCount,\n    IntPtr Arguments,\n    uint PassContext,\n    uint AlreadySuspended\n    );\n\n\n        /// &lt;summary&gt;\n        /// Завершение потока с указанным ID\n        /// &lt;/summary&gt;        \n        /// &lt;returns&gt;0 при успешном завершении, код NTSTATUS при ошибке&lt;/returns&gt;\n        public static int KillThreadById(uint threadid)\n        {\n            IntPtr hModule = (IntPtr)0;\n            IntPtr hThread = (IntPtr)0;\n            IntPtr unmanagedPointer = (IntPtr)0;\n            try\n            {\n                /*Получение адреса функции ExitThread*/\n                hModule = GetModuleHandle(@\"kernel32.dll\");\n                IntPtr pProc = (IntPtr)0;\n                pProc = GetProcAddress(hModule, \"ExitThread\");\n\n                /*Получение дескриптора потока с полным доступом*/\n                hThread = TaskKiller.OpenThread(\n                    (uint)(THREAD_ALL_ACCESS),\n                    false, (uint)threadid);\n\n                IntPtr hProcess = GetCurrentProcess();\n\n                int[] args = new int[] { (int)0 };//массив аргументов для RtlRemoteCall\n                unmanagedPointer = Marshal.AllocHGlobal(args.Length * sizeof(int));//выделение блока неуправлемой памяти\n                Marshal.Copy(args, 0, unmanagedPointer, args.Length);//копирование массива в неуправляемую память\n\n                /*Вызов ExitThread в контексте завершаемого потока*/\n                int result = RtlRemoteCall(hProcess, hThread, pProc, 1, unmanagedPointer, 0, 0);\n                return result;\n            }\n            finally\n            {\n                // Clean up resources\n                if(unmanagedPointer !=(IntPtr)0)Marshal.FreeHGlobal(unmanagedPointer);\n                if (hThread != (IntPtr)0) TaskKiller.CloseHandle(hThread);\n                if (hModule != (IntPtr)0) TaskKiller.CloseHandle(hModule);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Получение ID всех потоков, стартовавших в указанном интервале времени\n        /// &lt;/summary&gt;        \n        public static List&lt;uint&gt; GetThreadsByStartTime(DateTime t1, DateTime t2)\n        {\n            List&lt;uint&gt; threads = new List&lt;uint&gt;();\n\n            Process pr=Process.GetCurrentProcess();\n            using (pr)\n            {\n                ProcessThreadCollection ths = pr.Threads;\n\n                foreach (ProcessThread th in ths)\n                {\n                    using (th)\n                    {\n                        if (th.TotalProcessorTime.TotalMilliseconds &gt; 0)\n                        {\n                            if (DateTime.Compare(th.StartTime, t1) &gt;= 0 &amp;&amp;\n                                DateTime.Compare(th.StartTime, t2) &lt;= 0) threads.Add((uint)th.Id);\n                        }\n                    }\n                }\n            }\n            return threads;\n        }\n\n    }\n\n}\n</code></pre>\n\n<p><strong>Пример использования:</strong></p>\n\n<pre><code>    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n    using System.Text;\n    using System.Windows.Forms;\n    using System.Threading;\n    using System.Threading.Tasks;\n    using System.Diagnostics;\n    using System.Runtime.InteropServices;\n\n    namespace TaskTest\n    {\n        public partial class Form1 : Form\n        {        \n\n            public Form1()\n            {\n                InitializeComponent();\n                PrintThreads();\n            }\n\n            int i = 0;\n            uint threadid;//ID рабочего потока        \n\n            DateTime t;//время старта задачи\n            Task t1=null;//задача\n\n\n            void PrintThreads()\n            {\n                Process pr=Process.GetCurrentProcess();\n                using (pr)\n                {\n                    ProcessThreadCollection ths = pr.Threads;\n\n                    StringBuilder b = new StringBuilder(300);\n                    b.AppendLine(\"Threads: \" + ths.Count);\n                    foreach (ProcessThread th in ths)\n                    {\n                        using (th)\n                        {\n                            b.AppendLine(th.Id + \" - \" + th.ThreadState.ToString()+\" - \"+th.StartTime);\n                        }\n                    }\n                    textBox1.Text += b.ToString();\n                }\n            }\n\n\n            private void button1_Click(object sender, EventArgs e)\n            {\n\n                /*Делегат для задачи*/\n                Action action = () =&gt;\n                {\n                    threadid = TaskKiller.GetCurrentThreadId(); //сохранить ID потока для последующего доступа                               \n\n                    while (true)// Just loop.\n                    {      \n                        i++;                    \n                    }\n                };\n\n                // Construct an unstarted task            \n                t1 = new Task(action,TaskCreationOptions.LongRunning);            \n\n                // Launch task             \n                t1.Start();\n                t = DateTime.Now;//сохранить время старта для последующего использования\n\n                textBox1.Text = \"Task started\"+Environment.NewLine;\n                PrintThreads();\n            }\n\n            private void button2_Click(object sender, EventArgs e)\n            {\n                //Завершение потока, если известен его ID\n                textBox1.Text = \"-- Before terminating --\" + Environment.NewLine;\n                PrintThreads();\n                textBox1.Text += Environment.NewLine;\n\n                int res=TaskKiller.KillThreadById(threadid);\n                if (res != 0)\n                {\n                    textBox1.Text += (\"Error NTSTATUS=\" + res.ToString(\"X\"));\n                }\n                else\n                {\n                    textBox1.Text += threadid.ToString() + \" is terminated!\";\n                }\n                textBox1.Text += Environment.NewLine;\n\n                textBox1.Text += \"-- After terminating --\" + Environment.NewLine;\n                PrintThreads();\n            }\n\n            private void bTerminate_Click(object sender, EventArgs e)\n            {\n                //Завершение потоков по времени старта\n                textBox1.Text = \"-- Before terminating --\" + Environment.NewLine;\n                PrintThreads();\n                textBox1.Text += \"-----------------------\";\n                textBox1.Text += Environment.NewLine;\n\n                List&lt;uint&gt; threads=TaskKiller.GetThreadsByStartTime(\n                    t.Subtract(TimeSpan.FromSeconds(1)),\n                    t.Add(TimeSpan.FromSeconds(1))\n                    );\n\n                foreach (uint id in threads)\n                {\n                    TaskKiller.KillThreadById(id);\n                    textBox1.Text += id.ToString() + \" is terminated!\";\n                    textBox1.Text += Environment.NewLine;\n                }\n\n                textBox1.Text += \"-- After terminating --\" + Environment.NewLine;\n                PrintThreads();\n                textBox1.Text += \"-----------------------\";\n\n            }   \n\n\n       } \n    }\n</code></pre>\n"}