{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":1,"last_activity_date":1563781641,"last_edit_date":1563781641,"creation_date":1563778614,"answer_id":1005370,"question_id":1004275,"body":"<p>Например, так (в предположении, что все наследники в одной сборке, и что наплевать на производительность):</p>\n\n<pre><code>using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Reflection;\n\nnamespace ConsoleApp1\n{\n    abstract class Data\n    {\n        public static Data CreateDataInstance(int id)\n        {\n            var derived = typeof(Data).Assembly.GetTypes().Where(t =&gt; t.BaseType == typeof(Data));\n            var types = derived.Where(\n                    t =&gt; (t.GetCustomAttribute(typeof(DataIdAttribute)) as DataIdAttribute).ID == id\n                );\n            if (types.Count() == 0) throw new MissingMemberException(\"No such type with ID \"+id.ToString());            \n\n            Type type = types.First();\n            return (Data)Activator.CreateInstance(type);\n        }\n    }\n\n    class DataIdAttribute : Attribute\n    {\n        int _id;\n\n        public int ID { get { return _id; } }\n\n        public DataIdAttribute(int id)\n        {\n            _id = id;\n        }\n    }\n\n    [DataId(1)]\n    class DataA : Data\n    {\n        public override string ToString()\n        {\n            return \"DataA\";\n        }\n    }\n\n    [DataId(2)]\n    class DataB : Data\n    {\n        public override string ToString()\n        {\n            return \"DataB\";\n        }\n    }\n}\n</code></pre>\n\n<p>Если же производительность важна, но допустимы некоторые накладные расходы при первом обращении, можно предложить более громоздкое оптимизированное решение:</p>\n\n<pre><code>using System;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Reflection;\n\nnamespace ConsoleApp1\n{\n    abstract class Data\n    {\n        static Dictionary&lt;int, Delegate&gt; delegcache = new Dictionary&lt;int, Delegate&gt;();\n\n        public static Data CreateDataInstance(int id)\n        {\n            Delegate deleg;\n            if (delegcache.ContainsKey(id))\n            {\n                deleg = delegcache[id];\n            }\n            else\n            {\n                var derived = typeof(Data).Assembly.GetTypes().Where(t =&gt; t.BaseType == typeof(Data));\n                var types = derived.Where(\n                        t =&gt; (t.GetCustomAttribute(typeof(DataIdAttribute)) as DataIdAttribute).ID == id\n                    );\n                if (types.Count() == 0) throw new MissingMemberException(\"No such type with ID \" + id.ToString());\n\n                Type type = types.First();\n                NewExpression expr = Expression.New(type);\n                LambdaExpression lambda = Expression.Lambda(expr);\n                deleg = lambda.Compile();\n                delegcache[id] = deleg;\n            }\n\n            return (Data)deleg.DynamicInvoke();\n        }\n    }\n\n    class DataIdAttribute : Attribute\n    {\n        int _id;\n\n        public int ID { get { return _id; } }\n\n        public DataIdAttribute(int id)\n        {\n            _id = id;\n        }\n    }\n\n    [DataId(1)]\n    class DataA : Data\n    {\n        public override string ToString()\n        {\n            return \"DataA\";\n        }\n    }\n\n    [DataId(2)]\n    class DataB : Data\n    {\n        public override string ToString()\n        {\n            return \"DataB\";\n        }\n    }  \n}\n</code></pre>\n"}