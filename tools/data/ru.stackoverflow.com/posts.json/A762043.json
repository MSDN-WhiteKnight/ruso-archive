{"owner":{"reputation":7171,"user_id":222542,"user_type":"registered","accept_rate":100,"profile_image":"https://i.stack.imgur.com/sPLXw.jpg?s=128&g=1","display_name":"Bulson","link":"https://ru.stackoverflow.com/users/222542/bulson"},"is_accepted":false,"score":2,"last_activity_date":1514218940,"last_edit_date":1514218940,"creation_date":1513959749,"answer_id":762043,"question_id":753484,"body":"<p>Как я понял вам важно сохранять видеокадры в файлы, причем желательно обрабатывать несколько видеофайлов одновременно. Потому, в данном случае, пришлось отказаться от <code>VideoSourcePlayer</code>, он ведь может работать только с одним файлом за раз. </p>\n\n<p>У меня получилась такая программулина</p>\n\n<p><a href=\"https://i.stack.imgur.com/l0jUn.gif\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/l0jUn.gif\" alt=\"Пример работы программы\"></a></p>\n\n<p>Вот такой класс для работы с этой библиотекой пришлось написать</p>\n\n<pre><code>public class AFService\n{\n    private readonly IVideoSource _fileVideoSource;\n    private readonly string _savingDirectory;\n    private readonly string _fileName;\n\n    private int _skipFrames;\n    private int _numberPassedFrames;\n    private int _numberSavedFrames;\n\n    //ctor\n    public AFService(string pathToFile) : this(pathToFile, Path.GetDirectoryName(pathToFile))\n    {}\n    public AFService(string pathToFile, string dirToSave)\n    {\n        if (String.IsNullOrEmpty(pathToFile)) throw new ArgumentException(nameof(pathToFile));\n        if (String.IsNullOrEmpty(dirToSave)) throw new ArgumentException(nameof(dirToSave));\n        if (!File.Exists(pathToFile)) throw new FileNotFoundException(pathToFile);\n\n        _savingDirectory = dirToSave;\n        _fileName = Path.GetFileNameWithoutExtension(pathToFile);\n\n        string extension = Path.GetExtension(pathToFile);\n        if (extension.Contains(\"avi\"))\n        {\n            _fileVideoSource = new AVIFileVideoSource(pathToFile);\n        }\n        else\n        {\n            _fileVideoSource = new FileVideoSource(pathToFile);\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Кадр захвачен и сохранен\n    /// &lt;/summary&gt;\n    public event EventHandler&lt;AFServiceEventArgs&gt; FrameCaptured;\n\n    /// &lt;summary&gt;\n    /// Захват кадров закончен\n    /// &lt;/summary&gt;\n    public event EventHandler&lt;AFServiceEventArgs&gt; CaptureFinished;\n\n    /// &lt;summary&gt;\n    /// Захват кадров видео файла в jpg файлы\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"cancellationToken\"&gt;токен отмены&lt;/param&gt;\n    /// &lt;param name=\"skipFrames\"&gt;шаг пропуска кадров, по-умолчанию равно 30&lt;/param&gt;\n    /// &lt;returns&gt;количество сохраненных кадров&lt;/returns&gt;\n    public async Task&lt;int&gt; CaptureFramesAsync(CancellationToken cancellationToken, int skipFrames = 30)\n    {\n        //запоминаем шаг пропуска\n        _skipFrames = skipFrames;\n\n        //готовимся\n        AsyncVideoSource source = new AsyncVideoSource(_fileVideoSource, true);\n        source.PlayingFinished += Source_PlayingFinished;\n        source.NewFrame += Source_NewFrame;\n        source.VideoSourceError += Source_VideoSourceError;\n\n        //начинаем процесс\n        await Task.Run(() =&gt;\n        {\n            source.Start();\n            //ждем окончания прохода по всему видеофайлу\n            while (source.IsRunning)\n            {\n                if (cancellationToken.IsCancellationRequested)\n                {\n                    source.Stop();\n                    //выброс исключения в случае отмены задачи\n                    cancellationToken.ThrowIfCancellationRequested();\n                    break;\n                }\n\n                //Debug.WriteLine($\"FramesReceived-{source.FramesReceived}\");\n                //Debug.WriteLine($\"FramesProcessed-{source.FramesProcessed}\");\n                //Debug.WriteLine($\"BytesReceived-{source.BytesReceived}\");\n            }\n        });\n\n        //отдаем результат\n        return _numberSavedFrames;\n    }\n\n    private void Source_NewFrame(object sender, NewFrameEventArgs eventArgs)\n    {\n        AsyncVideoSource source = sender as AsyncVideoSource;\n        _numberPassedFrames += source.FramesProcessed;\n        Debug.WriteLine($\"Поступил кадр: {_numberPassedFrames}\");\n\n        //пропускаем ненужные кадры\n        if (_numberPassedFrames % _skipFrames != 0) return;\n\n        Debug.WriteLine($\"!&lt;-- Взят в обработку: {_numberPassedFrames}\");\n\n        //увеличиваем счетчик запоминаемых кадров\n        _numberSavedFrames++;\n        //формируем имя файла\n        var file = Path.Combine(_savingDirectory, $\"{_fileName}-{_numberSavedFrames}.jpg\");\n\n        //сохраняем кадр в файл\n        Image img = eventArgs.Frame;\n        img.Save(file, ImageFormat.Jpeg);\n        Debug.WriteLine($\"!&lt;-- cохраненен под именем: {file}\");\n\n        //вызываем событие сохранения кадра\n        var evArg = new AFServiceEventArgs(String.Empty, file, _numberSavedFrames, _numberPassedFrames);\n        FrameCaptured?.Invoke(this, evArg);\n    }\n\n    private void Source_PlayingFinished(object sender, ReasonToFinishPlaying reason)\n    {\n        Debug.WriteLine($\"Захват отработал у файла: {_fileName}\");\n\n        //вызываем событие окончания работы над файлом\n        var evArg = new AFServiceEventArgs(reason.ToString(), String.Empty, _numberSavedFrames, _numberPassedFrames);\n        CaptureFinished?.Invoke(this, evArg);\n    }\n\n    private void Source_VideoSourceError(object sender, VideoSourceErrorEventArgs eventArgs)\n    {\n        //вызываем событие окончания работы над файлом\n        var evArg = new AFServiceEventArgs(eventArgs.Description, String.Empty, 0, 0);\n        CaptureFinished?.Invoke(this, evArg);\n    }\n}\n</code></pre>\n\n<p>Работа протестирована на файлах <code>wmv</code>, на <code>avi</code> почему-то вылезает ошибка, но я надеюсь, что вы далее сами поработайте и все наладите. Весь проект целиком можно скачать <a href=\"https://yadi.sk/d/M_T-37ZJ3QwVmA\" rel=\"nofollow noreferrer\">здесь</a>.</p>\n"}