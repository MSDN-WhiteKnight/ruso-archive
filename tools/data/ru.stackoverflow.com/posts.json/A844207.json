{"owner":{"reputation":16068,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1529471730,"creation_date":1529471730,"answer_id":844207,"question_id":765731,"body":"<p>Можно сделать это путем чтения Process Environment Block (PEB) с помощью  функций Native API <em>NtWow64QueryInformationProcess64</em> и <em>NtWow64ReadVirtualMemory64</em>:</p>\n\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;tchar.h&gt;\n\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include &lt;windows.h&gt;\n\n#define NT_SUCCESS(x) ((x) &gt;= 0)\n\n// Namespace is present Not to collide with \"winbase.h\"\n// definition of PROCESS_INFORMATION_CLASS and others.\nnamespace sys\n{\n\ntypedef enum _PROCESS_INFORMATION_CLASS {\n    ProcessBasicInformation,\n    ProcessQuotaLimits,\n    ProcessIoCounters,\n    ProcessVmCounters,\n    ProcessTimes,\n    ProcessBasePriority,\n    ProcessRaisePriority,\n    ProcessDebugPort,\n    ProcessExceptionPort,\n    ProcessAccessToken,\n    ProcessLdtInformation,\n    ProcessLdtSize,\n    ProcessDefaultHardErrorMode,\n    ProcessIoPortHandlers,\n    ProcessPooledUsageAndLimits,\n    ProcessWorkingSetWatch,\n    ProcessUserModeIOPL,\n    ProcessEnableAlignmentFaultFixup,\n    ProcessPriorityClass,\n    ProcessWx86Information,\n    ProcessHandleCount,\n    ProcessAffinityMask,\n    ProcessPriorityBoost,\n    MaxProcessInfoClass\n} PROCESS_INFORMATION_CLASS, *PPROCESS_INFORMATION_CLASS;\n\n// ------------------------------------------------------------------------\n// Structs.\n// ------------------------------------------------------------------------\n\ntypedef struct _PROCESS_BASIC_INFORMATION64 {\n    ULONGLONG Reserved1;\n    ULONGLONG PebBaseAddress;\n    ULONGLONG Reserved2[2];\n    ULONGLONG UniqueProcessId;\n    ULONGLONG Reserved3;\n} PROCESS_BASIC_INFORMATION64;\n\ntypedef struct _PEB_LDR_DATA64 {\n    ULONG Length;\n    BOOLEAN Initialized;\n    ULONGLONG SsHandle;\n    LIST_ENTRY64 InLoadOrderModuleList;\n    LIST_ENTRY64 InMemoryOrderModuleList;\n    LIST_ENTRY64 InInitializationOrderModuleList;\n} PEB_LDR_DATA64, *PPEB_LDR_DATA64;\n\n// Structure is cut down to ProcessHeap.\ntypedef struct _PEB64 {\n    BOOLEAN InheritedAddressSpace;\n    BOOLEAN ReadImageFileExecOptions;\n    BOOLEAN BeingDebugged;\n    BOOLEAN Spare;\n    ULONGLONG Mutant;\n    ULONGLONG ImageBaseAddress;\n    ULONGLONG LoaderData;\n    ULONGLONG ProcessParameters;\n    ULONGLONG SubSystemData;\n    ULONGLONG ProcessHeap;\n} PEB64;\n\ntypedef struct _UNICODE_STRING64 {\n    USHORT Length;\n    USHORT MaximumLength;\n    ULONGLONG Buffer;\n} UNICODE_STRING64;\n\ntypedef struct _LDR_DATA_TABLE_ENTRY64 {\n    LIST_ENTRY64 InLoadOrderModuleList;\n    LIST_ENTRY64 InMemoryOrderModuleList;\n    LIST_ENTRY64 InInitializationOrderModuleList;\n    ULONGLONG BaseAddress;\n    ULONGLONG EntryPoint;\n    DWORD64 SizeOfImage;\n    UNICODE_STRING64 FullDllName;\n    UNICODE_STRING64 BaseDllName;\n    ULONG Flags;\n    SHORT LoadCount;\n    SHORT TlsIndex;\n    LIST_ENTRY64 HashTableEntry;\n    ULONGLONG TimeDateStamp;\n} LDR_DATA_TABLE_ENTRY64, *PLDR_DATA_TABLE_ENTRY64;\n\n}  // namespace sys\n\n// ------------------------------------------------------------------------\n// Function prototypes.\n// ------------------------------------------------------------------------\n\ntypedef NTSTATUS(NTAPI *_NtWow64QueryInformationProcess64)(\n    IN HANDLE ProcessHandle,\n    ULONG ProcessInformationClass,\n    OUT PVOID ProcessInformation,\n    IN ULONG ProcessInformationLength,\n    OUT PULONG ReturnLength OPTIONAL);\n\ntypedef NTSTATUS(NTAPI *_NtWow64ReadVirtualMemory64)(\n    IN HANDLE ProcessHandle,\n    IN DWORD64 BaseAddress,\n    OUT PVOID Buffer,\n    IN ULONG64 Size,\n    OUT PDWORD64 NumberOfBytesRead);\n\n\n//Functions to print error messages\nvoid ErrorMes(LPTSTR lpszFunction,WCHAR* buf) \n{ \n    // Retrieve the system error message for the last-error code\n    LPVOID lpMsgBuf;\n    LPVOID lpDisplayBuf;\n    DWORD dw = GetLastError(); \n\n    FormatMessage(\n        FORMAT_MESSAGE_ALLOCATE_BUFFER | \n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,\n        dw,\n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n        (LPTSTR) &amp;lpMsgBuf,\n        0, NULL );\n\n    // Print the error message \n    lpDisplayBuf = (LPVOID)LocalAlloc(LMEM_ZEROINIT, \n        (lstrlen((LPCTSTR)lpMsgBuf) + lstrlen((LPCTSTR)lpszFunction) + 40) * sizeof(TCHAR)); \n    swprintf(buf,L\"%s returned error 0x%x: %s\", \n        lpszFunction, dw, lpMsgBuf);     \n\n    LocalFree(lpMsgBuf);\n    LocalFree(lpDisplayBuf);\n}\n\nvoid RaiseError(LPTSTR lpszFunction){\n    WCHAR buf[1024]={0};\n    ErrorMes(lpszFunction,buf);\n    std::wcout &lt;&lt; buf &lt;&lt; std::endl;\n    throw std::exception(\"WINAPI call failed\");\n}\n\n#ifndef WIN32\n#   error \"This application must be built as an x86 executable\"\n#endif\n\n#define GET_FUNC_ADDR(name) _##name name = (_##name)::GetProcAddress(::GetModuleHandleA(\"ntdll.dll\"), #name)\n\n#define CHECK_ERROR(clause, func) if (!(clause)) { RaiseError(func); }\n\nnamespace\n{\n\nstruct close_on_exit\n{\n    close_on_exit(HANDLE ptr)\n        : ptr_(ptr)\n    { };\n\n    ~close_on_exit()\n    {\n        if (ptr_)\n        {\n            ::CloseHandle(ptr_);\n            ptr_ = nullptr;\n        }\n    }\n\nprivate:\n    HANDLE ptr_;\n};\n\n// Create C++ string based on unicode data \nstd::wstring CreateString(std::vector&lt;uint8_t&gt; &amp;raw_bytes)\n{\n    std::vector&lt;uint16_t&gt; unicode(raw_bytes.size() &gt;&gt; 1, 0);\n    memcpy(unicode.data(), raw_bytes.data(), raw_bytes.size());    \n\n    const std::wstring wide_string(unicode.begin(), unicode.end());    \n\n    return wide_string;\n}\n\n//Open process handle by its ID\nvoid *get_handle(uint32_t id)\n{\n\n    HANDLE handle = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);   \n    CHECK_ERROR(NULL != handle, L\"OpenProcess\");    \n\n    return handle;\n}\n\nvoid check_if_process_is_x64(HANDLE handle)\n{\n    BOOL is_wow64_process = TRUE;\n    CHECK_ERROR(::IsWow64Process(handle, &amp;is_wow64_process), L\"IsWow64Process\");\n\n    if(FALSE != is_wow64_process) throw std::exception( \"Target process is not x64 one\");\n}\n\nstd::vector&lt;uint8_t&gt; read_mem(HANDLE handle, uint64_t address, uint32_t length)\n{\n    if(handle == NULL)throw std::exception(\"Process handle is null\");\n\n    std::vector&lt;uint8_t&gt; data(length, 0);\n\n    GET_FUNC_ADDR(NtWow64ReadVirtualMemory64);\n\n    NTSTATUS status = NtWow64ReadVirtualMemory64(handle, address, data.data(), data.size(), FALSE);\n\n    if(!NT_SUCCESS(status)){\n        std::wcout &lt;&lt; L\"NtWow64ReadVirtualMemory64 status: \" &lt;&lt; status &lt;&lt;std::endl;\n        throw std::exception(\"NT API call failed\");\n    }\n\n    return data;\n}\n\nvoid read_pbi(HANDLE handle, sys::PROCESS_BASIC_INFORMATION64 &amp;pbi)\n{\n    if(handle == NULL)throw std::exception(\"Process handle is null\");\n\n    GET_FUNC_ADDR(NtWow64QueryInformationProcess64);\n\n    NTSTATUS status = NtWow64QueryInformationProcess64(handle, sys::ProcessBasicInformation, &amp;pbi, sizeof(pbi), NULL);\n\n    if(!NT_SUCCESS(status)){\n        std::wcout &lt;&lt; L\"NtQueryInformationProcess status: \" &lt;&lt; status &lt;&lt; std::endl;\n        throw std::exception(\"NT API call failed\");\n    }\n}\n\nstd::vector&lt;uint8_t&gt; read_peb_data(HANDLE handle)\n{\n    sys::PROCESS_BASIC_INFORMATION64 pbi = { 0 };\n    read_pbi(handle, pbi);\n\n    return read_mem(handle, pbi.PebBaseAddress, sizeof(sys::PEB64));\n}\n\n//Prints 64-bit process modules\nbool get_modules_load_order_via_peb(HANDLE handle)\n{    \n\n    std::vector&lt;uint8_t&gt; read_peb = read_peb_data(handle);\n    sys::PEB64 *peb = (sys::PEB64 *)read_peb.data();\n\n    // ------------------------------------------------------------------------\n    // Read memory from pointer to loader data structures.\n    // ------------------------------------------------------------------------\n    std::vector&lt;uint8_t&gt; read_peb_ldr_data = read_mem(handle, (uintptr_t)peb-&gt;LoaderData, sizeof(sys::PEB_LDR_DATA64));\n    sys::PEB_LDR_DATA64 *peb_ldr_data = (sys::PEB_LDR_DATA64 *)read_peb_ldr_data.data();\n    sys::PEB_LDR_DATA64 *loader_data = (sys::PEB_LDR_DATA64 *)peb-&gt;LoaderData;\n\n    const uintptr_t addr_of_ptr_to_first_ldr_module = (uintptr_t)loader_data\n        + ((uintptr_t)&amp;loader_data-&gt;InLoadOrderModuleList - (uintptr_t)&amp;loader_data-&gt;Length);\n\n    ULONGLONG address = peb_ldr_data-&gt;InLoadOrderModuleList.Flink;\n\n    uint32_t counter = 1;\n\n    // ------------------------------------------------------------------------\n    // Traversing loader data structures.\n    // ------------------------------------------------------------------------\n    do\n    {\n        std::vector&lt;uint8_t&gt; read_ldr_table_entry = read_mem(handle, address, sizeof(sys::LDR_DATA_TABLE_ENTRY64));\n\n        sys::LDR_DATA_TABLE_ENTRY64 *ldr_table_entry = (sys::LDR_DATA_TABLE_ENTRY64 *)read_ldr_table_entry.data();\n\n        std::vector&lt;uint8_t&gt; unicode_name = read_mem(handle, ldr_table_entry-&gt;BaseDllName.Buffer, ldr_table_entry-&gt;BaseDllName.MaximumLength);\n        std::wstring name = CreateString(unicode_name);\n\n        std::wcout  &lt;&lt; name &lt;&lt; std::endl;   \n\n        ldr_table_entry = (sys::LDR_DATA_TABLE_ENTRY64 *)read_ldr_table_entry.data();\n        address = (uintptr_t)ldr_table_entry-&gt;InLoadOrderModuleList.Flink;\n    } while (addr_of_ptr_to_first_ldr_module != address);       \n\n    return true;\n}\n\n}  // namespace\n\n\n/********************************************************************************/\nint _tmain(int argc, _TCHAR* argv[])\n{       \n\n    try\n    {\n        HANDLE handle = get_handle(2564);\n        close_on_exit auto_close_handle(handle);\n\n        check_if_process_is_x64(handle);\n\n        std::wcout &lt;&lt; L\"------------- Modules: ------------------------\\n\";\n        get_modules_load_order_via_peb(handle);\n        std::wcout &lt;&lt; L\"-----------------------------------------------\\n\";\n    }\n    catch (const std::exception &amp;e)\n    {\n        std::wcout &lt;&lt; L\"\\n----------------------------------------------------\\n\";\n        std::wcout &lt;&lt; \"Exception occurred: \" &lt;&lt; e.what();\n        std::wcout &lt;&lt; L\"\\n----------------------------------------------------\\n\";\n    }\n\n    return 0;\n}\n</code></pre>\n\n<p>Источник: <a href=\"https://stackoverflow.com/a/44502139/8674428\">ответ greenpiece на stackoverflow.com</a></p>\n"}