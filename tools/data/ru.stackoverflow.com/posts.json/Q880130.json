{"tags":["c#","указатели","память"],"owner":{"reputation":4498,"user_id":248572,"user_type":"registered","accept_rate":85,"profile_image":"https://i.stack.imgur.com/52azV.png?s=128&g=1","display_name":"Kir_Antipov","link":"https://ru.stackoverflow.com/users/248572/kir-antipov"},"is_answered":true,"view_count":114,"accepted_answer_id":880147,"answer_count":3,"score":4,"last_activity_date":1563532093,"creation_date":1536679377,"question_id":880130,"link":"https://ru.stackoverflow.com/questions/880130/%d0%90%d0%bd%d0%b0%d0%bb%d0%be%d0%b3-ptrtostructure-%d0%b4%d0%bb%d1%8f-%d0%ba%d0%bb%d0%b0%d1%81%d1%81%d0%be%d0%b2","title":"Аналог PtrToStructure для классов","body":"<p>Товарищи, стал мне интересен следующий вопрос:</p>\n\n<p>Положим, есть у нас примера ради структура <code>System.Drawing.Point</code><br>\nМы спокойно можем баловаться с ней следующим образом:</p>\n\n<pre><code>// Инициализируем нашу структурку\nPoint point = new Point(2, 3);\n\n// Получаем ее адрес\nPoint* pointer = &amp;point;\n\n// Получим ее данные\nint x = ((int*)pointer)[0]; // 2\nint y = ((int*)pointer)[1]; // 3\n\n// Получаем ту же структуру, разыменовав указатель\nPoint copied = *pointer;\n\n// Или так (получаем нулевую `Point` по указателю)\ncopied = pointer[0];\n\n// Или даже так\ncopied = Marshal.PtrToStructure&lt;Point&gt;(new IntPtr(pointer));\n</code></pre>\n\n<p>В общем, имея указатель, мы спокойно можем получить <strong>структуру</strong> в явном виде</p>\n\n<hr>\n\n<p>Теперь же отойдем от <em>типов значения</em> и перейдем к типам <em>ссылочным</em>, то есть поговорить я хочу о подобных механизмах для <strong>классов</strong></p>\n\n<p>Оперируя инстансами классов, мы на деле оперируем их ссылками, то есть, получив указатель, мы получим указатель на ссылку на определенный участок памяти, где как раз и можно найти данные объекта</p>\n\n<p>То есть следующий псевдо-код:</p>\n\n<pre><code>// Обозначим instance'ы классов\nMyClass my0 = new MyClass { A = 2 };\nMyClass my1 = new MyClass { A = 3 };\n\n// Некоторые действия\nIntPtr* ptr0 = ...;\nIntPtr* ptr1 = ...;\n\nIntPtr tmp = *ptr0;\n\nptr0[0] = ptr1[0];\nptr1[0] = tmp;\n\nConsole.WriteLine(my0.A); // 3\nConsole.WriteLine(my1.A); // 2\n</code></pre>\n\n<p>На деле аналогичен простой смене переменных местами</p>\n\n<hr>\n\n<p>И вот теперь главный вопрос: каким образом, имея указатель, я могу также, как и в случае со структурой, получить объект?</p>\n\n<p>Проблема в том, что </p>\n\n<ul>\n<li>Создание указателя на класс - невозможно (ошибка <a href=\"https://docs.microsoft.com/ru-ru/dotnet/csharp/misc/cs0208\" rel=\"nofollow noreferrer\">CS0208</a>)</li>\n<li>А <a href=\"https://msdn.microsoft.com/ru-ru/library/system.runtime.interopservices.marshal.ptrtostructure%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396\" rel=\"nofollow noreferrer\">Marshal.PtrToStructure</a> также рассчитан только на структуры</li>\n</ul>\n\n<p>То есть я ищу нечто такое:</p>\n\n<pre><code>IntPtr* pointer = ...;\n// Я знаю, что это не работает, это просто псевдо-код\nMyClass my = *((MyClass*)pointer);\nmy = Marshal.PtrToClass&lt;MyClass&gt;(new IntPtr(pointer));\n</code></pre>\n\n<hr>\n\n<p>Собственно, <strong>возможно ли</strong> такое в <code>C#</code> (не думаю, что прямо совсем никак) и, если да, то <strong>как</strong>?</p>\n\n<p>Приветствуются даже самые безумные идеи!</p>\n"}