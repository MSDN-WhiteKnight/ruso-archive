{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":1,"last_activity_date":1563795989,"creation_date":1563795989,"answer_id":1005505,"question_id":1005297,"body":"<blockquote>\n  <p>как получить указатель на первый байт тела </p>\n</blockquote>\n\n<p>При наличии полных отладочных символов (компоновка с <code>/DEBUG:FULL</code> для VS 2017+) как-то так:</p>\n\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;windows.h&gt;\n#include \"DbgHelp.h\"\n#pragma comment(lib, \"Dbghelp.lib\")\n\nstruct Function {\n    const char* name;\n    uintptr_t address;\n    bool success;\n};\n\nBOOL CALLBACK EnumSymProc(PSYMBOL_INFO pSymInfo, ULONG SymbolSize, PVOID context) {\n\n    Function* pfstruct = (Function*)context;\n\n    if (strcmp(pSymInfo-&gt;Name, pfstruct-&gt;name) == 0) {\n\n        pfstruct-&gt;address = pSymInfo-&gt;Address;      \n        pfstruct-&gt;success = true;\n        return FALSE; //закончить поиск\n\n    }\n    return TRUE; //продолжить поиск\n}\n\nbool GetFunctionAddress(const char* fname, uintptr_t&amp; resultvar) {\n\n    bool ret;\n    Function fstruct;\n    fstruct.name = fname;\n    fstruct.address = 0;\n    fstruct.success = false;\n\n    HANDLE hProcess = GetCurrentProcess(); //текущий процесс\n    char Mask[] = \"*!\"; //искать среди всех модулей\n    BOOL status;\n\n    status = SymInitialize(hProcess, NULL, TRUE); //загрузка символов\n    if (status == FALSE)\n    {\n        printf(\"SymInitialize failed. Error code: %d\\n\", GetLastError());\n        return false;\n    }\n\n    //поиск символов\n    if (SymEnumSymbols(hProcess, 0, Mask, &amp;EnumSymProc, (void*)&amp;fstruct))\n    {\n        if (fstruct.success != false) {\n\n            resultvar = fstruct.address; \n            ret = true;\n        }\n        else {\n            printf(\"Symbol [%s] not found\\n\", fname);\n            ret = false;\n        }\n    }\n    else\n    {\n        printf(\"SymEnumSymbols failed. Error code: %d\\n\", GetLastError());\n        ret = false;\n    }\n\n    SymCleanup(hProcess);\n    return ret;\n}\n\n//**********************************\n\nvoid Func() {\n    printf(\"Hello, World!\\n\");\n}\n\nint main(int argc, char **argv)\n{\n    uintptr_t p;\n    if (GetFunctionAddress(\"Func\", p) != false) {\n        //можно привести p к нужному типу и использовать...\n    }\n\n    return 0;\n}\n</code></pre>\n\n<blockquote>\n  <p>и почему я получаю указатель на jmp вместо него</p>\n</blockquote>\n\n<p>Трудно сказать. Скорее всего, вы делаете что-то не то. Обычно, когда необходимо работать с неким куском кода как с машинным кодом, целесообразно реализовать его полностью ассемблерной вставкой, как например <a href=\"https://ru.stackoverflow.com/a/751021/240512\">здесь</a>. Это гарантирует, что формат машинного кода будет наиболее близок к тому, что вы ожидаете.</p>\n"}