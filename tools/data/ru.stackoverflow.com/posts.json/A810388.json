{"owner":{"reputation":16068,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":5,"last_activity_date":1523008035,"last_edit_date":1523008035,"creation_date":1523005938,"answer_id":810388,"question_id":809884,"body":"<p>Как вариант, скомпилировать код, загрузить полученную сборку и через <em>Reflection</em> проверить типы полей и локальных переменных. Если считать, что код использует массивы, когда в нем есть хотя бы одно поле или локальная переменная с типом, унаследованным от <em>Array</em>, как-то так:</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.IO;\nusing System.Text;\nusing System.Reflection;\nusing System.CodeDom.Compiler;\nusing Microsoft.CSharp;\n\nnamespace ConsoleApplication1\n{    \n    class Program\n    {\n        //отображает информацию о использовании строк и массивов в сборке\n        public static string GetAssInfo(Assembly ass)\n        {\n            StringBuilder sb = new StringBuilder(500);\n            Type type;\n\n            List&lt;string&gt; arrays = new List&lt;string&gt;();\n            List&lt;string&gt; strings = new List&lt;string&gt;();\n\n            //анализируем типы сборки\n            foreach (TypeInfo t in ass.DefinedTypes)\n            {\n\n                foreach (var mem in t.DeclaredMembers)\n                {\n                    switch (mem.MemberType)\n                    {\n                        case MemberTypes.Field:\n                            type = (mem as FieldInfo).FieldType;\n                            if (type.BaseType == typeof(Array))\n                            {\n                                arrays.Add(t.ToString() + \", поле \" + type.ToString() + \" \" + mem.Name);\n                            }\n\n                            if (type == typeof(string))\n                            {\n                                strings.Add(t.ToString() + \", поле \" + type.ToString() + \" \" + mem.Name);\n                            }\n\n                            break;\n                        case MemberTypes.Method:\n\n                            MethodInfo mi = (mem as MethodInfo);\n                            var body = mi.GetMethodBody();\n                            foreach (var local in body.LocalVariables)\n                            {\n                                if (local.LocalType.BaseType == typeof(Array))\n                                {\n                                    arrays.Add(t.ToString() + \", метод \" + mi.Name + \", переменная \" + local.ToString());\n                                }\n\n                                if (local.LocalType == typeof(string))\n                                {\n                                    strings.Add(t.ToString() + \", метод \" + mi.Name + \", переменная \" + local.ToString());\n                                }\n                            }\n                            break;\n\n                    }\n\n                }\n\n            }\n\n            //выводим информацию\n            sb.AppendLine(\"Найдено использований массивов: \" + arrays.Count.ToString());    \n\n            foreach (var s in arrays)\n            {\n                sb.AppendLine(\"- \" + s);\n            }\n            sb.AppendLine();\n\n            sb.AppendLine(\"Найдено использований строк: \" + strings.Count.ToString());\n            foreach (var s in strings)\n            {\n                sb.AppendLine(\"- \" + s);\n            }\n\n            return sb.ToString();\n        }\n\n        public static void Main(string[] argv)\n        {\n            //путь к файлу с исходным кодом должен быть передан первым аргументом\n            if(argv.Length==0){Console.WriteLine(\"Укажите файл с исходым кодом\");return;}\n\n            var csc = new CSharpCodeProvider();\n            string source = File.ReadAllText(argv[0]);            \n            var parameters = new CompilerParameters(new[] { \"mscorlib.dll\", \"System.Core.dll\" }, \"foo.dll\", true);\n\n            //компилируем сборку из кода\n            CompilerResults results = csc.CompileAssemblyFromSource(parameters,source);\n            if (results.Errors.Count &gt; 0)\n            {\n               Console.WriteLine(\"Не удалось скомпилировать код\");\n                foreach (var err in results.Errors)\n                {\n                   Console.WriteLine(err.ToString());\n                }\n                return;\n            }\n\n            //выводим информацию\n            string s = GetAssInfo(results.CompiledAssembly);\n\n            Console.WriteLine(\"* Информация о сборке: *\");\n            Console.WriteLine();\n\n            Console.WriteLine(s);             \n\n        }       \n    }        \n}\n</code></pre>\n\n<p>Недостаток способа в том, что при этом сборка грузится в память процесса и от нее никак нельзя избавиться до завершения работы программы (кроме выгрузки всего домена приложений). Также, он является небезопасным, так как позволяет выполнить вредоносный код, если он будет во входном файле.</p>\n"}