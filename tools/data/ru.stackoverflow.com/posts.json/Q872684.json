{"tags":["c#","winforms","исключения","логирование"],"owner":{"reputation":11,"user_id":307194,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/576d52d08589340c7825637bb7cdfa5a?s=128&d=identicon&r=PG","display_name":"Владимир Кравченко","link":"https://ru.stackoverflow.com/users/307194/%d0%92%d0%bb%d0%b0%d0%b4%d0%b8%d0%bc%d0%b8%d1%80-%d0%9a%d1%80%d0%b0%d0%b2%d1%87%d0%b5%d0%bd%d0%ba%d0%be"},"is_answered":false,"view_count":80,"answer_count":2,"score":1,"last_activity_date":1535096331,"creation_date":1535046733,"last_edit_date":1535096331,"question_id":872684,"link":"https://ru.stackoverflow.com/questions/872684/unhandledexceptionhandler-%d0%bd%d0%b0-c-%d0%b2%d0%bd%d0%b5-visual-studio","title":"UnhandledExceptionHandler на C# вне Visual Studio","body":"<p>Есть проект. Начальство, спустя более 40к строк кода решило добавить логирование. Обычное, уровня Debug, уже добавил, теперь пришёл черед Exception-ов.</p>\n\n<p>Есть вариант прошить всё <code>try {} catch {log.write(message)}</code>, но, по-моему, это не самый оптимальный вариант.</p>\n\n<p>Попытался использовать <code>UnhandledExceptionHandler</code>, однако вне студии (да и банально в запуске без отладки) handler работать не хочет.</p>\n\n<p><strong>Вопрос</strong>: не сталкивался ли кто с подобным и что можете посоветовать в таком случае?\nТ.е. задача: перехватывать все (не только фатальные) исключения в релизе.</p>\n\n<p>Приложение WinForms .NET 2.0 (да, всё настолько плохо:)</p>\n\n<p>Добавлено:</p>\n\n<p>Вешаю <code>Handler</code> в <code>Main</code> перед <code>Application.Run(mainForm)</code>:</p>\n\n<pre><code>AppDomain.CurrentDomain.UnhandledException += UnhandledExceptionHandler;\nApplication.SetUnhandledExceptionMode(UnhandledExceptionMode.CatchException);\n</code></pre>\n\n<p>Код обработки</p>\n\n<pre><code>static void UnhandledExceptionHandler(object source, UnhandledExceptionEventArgs e)\n        {\n            logger.Error(\"Message: \" + ((Exception)e.ExceptionObject).Message);\n            var st = new StackTrace(((Exception)e.ExceptionObject), true);\n            for (int i = 0; i &lt; st.FrameCount; i++)\n            {\n                var frame = st.GetFrame(i);\n                var method = frame.GetMethod();\n                //if (method.DeclaringType.FullName.Contains(\"AMT\"))\n                {\n                    logger.Error(\"Source: \" + method.DeclaringType.FullName + \".\" + method.Name);\n                    logger.Error(\"Line: \" + frame.GetFileLineNumber());\n                }\n            }\n        }\n</code></pre>\n\n<p>Код просто не отрабатывает, как будто его и нет. В самой студии в режиме отладки всё нормально - и брекпоинт можно поставить, и лог пишется. Как только запускаю .exe напрямую - метода как-будто нет.</p>\n\n<p><strong>Обновление</strong></p>\n\n<p>Решение проблемы:</p>\n\n<p>В Main:</p>\n\n<pre><code>AppDomain.CurrentDomain.UnhandledException += UnhandledExceptionHandler;\nApplication.ThreadException += new ThreadExceptionEventHandler(ThreadExceptionHandler);\n</code></pre>\n\n<p>И три метода, два из которых перехватывают исключения и один вспомогательный для вывода инфы для юзера.</p>\n\n<pre><code>static void UnhandledExceptionHandler(object source, UnhandledExceptionEventArgs e)\n        {\n            logger.Error(\"Message: \" + ((Exception)e.ExceptionObject).Message);\n            var st = new StackTrace(((Exception)e.ExceptionObject), true);\n            for (int i = 0; i &lt; st.FrameCount; i++)\n            {\n                var frame = st.GetFrame(i);\n                var method = frame.GetMethod();\n                if (method.DeclaringType.FullName.Contains(\"AMT\"))\n                {\n                    logger.Error(\"Source: \" + method.DeclaringType.FullName + \".\" + method.Name);\n                    logger.Error(\"Line: \" + frame.GetFileLineNumber());\n                }\n            }\n        }\n\n        private static void ThreadExceptionHandler(object sender, ThreadExceptionEventArgs e)\n        {\n            logger.Error(\"Message: \" + e.Exception.Message);\n            var st = new StackTrace(e.Exception, true);\n            for (int i = 0; i &lt; st.FrameCount; i++)\n            {\n                var frame = st.GetFrame(i);\n                var method = frame.GetMethod();\n                if (method.DeclaringType.FullName.Contains(\"AMT\"))\n                {\n                    logger.Error(\"Source: \" + method.DeclaringType.FullName + \".\" + method.Name);\n                    logger.Error(\"Line: \" + frame.GetFileLineNumber());\n                }\n            }\n\n            DialogResult result = DialogResult.Cancel;\n            try\n            {\n                result = ShowThreadExceptionDialog(\"Windows Forms Error\", e.Exception);\n            }\n            catch\n            {\n                try\n                {\n                    MessageBox.Show(\"Fatal Windows Forms Error\", \"Fatal Windows Forms Error\", MessageBoxButtons.AbortRetryIgnore, MessageBoxIcon.Stop);\n                }\n                finally\n                {\n                    Application.Exit();\n                }\n            }\n            if (result == DialogResult.Abort)\n                Application.Exit();\n        }\n\n        private static DialogResult ShowThreadExceptionDialog(string title, Exception e)\n        {\n            string errorMsg = \"An application error occurred. Please contact the adminstrator \" +\n                \"with the following information:\\n\\n\";\n            errorMsg = errorMsg + e.Message + \"\\n\\nStack Trace:\\n\" + e.StackTrace;\n            return MessageBox.Show(errorMsg, title, MessageBoxButtons.AbortRetryIgnore, MessageBoxIcon.Stop);\n        }\n</code></pre>\n"}