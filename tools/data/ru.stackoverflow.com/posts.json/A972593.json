{"owner":{"reputation":17975,"user_id":184217,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/87aed06c947625b429242fbcdf11f5e0?s=128&d=identicon&r=PG&f=1","display_name":"Alexander Petrov","link":"https://ru.stackoverflow.com/users/184217/alexander-petrov"},"is_accepted":false,"score":1,"last_activity_date":1555934914,"last_edit_date":1555934914,"creation_date":1555934287,"answer_id":972593,"question_id":969870,"body":"<blockquote>\n  <p>есть список объектов, который я хочу сохранить в файл<br>\n  сколько памяти потребуется для текстового файла, сколько для бинарного и сколько для xml-файла</p>\n</blockquote>\n\n<p>Допустим, имеется следующий класс:</p>\n\n<pre><code>public class Equipment\n{\n    //public string Department { get; set; }\n    //public string Name { get; set; }\n    public int amount { get; set; }\n    public double unitCost { get; set; }\n    public double totalCost { get; set; }\n}\n</code></pre>\n\n<p>И записывается он в бинарный файл с помощью <a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter?view=netframework-4.8\" rel=\"nofollow noreferrer\">BinaryWriter</a>:</p>\n\n<pre><code>binaryWriter.Write(equipment.amount);\nbinaryWriter.Write(equipment.unitCost);\nbinaryWriter.Write(equipment.totalCost);\n</code></pre>\n\n<p>То есть данные идут вплотную, без дополнительной метаинформации.</p>\n\n<p>Размер примитивных типов можно получить оператором <a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sizeof\" rel=\"nofollow noreferrer\">sizeof</a>. Следовательно, размер одного экземпляра и всего списка вычисляется следующим образом:</p>\n\n<pre><code>int equipmentSize = sizeof(int) + sizeof(double) + sizeof(double);\nint listSize = equipmentSize * equipmentList.Count;\n</code></pre>\n\n<p>O(1) - эффективнее некуда.</p>\n\n<hr>\n\n<p>Однако, если раскомментировать строковые свойства, то ситуация усложнится.</p>\n\n<p>Длина строки в байтах зависит от используемой кодировки (<code>BinaryWriter</code> может использовать любую). Следовательно, нужно вычислять эту длину.</p>\n\n<pre><code>int nameSize = encoding.GetByteCount(equipment.Name);\nint departmentSize = encoding.GetByteCount(equipment.Department);\n</code></pre>\n\n<p>где <code>encoding</code> - та же кодировка, что используется при записи в файл.</p>\n\n<p>Естественно, длина строк у разных объектов в списке может быть разная, поэтому придётся сделать проход по всему списку и добавить сумму длин в <code>listSize</code>. Получаем O(n).</p>\n\n<p>Дело осложняется тем, что при записи строк в файл <code>BinaryWriter</code> предваряет значение записываемой строки её длиной. Это значение тоже нужно приплюсовать к итоговому размеру. Причём длина рассчитывается как 7-bit encoded. Подробнее <a href=\"https://stackoverflow.com/q/47409296/5045688\">здесь</a> и <a href=\"https://stackoverflow.com/q/44401928/5045688\">здесь</a>.</p>\n\n<hr>\n\n<p>Вычисление размера текстового файла зависит от используемой кодировки и от формата. Его сделать относительно несложно используя метод <code>Encoding.GetByteCount</code>.</p>\n\n<p>XML-файл по сути является текстовым. Аналогично, его размер можно рассчитать аналитически, без самой записи. Но возникает много проблем с предварительным определением его формата: с индентацией и без, с переносом атрибутов на новую строку или без переноса и многое другое.</p>\n\n<p>При желании, можно заморочиться ручным вычислением. Но это окупится лишь в том случае, если нужно рассчитывать размеры большого количества файлов/потоков большого размера. А главное, код в ответе MSDN.WhiteKnight именно это и делает.</p>\n"}