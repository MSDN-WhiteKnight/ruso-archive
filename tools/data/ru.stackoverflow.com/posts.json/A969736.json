{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":2,"last_activity_date":1555314650,"last_edit_date":1555314650,"creation_date":1555301975,"answer_id":969736,"question_id":969540,"body":"<p>Проблема в том, что</p>\n\n<pre><code>while (form.trigger_status == \"start\")\n{\n    Thread.Sleep(1000);\n}\n</code></pre>\n\n<p>блокирует цикл обработки сообщений, так что вызов form.textBox1.Invoke будет вечно ожидать выполнения делегата. Кроме того, проверка свойств в цикле (тем более, строковых) - по меньшей мере, не самый лучший способ синхронизации потоков. </p>\n\n<p>Как сделать это правильно? Логичным решением было бы вместо потоков использовать асинхронные задачи и await. Но можно применить и классический способ с EventWaitHandle и MsgWaitForMultipleObjectsEx:</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Windows.Forms;\nusing System.Runtime.InteropServices;\nusing System.Threading;\n\nnamespace WindowsFormsApp1\n{\n    public partial class Form1 : Form\n    {\n        [DllImport(\"user32.dll\")]\n        static extern int MsgWaitForMultipleObjectsEx(uint nCount, IntPtr[] pHandles,\n           uint dwMilliseconds, uint dwWakeMask, uint dwFlags);\n\n        const uint QS_ALLEVENTS = 1215;\n        const int WAIT_OBJECT_0 = 0;\n        const int WAIT_FAILED = -1;\n        const uint INFINITE = 0xFFFFFFFF;\n\n        //ожидает событие с обработкой сообщений\n        public static void WaitEvent(EventWaitHandle evt)\n        {    \n            var swh = evt.SafeWaitHandle;\n\n            using (swh)\n            {\n                IntPtr h = swh.DangerousGetHandle();\n\n                while (true)\n                {\n                    int res = MsgWaitForMultipleObjectsEx(1, new IntPtr[] { h }, INFINITE, QS_ALLEVENTS, 0);\n                    switch (res)\n                    {\n                        case WAIT_OBJECT_0:\n                            return;\n                        case WAIT_OBJECT_0 + 1:\n                            Application.DoEvents();\n                            break;\n                        default:\n                            throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());\n                    }\n                }\n            }\n        }\n\n        public Form1()\n        {\n            InitializeComponent();            \n        }\n\n        EventWaitHandle evt; //объект для синхронизации\n\n        void DoWork()\n        {\n            evt = new ManualResetEvent(false);\n\n            try\n            {\n                //выполняем операции...\n            }\n            finally\n            {\n                evt.Set(); //сигнализируем об окончании обработки\n            }\n        }        \n\n        private void button1_Click(object sender, EventArgs e)\n        {\n            Thread th;\n            th = new Thread(DoWork);\n            th.Start(); //запускаем обработку в фоновом потоке            \n        }     \n\n        private void Form1_FormClosing(object sender, FormClosingEventArgs e)\n        {\n            if (evt != null)\n            {\n                WaitEvent(evt); //ожидаем конца фоновой обработки\n            }\n        }\n    }  \n}\n</code></pre>\n"}