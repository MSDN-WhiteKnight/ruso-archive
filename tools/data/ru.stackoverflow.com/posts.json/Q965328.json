{"tags":["c#","dll","clr"],"owner":{"reputation":33,"user_id":317677,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/9077db9b70e4326897cde4153240d927?s=128&d=identicon&r=PG&f=1","display_name":"Egorosh","link":"https://ru.stackoverflow.com/users/317677/egorosh"},"is_answered":true,"view_count":174,"accepted_answer_id":966828,"answer_count":1,"score":2,"last_activity_date":1554703556,"creation_date":1554361790,"question_id":965328,"link":"https://ru.stackoverflow.com/questions/965328/%d0%9a%d0%b0%d0%ba-%d0%b2%d1%8b%d0%b3%d1%80%d1%83%d0%b7%d0%b8%d1%82%d1%8c-c-%d0%b1%d0%b8%d0%b1%d0%bb%d0%b8%d0%be%d1%82%d0%b5%d0%ba%d1%83-%d0%b8%d0%b7-clr-%d0%bd%d0%b5-%d0%b7%d0%b0%d0%b2%d0%b5%d1%80%d1%88%d0%b0%d1%8f-%d0%bf%d1%80%d0%be%d1%86%d0%b5%d1%81%d1%81%d0%b0","title":"Как выгрузить c# библиотеку из CLR, не завершая процесса","body":"<p>Подскажите, пожалуйста, каким образом можно выгрузить с# библиотеку из нативного кода или как-то изнутри самой библиотеки.</p>\n\n<p>Дело в том, что есть нативное оконное приложение на delphi. Для него мной был написан плагин на с# с вызовом функции, внутри которой стартует отдельный поток с wpf приложением и запуском окна, но внутри основного процесса. </p>\n\n<p>В приложении на delphi dll подключается с помощью WinAPI (LoadLibrary, GetProcAddress и FreeLibrary). Так вот, при освобождении с помощью FreeLibrary плагин на самом деле не освобождается, а продолжает висеть в CLR вплоть до завершения процесса. </p>\n\n<p>В англоязычном сегменте, нашёл ответ, что нужно выгружать AppDomain, но без примеров. Как в моём случае решить данную проблему, откуда выгружать AppDomain, каким образом?</p>\n\n<p>Экспортируемая функция внутри C# либы выглядит следующим образом:</p>\n\n<pre class=\"lang-cs prettyprint-override\"><code> public static int showCyclegramm(IntPtr allWindowsClosedCallback)\n        {\n            if (_wpfLoaded)\n                App.ShowWindow();\n            else\n            {\n                _thread = new Thread(App.StartWpf);\n                _thread.SetApartmentState(ApartmentState.STA);\n                _thread.Start(allWindowsClosedCallback);\n                _wpfLoaded = true;\n            }\n\n            return 0;\n        }\n</code></pre>\n\n<p>StartWpf это по сути тот же main из обычного WPF приложения:</p>\n\n<pre class=\"lang-cs prettyprint-override\"><code>public static void StartWpf(object allWindowsClosedCallback)\n        {\n            var cPointer = (IntPtr) allWindowsClosedCallback;\n            if (cPointer != IntPtr.Zero)\n                _allClosedWindowsAction =\n                    Marshal.GetDelegateForFunctionPointer&lt;Action&gt;((IntPtr) allWindowsClosedCallback);\n\n            try\n            {\n                _app = new App();\n            }\n            catch (InvalidOperationException e)\n            {\n                MessageBox.Show(\"Последнее окно было закрыто. Перезагрузите библиотеку\");\n                return;\n            }\n\n            _app.InitializeComponent();\n            _app.Run();\n        }\n</code></pre>\n"}