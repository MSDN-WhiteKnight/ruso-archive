{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":0,"last_activity_date":1520921645,"creation_date":1520921645,"answer_id":797408,"question_id":796861,"body":"<p>Мне не удалось воспроизвести зависание программы при наличии незакрытого <code>OleDbConnection</code>. Впрочем, это не удивительно, похоже, речь идет о неопределенном поведении.</p>\n\n<blockquote>\n  <p>Так вот, под конец работы приложения программа зависает, если не вызвать Dispose, хотя... в этом случае должен отработать финализатор.</p>\n</blockquote>\n\n<p>Все немного сложнее. Класс <code>OleDbConnection</code> внутренне использует несколько COM-объектов: объект <em>Data Links</em>, который отвечает за управление пулом соединений - один на домен приложений, и объекты <em>Data Source</em> и <em>Session</em> - по одному на каждое соединение. См. <a href=\"https://referencesource.microsoft.com/#System.Data/System/Data/OleDb/OleDbWrapper.cs,9b3ba9571a56b8f6\" rel=\"nofollow noreferrer\">здесь</a>. При ручном закрытии соединения обеспечивается корректный порядок действий:</p>\n\n<ul>\n<li><p>Сброс данных из внутренних буферов в физическое хранилище</p></li>\n<li><p>Возврат соединения в пул, или закрытие физического соединения, если пул отключен</p></li>\n<li><p>По завершении приложения (при выгрузке домена), освобождаются объекты, связанные с физическими соединениями и последним - глобальный объект пула.</p></li>\n</ul>\n\n<p>Если соединение явно не закрывается, при завершении приложения все объекты кучей попадают в очередь финализации, и выполняется попытка их освободить в специальном потоке. При этом, как сказано в <a href=\"https://msdn.microsoft.com/en-us/library/system.object.finalize%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396\" rel=\"nofollow noreferrer\">документации</a>, порядок вызова финализаторов не определен. Это нарушает логику работы с БД: если финализатор для глобального объекта пула попадет в очередь до объекта соединения, он будет ждать освобождения соединения и не дождется никогда, возникает взаимоблокировка. Видимо, у вас что-то подобное и происходит. </p>\n\n<p>При работе с соединениями с БД, конечно, не стоит полагаться на финализаторы и нужно явно закрывать соединение, когда оно больше не нужно (в вашем случае, класс Converter должен тоже реализовывать <code>IDisposable</code>, и в конце программы для него вызывать <code>Dispose</code>). Это обеспечивает  корректный порядок действий при освобождении ресурсов, завершение выполняющихся в данный момент транзакций и сброс закэшированных данных в место назначения. </p>\n\n<p>Закрытие соединение с БД через финализатор никогда не было поддерживаемым режимом, в документации везде это четко написано. Класс <code>SqlConnection</code>, к примеру, вообще вызывает в конструкторе <code>SuppressFinalize</code>, так что его финализатор никогда не будет вызван. </p>\n"}