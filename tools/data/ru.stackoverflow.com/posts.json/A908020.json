{"owner":{"reputation":16137,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":3,"last_activity_date":1542527122,"creation_date":1542527122,"answer_id":908020,"question_id":907230,"body":"<blockquote>\n  <p>В С++- это обрабатываемое исключение, если верить комментариям из предыдущего вопроса</p>\n</blockquote>\n\n<p>На самом деле все немного не так. Стандартными средствами С++, разумеется, нельзя обработать переполнение стека. Однако, в Windows его можно обработать с помощью механизма SEH. И, что бы ни говорил Эрик Липперт, восстановление после переполнения стека - вполне поддерживаемый сценарий,  иначе зачем бы существовали функции <a href=\"https://msdn.microsoft.com/ru-ru/library/89f73td2.aspx?f=255&amp;MSPPError=-2147217396\" rel=\"nofollow noreferrer\">_resetstkoflw</a> и <a href=\"https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setthreadstackguarantee\" rel=\"nofollow noreferrer\">SetThreadStackGuarantee</a>?</p>\n\n<blockquote>\n  <p>а в .NET нет, так как возможно, как я понимаю, что СLR, которой нужно что-то сделать, может повредится из-за не хватки стека</p>\n</blockquote>\n\n<p>В .NET StackOverflowException не обрабатывается не потому, что это технически невозможно, а потому, что так решили разработчики. В Windows переполнение стека порождает исключение SEH с кодом STATUS_STACK_OVERFLOW (0xC00000FD). CLR перехватывает SEH-исключения и, если видит этот код, принудительно убивает процесс (будучи загруженной с параметрами по умолчанию). При этом куда более опасное Access Violation .NET почему-то разрешает обрабатывать.</p>\n\n<blockquote>\n  <p>Получается, что запуская чужой код, к исходникам которого мы не имеем доступа, хоть в отдельном потоке, хоть в отдельном домене, то мы все равно падаем и в .NET никак нельзя предотвратить это при таком типе исключения?</p>\n</blockquote>\n\n<p>Только средствами .NET нельзя. Однако в неуправляемом коде нужно написать, по сути, очень немного.</p>\n\n<p>Один из способов обойти это поведение, это создать специальную неуправляемую DLL, единственной целью которой будет обработать SEH-исключение и поменять его код на тот, который CLR \"не напугает\" (SEH-исключения с неизвестным кодом CLR преобразует в SEHException, которое можно обработать). В приложении на C# загрузить DLL, установить векторный обработчик исключений и увеличить размер зарезервированной области стека с помощью функции SetThreadStackGuarantee.</p>\n\n<p>Конечно, это не обеспечит полное восстановление стека, т.е., чтобы можно было далее в том же потоке снова словить переполнение стека и обработать его. Но если просто позволить потоку завершиться и забыть про него, это не имеет значения:  вновь созданные потоки уже будут иметь корректный стек.</p>\n\n<p>Например, создадим DLL на С++ с таким кодом:</p>\n\n<pre><code>#include &lt;malloc.h&gt;\n#include &lt;windows.h&gt;\n\n#ifdef __cplusplus\nextern \"C\"{\n#endif\n\n__declspec(dllexport) LONG WINAPI fnCrashHandler(LPEXCEPTION_POINTERS pExceptionInfo)\n{   \n\n    if(pExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == STATUS_STACK_OVERFLOW){\n        pExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode = 0x1234;\n    }\n\n    return EXCEPTION_CONTINUE_SEARCH;\n}\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>\n\n<p>Назовем ее, допустим, CrashHandler.dll, и поместим в каталог с программой. Тогда в C# можно обработать переполнение стека таким образом:</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Threading;\nusing System.Runtime.InteropServices;\n\nnamespace ConsoleTest\n{\n     class Program\n    {                \n\n        [DllImport(\"kernel32.dll\")]        \n        public static extern IntPtr AddVectoredExceptionHandler(\n            uint FirstHandler,\n            IntPtr VectoredHandler\n        );                       \n\n        [DllImport(\"kernel32.dll\")]\n        public static extern int SetThreadStackGuarantee(  ref uint StackSizeInBytes);         \n\n        [DllImport(\"kernel32.dll\")]\n        public static extern IntPtr LoadLibrary([MarshalAs(UnmanagedType.LPStr)]string lpFileName);\n\n        [DllImport(\"kernel32.dll\", CharSet = CharSet.Ansi, ExactSpelling = true)]\n        public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);\n\n        static void Recursive()\n        {\n            Recursive();\n        }\n\n        static void Test()\n        {            \n\n            //увеличим размер зарезервированной области стека (30 KB должно быть достаточно)\n            uint size = 30000; \n            SetThreadStackGuarantee(ref size);   \n\n            try\n            {\n                Recursive();\n            }\n            catch (SEHException)\n            {\n                Console.WriteLine(\"SEHException. Code: 0x\" + Marshal.GetExceptionCode().ToString(\"X\"));                \n            }\n\n        }        \n\n        static void Main(string[] args)\n        {\n            //добавим обработчик исключений\n            IntPtr h = LoadLibrary(\"CrashHandler.dll\");\n            IntPtr fnAddress = GetProcAddress(h, \"_fnCrashHandler@4\"); //декорированное имя функции по правилам stdcall           \n            AddVectoredExceptionHandler(1, fnAddress);\n\n            //запустим поток\n            Thread thread = new Thread(Test);\n            thread.Start();\n            thread.Join();            \n\n            Console.WriteLine(\"Press any key...\");\n            Console.ReadKey();\n        }\n\n    }\n}\n</code></pre>\n\n<p><strong>Примечание.</strong> Целевая архитектура неуправляемой DLL и приложения должны совпадать. Для AnyCPU-приложений понадобится иметь несколько неуправляемых DLL под каждую архитектуру и загружать нужную в зависимости от текущей архитектуры приложения.</p>\n"}