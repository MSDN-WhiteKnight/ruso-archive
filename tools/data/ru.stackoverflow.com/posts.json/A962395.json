{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1553750528,"creation_date":1553750528,"answer_id":962395,"question_id":962254,"body":"<p>С данным кодом есть несколько проблем:</p>\n\n<ul>\n<li><p>Если вас интересуют компьютеры, а не общие каталоги, вам и не надо раскрывать контейнеры, достаточно перечислить элементы на основном уровне вложенности. </p></li>\n<li><p>Для компьютеров в качестве имени нужно брать не lpLocalName, а lpRemoteName; локальное имя для них все равно будет NULL. </p></li>\n<li><p>Закрывать дескриптор надо WNetCloseEnum, а не CloseHandle</p></li>\n</ul>\n\n<p>Ну, а чтобы получить IP-адреса, необходимо добавить разрешение имен. Если исправить ошибки в вашем коде и добавить его, получится такой код:</p>\n\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;iostream&gt;\n#include &lt;WS2tcpip.h&gt;\n#include &lt;Windows.h&gt;\n\n#pragma comment( lib, \"Mpr.lib\" )\n#pragma comment( lib, \"Ws2_32.lib\")\n\nstd::wstring ResolveAddr(WCHAR* addr) {\n\n    ADDRINFOW *result = NULL;   \n    ADDRINFOW hints;\n    LPSOCKADDR sockaddr_ip;\n    wchar_t ipstringbuffer[46];\n    DWORD ipbufferlength;\n    DWORD res;  \n    int iRetval;\n\n    ZeroMemory(&amp;hints, sizeof(hints));\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;       \n\n    res = GetAddrInfoW(addr, nullptr, &amp;hints, &amp;result);\n    if (res != 0) {\n        wprintf(L\"GetAddrInfoW failed with error: %d\\n\", res);\n        return std::wstring(L\"\");\n    }\n\n    if (result-&gt;ai_family != AF_INET) {\n        wprintf(L\"Error: Unsupported address\\n\", res);\n        return std::wstring(L\"\");\n    }\n\n    sockaddr_ip = result-&gt;ai_addr;\n    ipbufferlength = 46;\n    iRetval = WSAAddressToString(sockaddr_ip, (DWORD)result-&gt;ai_addrlen, NULL,\n        ipstringbuffer, &amp;ipbufferlength);\n\n    if (iRetval) {\n        wprintf(L\"WSAAddressToString failed with %u\\n\", WSAGetLastError());\n        return std::wstring(L\"\");\n    }\n\n    return std::wstring(ipstringbuffer);    \n}\n\nBOOL WINAPI EnumResources(LPNETRESOURCE lpNR = nullptr) {\n\n    HANDLE hNetEnum;\n    DWORD dwResultOpen = WNetOpenEnumW(RESOURCE_CONTEXT,\n        NULL,\n        0,\n        lpNR,\n        &amp;hNetEnum);\n\n    if (dwResultOpen != NO_ERROR)\n        return FALSE;\n\n    constexpr DWORD numOfResources = 2048;\n    DWORD count = -1;\n    DWORD cbBuffer = numOfResources * sizeof(NETRESOURCE);\n    DWORD dwResultEnum = 0;\n    LPNETRESOURCE lpNRlocal = new NETRESOURCE[numOfResources]; \n    WCHAR* pwc;\n\n    do {\n        dwResultEnum = WNetEnumResourceW(hNetEnum, &amp;count, lpNRlocal, &amp;cbBuffer);\n\n        if (dwResultEnum == NO_ERROR) {\n            for (int i = 0; i &lt; count; ++i) {\n\n                if (lpNRlocal[i].lpRemoteName == nullptr) continue;\n\n                std::wcout &lt;&lt; lpNRlocal[i].lpRemoteName &lt;&lt; L\": \";\n                pwc = lpNRlocal[i].lpRemoteName;\n                if (wcslen(pwc) &gt; 2) {\n                    if(pwc[0]=='\\\\' &amp;&amp; pwc[1]=='\\\\') pwc = lpNRlocal[i].lpRemoteName + 2;\n                }               \n\n                std::wcout &lt;&lt; ResolveAddr(pwc).c_str() &lt;&lt; std::endl;        \n            }           \n        }       \n        else if (dwResultEnum != ERROR_NO_MORE_ITEMS) {\n            std::wcout &lt;&lt; L\"WNetEnumResourceW error: \"&lt;&lt; dwResultEnum &lt;&lt; std::endl;\n        }\n\n    } while (dwResultEnum != ERROR_NO_MORE_ITEMS);\n\n    delete[] lpNRlocal;\n    WNetCloseEnum(hNetEnum);\n\n    return TRUE;\n}\n\nint main()\n{\n    WSADATA wsaData;\n    int iResult;\n\n    iResult = WSAStartup(MAKEWORD(2, 2), &amp;wsaData);\n    if (iResult != 0) {\n        wprintf(L\"WSAStartup failed: %d\\n\", iResult);\n        return 1;\n    }   \n\n    EnumResources();\n\n    getchar();\n}\n</code></pre>\n\n<p>Так как данный код завязан на сетевое обнаружение (которое использует в том числе широковещательные запросы протоколов NetBIOS/WS-Discovery/UPnP/SSDP в зависимости от версии и конфигурации Windows), насколько быстро он будет работать, и будет ли работать вообще, зависит от многих факторов. Если вы хотите более надежный способ получения списка компьютеров для доменных сетей, смотрите в сторону <a href=\"https://docs.microsoft.com/en-us/windows/desktop/ADSI/active-directory-service-interfaces-adsi\" rel=\"nofollow noreferrer\">ADSI</a>.</p>\n"}