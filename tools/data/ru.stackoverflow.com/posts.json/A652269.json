{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":3,"last_activity_date":1491908755,"last_edit_date":1491908755,"creation_date":1491905450,"answer_id":652269,"question_id":649179,"body":"<p>Обрабатывать WM_NCPAINT (и еще несколько сообщений) и рисовать эту рамку самостоятельно. Вот простейший пример, основанный на OpenSource-проекте <a href=\"https://customerborderform.codeplex.com\" rel=\"nofollow noreferrer\">customerborderform.codeplex.com</a>. Он не совершенный, так как нет двойной буферизации и при изменении размера окно мерцает, но думаю как основа будет полезен. </p>\n\n<p><strong>Вспомогательные классы</strong></p>\n\n<p>NativeMethods</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Runtime.InteropServices;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nnamespace WindowsFormsTest\n{\n    public class NativeMethods\n    {\n\n\n        #region WindowMessages\n        public enum WindowMessages\n        {\n            WM_NULL = 0x0000,\n            WM_CREATE = 0x0001,\n            WM_DESTROY = 0x0002,\n            WM_MOVE = 0x0003,\n            WM_SIZE = 0x0005,\n            WM_ACTIVATE = 0x0006,\n            WM_SETFOCUS = 0x0007,\n            WM_KILLFOCUS = 0x0008,\n            WM_ENABLE = 0x000A,\n            WM_SETREDRAW = 0x000B,\n            WM_SETTEXT = 0x000C,\n            WM_GETTEXT = 0x000D,\n            WM_GETTEXTLENGTH = 0x000E,\n            WM_PAINT = 0x000F,\n            WM_CLOSE = 0x0010,\n\n            WM_QUIT = 0x0012,\n            WM_ERASEBKGND = 0x0014,\n            WM_SYSCOLORCHANGE = 0x0015,\n            WM_SHOWWINDOW = 0x0018,\n\n            WM_ACTIVATEAPP = 0x001C,\n\n            WM_SETCURSOR = 0x0020,\n            WM_MOUSEACTIVATE = 0x0021,\n            WM_GETMINMAXINFO = 0x24,\n            WM_WINDOWPOSCHANGING = 0x0046,\n            WM_WINDOWPOSCHANGED = 0x0047,\n\n            WM_CONTEXTMENU = 0x007B,\n            WM_STYLECHANGING = 0x007C,\n            WM_STYLECHANGED = 0x007D,\n            WM_DISPLAYCHANGE = 0x007E,\n            WM_GETICON = 0x007F,\n            WM_SETICON = 0x0080,\n\n            // non client area\n            WM_NCCREATE = 0x0081,\n            WM_NCDESTROY = 0x0082,\n            WM_NCCALCSIZE = 0x0083,\n            WM_NCHITTEST = 0x84,\n            WM_NCPAINT = 0x0085,\n            WM_NCACTIVATE = 0x0086,\n\n            WM_GETDLGCODE = 0x0087,\n\n            WM_SYNCPAINT = 0x0088,\n\n            // non client mouse\n            WM_NCMOUSEMOVE = 0x00A0,\n            WM_NCLBUTTONDOWN = 0x00A1,\n            WM_NCLBUTTONUP = 0x00A2,\n            WM_NCLBUTTONDBLCLK = 0x00A3,\n            WM_NCRBUTTONDOWN = 0x00A4,\n            WM_NCRBUTTONUP = 0x00A5,\n            WM_NCRBUTTONDBLCLK = 0x00A6,\n            WM_NCMBUTTONDOWN = 0x00A7,\n            WM_NCMBUTTONUP = 0x00A8,\n            WM_NCMBUTTONDBLCLK = 0x00A9,\n\n            // keyboard\n            WM_KEYDOWN = 0x0100,\n            WM_KEYUP = 0x0101,\n            WM_CHAR = 0x0102,\n\n            WM_SYSCOMMAND = 0x0112,\n\n            // menu\n            WM_INITMENU = 0x0116,\n            WM_INITMENUPOPUP = 0x0117,\n            WM_MENUSELECT = 0x011F,\n            WM_MENUCHAR = 0x0120,\n            WM_ENTERIDLE = 0x0121,\n            WM_MENURBUTTONUP = 0x0122,\n            WM_MENUDRAG = 0x0123,\n            WM_MENUGETOBJECT = 0x0124,\n            WM_UNINITMENUPOPUP = 0x0125,\n            WM_MENUCOMMAND = 0x0126,\n\n            WM_CHANGEUISTATE = 0x0127,\n            WM_UPDATEUISTATE = 0x0128,\n            WM_QUERYUISTATE = 0x0129,\n\n            // mouse\n            WM_MOUSEFIRST = 0x0200,\n            WM_MOUSEMOVE = 0x0200,\n            WM_LBUTTONDOWN = 0x0201,\n            WM_LBUTTONUP = 0x0202,\n            WM_LBUTTONDBLCLK = 0x0203,\n            WM_RBUTTONDOWN = 0x0204,\n            WM_RBUTTONUP = 0x0205,\n            WM_RBUTTONDBLCLK = 0x0206,\n            WM_MBUTTONDOWN = 0x0207,\n            WM_MBUTTONUP = 0x0208,\n            WM_MBUTTONDBLCLK = 0x0209,\n            WM_MOUSEWHEEL = 0x020A,\n            WM_MOUSELAST = 0x020D,\n\n            WM_PARENTNOTIFY = 0x0210,\n            WM_ENTERMENULOOP = 0x0211,\n            WM_EXITMENULOOP = 0x0212,\n\n            WM_NEXTMENU = 0x0213,\n            WM_SIZING = 0x0214,\n            WM_CAPTURECHANGED = 0x0215,\n            WM_MOVING = 0x0216,\n\n            WM_ENTERSIZEMOVE = 0x0231,\n            WM_EXITSIZEMOVE = 0x0232,\n\n            WM_MOUSELEAVE = 0x02A3,\n            WM_MOUSEHOVER = 0x02A1,\n            WM_NCMOUSEHOVER = 0x02A0,\n            WM_NCMOUSELEAVE = 0x02A2,\n\n            WM_MDIACTIVATE = 0x0222,\n            WM_HSCROLL = 0x0114,\n            WM_VSCROLL = 0x0115,\n\n            WM_PRINT = 0x0317,\n            WM_PRINTCLIENT = 0x0318,\n        }\n        #endregion //WindowMessages\n\n\n\n        #region DCX enum\n        [Flags()]\n        internal enum DCX\n        {\n            DCX_CACHE = 0x2,\n            DCX_CLIPCHILDREN = 0x8,\n            DCX_CLIPSIBLINGS = 0x10,\n            DCX_EXCLUDERGN = 0x40,\n            DCX_EXCLUDEUPDATE = 0x100,\n            DCX_INTERSECTRGN = 0x80,\n            DCX_INTERSECTUPDATE = 0x200,\n            DCX_LOCKWINDOWUPDATE = 0x400,\n            DCX_NORECOMPUTE = 0x100000,\n            DCX_NORESETATTRS = 0x4,\n            DCX_PARENTCLIP = 0x20,\n            DCX_VALIDATE = 0x200000,\n            DCX_WINDOW = 0x1,\n        }\n        #endregion //DCX\n\n\n\n\n\n\n\n        #region RECT structure\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct RECT\n        {\n            public int left;\n            public int top;\n            public int right;\n            public int bottom;\n\n            public RECT(int left, int top, int right, int bottom)\n            {\n                this.left = left;\n                this.top = top;\n                this.right = right;\n                this.bottom = bottom;\n            }\n\n            public Rectangle Rect { get { return new Rectangle(this.left, this.top, this.right - this.left, this.bottom - this.top); } }\n\n            public static RECT FromXYWH(int x, int y, int width, int height)\n            {\n                return new RECT(x,\n                                y,\n                                x + width,\n                                y + height);\n            }\n\n            public static RECT FromRectangle(Rectangle rect)\n            {\n                return new RECT(rect.Left,\n                                 rect.Top,\n                                 rect.Right,\n                                 rect.Bottom);\n            }\n        }\n\n        #endregion RECT structure\n\n\n\n\n\n        #region TRACKMOUSEEVENT structure\n\n        [StructLayout(LayoutKind.Sequential)]\n        public class TRACKMOUSEEVENT\n        {\n            public TRACKMOUSEEVENT()\n            {\n                this.cbSize = Marshal.SizeOf(typeof(NativeMethods.TRACKMOUSEEVENT));\n                this.dwHoverTime = 100;\n            }\n\n            public int cbSize;\n            public int dwFlags;\n            public IntPtr hwndTrack;\n            public int dwHoverTime;\n        }\n\n        #endregion\n\n\n\n        #region TernaryRasterOperations enum\n\n        public enum TernaryRasterOperations\n        {\n            SRCCOPY = 0x00CC0020, /* dest = source*/\n            SRCPAINT = 0x00EE0086, /* dest = source OR dest*/\n            SRCAND = 0x008800C6, /* dest = source AND dest*/\n            SRCINVERT = 0x00660046, /* dest = source XOR dest*/\n            SRCERASE = 0x00440328, /* dest = source AND (NOT dest )*/\n            NOTSRCCOPY = 0x00330008, /* dest = (NOT source)*/\n            NOTSRCERASE = 0x001100A6, /* dest = (NOT src) AND (NOT dest) */\n            MERGECOPY = 0x00C000CA, /* dest = (source AND pattern)*/\n            MERGEPAINT = 0x00BB0226, /* dest = (NOT source) OR dest*/\n            PATCOPY = 0x00F00021, /* dest = pattern*/\n            PATPAINT = 0x00FB0A09, /* dest = DPSnoo*/\n            PATINVERT = 0x005A0049, /* dest = pattern XOR dest*/\n            DSTINVERT = 0x00550009, /* dest = (NOT dest)*/\n            BLACKNESS = 0x00000042, /* dest = BLACK*/\n            WHITENESS = 0x00FF0062, /* dest = WHITE*/\n        };\n\n        #endregion\n\n        #region Constants\n\n        public static readonly IntPtr TRUE = new IntPtr(1);\n        public static readonly IntPtr FALSE = new IntPtr(0);\n\n        public static readonly IntPtr HWND_TOPMOST = new IntPtr(-1);\n\n        #endregion\n\n        #region API methods\n\n\n\n        [DllImport(\"user32.dll\")]\n        public static extern IntPtr GetDCEx(IntPtr hwnd, IntPtr hrgnclip, uint fdwOptions);\n\n        [DllImport(\"user32.dll\")]\n        public static extern int ReleaseDC(IntPtr hwnd, IntPtr hDC);\n\n        [DllImport(\"user32.dll\")]\n        public static extern int GetWindowRect(IntPtr hwnd, ref RECT lpRect);\n\n\n\n        public const int VK_LBUTTON = 0x01;\n        public const int VK_RBUTTON = 0x02;\n\n\n\n\n\n        public static int GetLastError()\n        {\n            return System.Runtime.InteropServices.Marshal.GetLastWin32Error();\n        }\n\n\n\n        [DllImport(\"gdi32.dll\")]\n        public static extern bool DeleteDC(IntPtr hDC);\n\n        #endregion\n\n\n    }\n}\n</code></pre>\n\n<p>SystemMetric</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace WindowsFormsTest\n{\n    public enum SystemMetric : int\n    {\n\n\n        /// &lt;summary&gt;\n        /// The width of a window border, in pixels. This is equivalent to the SM_CXEDGE value for windows with the 3-D look.\n        /// &lt;/summary&gt;\n        SM_CXBORDER = 5,\n\n        /// &lt;summary&gt;\n        /// The width of a cursor, in pixels. The system cannot create cursors of other sizes.\n        /// &lt;/summary&gt;\n        SM_CXCURSOR = 13,\n\n        /// &lt;summary&gt;\n        /// This value is the same as SM_CXFIXEDFRAME.\n        /// &lt;/summary&gt;\n        SM_CXDLGFRAME = 7,\n\n\n\n        /// &lt;summary&gt;\n        /// This value is the same as SM_CXSIZEFRAME.\n        /// &lt;/summary&gt;\n        SM_CXFRAME = 32,\n\n\n        /// &lt;summary&gt;\n        /// The width of a button in a window caption or title bar, in pixels.\n        /// &lt;/summary&gt;\n        SM_CXSIZE = 30,\n\n        /// &lt;summary&gt;\n        /// The thickness of the sizing border around the perimeter of a window that can be resized, in pixels. \n        /// SM_CXSIZEFRAME is the width of the horizontal border, and SM_CYSIZEFRAME is the height of the vertical border. \n        /// This value is the same as SM_CXFRAME.\n        /// &lt;/summary&gt;\n        SM_CXSIZEFRAME = 32,\n\n\n        /// &lt;summary&gt;\n        /// The height of a window border, in pixels. This is equivalent to the SM_CYEDGE value for windows with the 3-D look.\n        /// &lt;/summary&gt;\n        SM_CYBORDER = 6,\n\n        /// &lt;summary&gt;\n        /// The height of a caption area, in pixels.\n        /// &lt;/summary&gt;\n        SM_CYCAPTION = 4,\n\n\n\n\n\n        /// &lt;summary&gt;\n        /// This value is the same as SM_CYSIZEFRAME.\n        /// &lt;/summary&gt;\n        SM_CYFRAME = 33,\n\n\n        /// &lt;summary&gt;\n        /// The height of a button in a window caption or title bar, in pixels.\n        /// &lt;/summary&gt;\n        SM_CYSIZE = 31,\n\n        /// &lt;summary&gt;\n        /// The thickness of the sizing border around the perimeter of a window that can be resized, in pixels. \n        /// SM_CXSIZEFRAME is the width of the horizontal border, and SM_CYSIZEFRAME is the height of the vertical border. \n        /// This value is the same as SM_CYFRAME.\n        /// &lt;/summary&gt;\n        SM_CYSIZEFRAME = 33,\n\n        /// &lt;summary&gt;\n        /// The height of a small caption, in pixels.\n        /// &lt;/summary&gt;\n        SM_CYSMCAPTION = 51,\n\n        /// &lt;summary&gt;\n        /// The recommended height of a small icon, in pixels. Small icons typically appear in window captions and in small icon view.\n        /// &lt;/summary&gt;\n        SM_CYSMICON = 50,\n\n        /// &lt;summary&gt;\n        /// The height of small caption buttons, in pixels.\n        /// &lt;/summary&gt;\n        SM_CYSMSIZE = 53,\n\n\n\n    }\n}\n</code></pre>\n\n<p><strong>Собственно форма</strong></p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;\nusing System.Runtime.InteropServices;\n/*https://customerborderform.codeplex.com*/\n\nnamespace WindowsFormsTest\n{\n    public partial class Form1 : Form\n    {\n        /*Параметры отображения окна*/\n        Color TextColor = Color.Black;//цвет текста\n        Color FrameColor = Color.Red;//цвет рамки\n        bool EnableNonClientAreaPaint = true;//использовать нестандартную рамку\n\n        [DllImport(\"user32.dll\")]\n        static extern int GetSystemMetrics(SystemMetric smIndex);\n\n        public Form1()\n        {\n            InitializeComponent();\n        }        \n\n        /// &lt;summary&gt;\n        /// Custom client area paint\n        /// &lt;/summary&gt;        \n        protected void OnNonClientAreaPaint(NonClientPaintEventArgs e)\n        {\n            /*Размеры рамки*/\n            int w = GetSystemMetrics(SystemMetric.SM_CXSIZEFRAME);\n            int h = GetSystemMetrics(SystemMetric.SM_CYSIZEFRAME);\n\n            /*Размеры кнопки*/\n            int w2 = (GetSystemMetrics(SystemMetric.SM_CXSIZE));\n            int h2 = GetSystemMetrics(SystemMetric.SM_CYSIZE);\n\n            Rectangle rc;\n            StringFormat fmt=StringFormat.GenericDefault;            \n            fmt.Alignment = StringAlignment.Center;\n            fmt.LineAlignment = StringAlignment.Center;\n\n            Brush br=new SolidBrush(TextColor);//brush for text\n            Brush fbr = new SolidBrush(FrameColor);//brush for frame\n            Font font = new Font(\"Arial\", 14);\n            Pen p = new Pen(FrameColor, (float)w);\n\n            using(br)\n            using(fbr)\n            using(font)\n            using (p)\n            {\n                /*border*/\n                e.Graphics.DrawRectangle(p, w / 2.0f, h / 2.0f, e.Bounds.Width - w, e.Bounds.Height - h );\n\n                /*title area*/\n                rc = new Rectangle(w, h, e.Bounds.Width, h2);\n                e.Graphics.FillRectangle(fbr, rc);\n                e.Graphics.DrawString(this.Text, SystemFonts.CaptionFont, br, rc);\n\n                /*close butt*/\n                rc=new Rectangle(e.Bounds.Width-w-w2, h, w2, h2-4);                \n                e.Graphics.DrawString(\"x\", font, br, rc ,fmt);\n\n                /*max butt*/\n                rc = new Rectangle(e.Bounds.Width - w - w2*2, h, w2, h2-4);                \n                e.Graphics.DrawString(\"■\", font, br, rc, fmt);\n\n                /*min butt*/\n                rc = new Rectangle(e.Bounds.Width - w - w2*3, h, w2, h2-4);                \n                e.Graphics.DrawString(\"–\", font, br, rc, fmt);\n\n            }\n\n        }\n\n\n        protected override void WndProc(ref Message m)\n        {\n\n            if (!this.EnableNonClientAreaPaint)\n            {\n                base.WndProc(ref m);\n                return;\n            }\n\n            switch (m.Msg)\n            {\n\n                case (int)NativeMethods.WindowMessages.WM_NCPAINT:\n                    {\n                        // Here should all our painting occur, but...\n                        DefWndProc(ref m);\n                        WmNCPaint(ref m);\n                        this.Refresh();\n                        break;\n                    }\n                case (int)NativeMethods.WindowMessages.WM_NCACTIVATE:\n                    {\n                        // ... WM_NCACTIVATE does some painting directly \n                        // without bothering with WM_NCPAINT ...\n                        WmNCActivate(ref m);\n                        break;\n                    }\n                case (int)NativeMethods.WindowMessages.WM_SETTEXT:\n                    {\n                        // ... and some painting is required in here as well\n                        WmSetText(ref m);\n                        break;\n                    }\n                case (int)NativeMethods.WindowMessages.WM_NCMOUSEMOVE:\n                    {\n                        //PaintNonClientArea(this.Handle, (IntPtr)1);\n                        //this.Refresh();\n                        WmNCMouseMove(ref m);\n                        break;\n                    }\n\n                case (int)NativeMethods.WindowMessages.WM_ERASEBKGND:\n                    {\n                        WmEraseBkgnd(ref m);\n                        break;\n                    }\n                default:\n                    {\n                        base.WndProc(ref m);\n                        break;\n                    }\n            }\n        }\n\n        #region Wm ... (Windows message...)\n\n        protected void OnUpdateWindowState()\n        { }\n\n        private void WmEraseBkgnd(ref Message m)\n        {\n            base.WndProc(ref m);\n\n            //Log(MethodInfo.GetCurrentMethod(), \"{0}\", WindowState);\n            OnUpdateWindowState();\n        }\n\n        #endregion\n\n\n        public Point PointToWindow(Point screenPoint)\n        {\n            return new Point(screenPoint.X - Location.X, screenPoint.Y - Location.Y);\n        }\n\n\n        #region WmNC ... (Windows message... Non Client)               \n\n        /// &lt;summary&gt;\n        /// Handle WmNCMouseMove, so buttons aren't repainted due to mouse movement\n        /// &lt;/summary&gt;        \n        private void WmNCMouseMove(ref Message msg)\n        {\n\n            Point clientPoint = this.PointToWindow(new Point(msg.LParam.ToInt32()));            \n            msg.Result = IntPtr.Zero;\n        }\n\n\n        private void PaintNonClientArea(IntPtr hWnd, IntPtr hRgn)\n        {\n            NativeMethods.RECT windowRect = new NativeMethods.RECT();\n            if (NativeMethods.GetWindowRect(hWnd, ref windowRect) == 0)\n                return;\n\n            Rectangle bounds = new Rectangle(0, 0,\n                windowRect.right - windowRect.left,\n                windowRect.bottom - windowRect.top);\n\n            if (bounds.Width == 0 || bounds.Height == 0)\n                return;\n\n            // The update region is clipped to the window frame. When wParam is 1, the entire window frame needs to be updated. \n            Region clipRegion = null;\n            if (hRgn != (IntPtr)1)\n                clipRegion = System.Drawing.Region.FromHrgn(hRgn);\n\n            // MSDN states that only WINDOW and INTERSECTRGN are needed,\n            // but other sources confirm that CACHE is required on Win9x\n            // and you need CLIPSIBLINGS to prevent painting on overlapping windows.\n            IntPtr hDC = NativeMethods.GetDCEx(/*hWnd*/this.Handle, /*hRgn*/(IntPtr)0,\n                (int)(NativeMethods.DCX.DCX_WINDOW /*| NativeMethods.DCX.DCX_INTERSECTRGN*/\n                    | NativeMethods.DCX.DCX_CACHE | NativeMethods.DCX.DCX_CLIPSIBLINGS));\n\n            if (hDC == IntPtr.Zero)\n                return;\n\n\n            try\n            {\n                    using (Graphics g = Graphics.FromHdc(hDC))\n                    {\n                        //cliping rect is not cliping rect but actual rectangle\n                        OnNonClientAreaPaint(new NonClientPaintEventArgs(g, bounds, clipRegion));\n                    }\n\n                    //NOTE: The Graphics object would realease the HDC on Dispose.\n                    // So there is no need to call NativeMethods.ReleaseDC(msg.HWnd, hDC);\n\n            }\n            finally\n            {\n                NativeMethods.ReleaseDC(this.Handle, hDC);\n            }\n        }\n\n        private void WmNCPaint(ref Message msg)\n        {            \n\n            // The WParam contains handle to clipRegion or 1 if entire window should be repainted\n            PaintNonClientArea(msg.HWnd, (IntPtr)msg.WParam);\n\n            // we handled everything\n            msg.Result = NativeMethods.TRUE;\n        }\n\n        private void WmSetText(ref Message msg)\n        {\n            // allow the system to receive the new window title\n            DefWndProc(ref msg);\n\n            // repaint title bar\n            PaintNonClientArea(msg.HWnd, (IntPtr)1);\n        }\n\n        private void WmNCActivate(ref Message msg)\n        {           \n\n            bool active = (msg.WParam == NativeMethods.TRUE);            \n\n            if (WindowState == FormWindowState.Minimized)\n                DefWndProc(ref msg);\n            else\n            {\n                // repaint title bar\n                PaintNonClientArea(msg.HWnd, (IntPtr)1);\n\n                // allow to deactivate window\n                msg.Result = NativeMethods.TRUE;\n            }\n        }\n\n        #endregion\n\n\n    }\n\n    public class NonClientPaintEventArgs : EventArgs\n    {\n        public Graphics Graphics;\n        public Rectangle Bounds;\n        public Region clipRegion;\n\n        public NonClientPaintEventArgs(Graphics g, Rectangle bounds, Region cr)\n        {\n            this.Graphics = g;\n            this.Bounds = bounds;\n            clipRegion = cr;\n\n        }\n\n    }\n}\n</code></pre>\n\n<p>Вот как это выглядит</p>\n\n<p><a href=\"https://i.stack.imgur.com/5hgch.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/5hgch.png\" alt=\"введите сюда описание изображения\"></a></p>\n"}