{"tags":["c#","c++","winapi","клавиатура"],"owner":{"reputation":1415,"user_id":238013,"user_type":"registered","accept_rate":64,"profile_image":"https://www.gravatar.com/avatar/d4dab84aa4c67525aecd5da391a8e68a?s=128&d=identicon&r=PG&f=1","display_name":"D .Stark","link":"https://ru.stackoverflow.com/users/238013/d-stark"},"is_answered":true,"view_count":1312,"answer_count":1,"score":2,"last_activity_date":1521963104,"creation_date":1515418312,"last_edit_date":1515557799,"question_id":767999,"link":"https://ru.stackoverflow.com/questions/767999/getkeyboardstate-%d0%be%d0%bf%d1%80%d0%b5%d0%b4%d0%b5%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d1%81%d0%be%d1%81%d1%82%d0%be%d1%8f%d0%bd%d0%b8%d1%8f-%d0%ba%d0%bb%d0%b0%d0%b2%d0%b8%d1%88%d0%b8","title":"GetKeyboardState: определение состояния клавиши","body":"<p>Не могу понять как работает функция <code>GetKeyboardState</code>. Вроде как должна определять состояние всех клавиш, но правильность результата зависит от места вызова... Если, например, скрыть окно, либо запускать функцию по таймеру, все значения окажутся равными 0. Если же назначить некоторой кнопке обработчик и при нажатии определять состояние, скажем, LeftShift, функция покажет верное значение.</p>\n\n<p>Ещё мне не ясно как обозначаются состояния клавиш. Понятно, что старший бит говорит о том нажата клавиша или нет, а вот младший - is key toggled. Что ещё за Toggled state?</p>\n\n<p><strong>UPD:</strong> Так же, на счёт toggled state, согласно моим наблюдениям вполне возможна ситуация когда клавиша не нажата, а старший бит равен 1 (младший 0). Не могу понять никак как это должно работать...</p>\n\n<pre><code>var keyboardState = new byte[256];\nGetKeyboardState(keyboardState);\nvar keyStateBits = new System.Collections.BitArray(new byte[] { keyboardState[(uint)Keys.LShiftKey] });\nDebug.WriteLine(\"SHIFT key state: down - \" + keyStateBits[0] + \"; toggled - \" + keyStateBits[7]);\n</code></pre>\n\n<p><strong>UPD2:</strong> В самом деле мне нужно сделать работоспособным этот код:</p>\n\n<pre><code>    [DllImport(\"user32.dll\")]\n    static extern int ToUnicodeEx(\n        uint wVirtKey, \n        uint wScanCode, \n        byte[] lpKeyState, \n        [Out, MarshalAs(UnmanagedType.LPWStr)] StringBuilder pwszBuff, \n        int cchBuff, \n        uint wFlags, \n        IntPtr dwhkl);\n\n    [DllImport(\"user32.dll\")]\n    static extern bool GetKeyboardState(byte[] lpKeyState);\n\n    [DllImport(\"user32.dll\")]\n    static extern uint MapVirtualKey(\n        uint uCode, \n        uint uMapType);\n\n    [DllImport(\"user32.dll\")]\n    static extern IntPtr GetKeyboardLayout(uint idThread);\n\n    public static string VKCodeToUnicode(uint vkCode) {\n\n        StringBuilder buf = new StringBuilder();\n        byte[] keyboardState = new byte[255];\n        if (!GetKeyboardState(keyboardState)) return string.Empty;\n\n        ToUnicodeEx(vkCode, MapVirtualKey(vkCode, 0), keyboardState, buf, 5, 0, GetKeyboardLayout(0));\n        return buf.ToString();\n    }\n</code></pre>\n\n<p>Если окно отображается и активно, всё работает. Но если окно скрыть (ну через ShowWindow SW_HIDE), код выдаёт неправильные значения (без учёта состояния клавиш клавиатуры управляющих регистром и текущего языка раскладки)... Как это решить?</p>\n"}