{"owner":{"reputation":16068,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":2,"last_activity_date":1528092808,"creation_date":1528092808,"answer_id":837327,"question_id":835642,"body":"<p>Можно взять класс PeHeaderReader <a href=\"https://gist.github.com/b0urb4k1/ef386f9075d1f74fdff607f306743954\" rel=\"nofollow noreferrer\">отсюда</a>:</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.InteropServices;\n\n\n/// &lt;summary&gt;\n/// Reads in the header information of the Portable Executable format.\n/// Provides information such as the date the assembly was compiled.\n/// &lt;/summary&gt;\npublic class PeHeaderReader\n{\n    #region File Header Structures\n\n    public struct IMAGE_DOS_HEADER\n    {      // DOS .EXE header\n        public UInt16 e_magic;              // Magic number\n        public UInt16 e_cblp;               // Bytes on last page of file\n        public UInt16 e_cp;                 // Pages in file\n        public UInt16 e_crlc;               // Relocations\n        public UInt16 e_cparhdr;            // Size of header in paragraphs\n        public UInt16 e_minalloc;           // Minimum extra paragraphs needed\n        public UInt16 e_maxalloc;           // Maximum extra paragraphs needed\n        public UInt16 e_ss;                 // Initial (relative) SS value\n        public UInt16 e_sp;                 // Initial SP value\n        public UInt16 e_csum;               // Checksum\n        public UInt16 e_ip;                 // Initial IP value\n        public UInt16 e_cs;                 // Initial (relative) CS value\n        public UInt16 e_lfarlc;             // File address of relocation table\n        public UInt16 e_ovno;               // Overlay number\n        public UInt16 e_res_0;              // Reserved words\n        public UInt16 e_res_1;              // Reserved words\n        public UInt16 e_res_2;              // Reserved words\n        public UInt16 e_res_3;              // Reserved words\n        public UInt16 e_oemid;              // OEM identifier (for e_oeminfo)\n        public UInt16 e_oeminfo;            // OEM information; e_oemid specific\n        public UInt16 e_res2_0;             // Reserved words\n        public UInt16 e_res2_1;             // Reserved words\n        public UInt16 e_res2_2;             // Reserved words\n        public UInt16 e_res2_3;             // Reserved words\n        public UInt16 e_res2_4;             // Reserved words\n        public UInt16 e_res2_5;             // Reserved words\n        public UInt16 e_res2_6;             // Reserved words\n        public UInt16 e_res2_7;             // Reserved words\n        public UInt16 e_res2_8;             // Reserved words\n        public UInt16 e_res2_9;             // Reserved words\n        public UInt32 e_lfanew;             // File address of new exe header\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct IMAGE_DATA_DIRECTORY\n    {\n        public UInt32 VirtualAddress;\n        public UInt32 Size;\n    }\n\n    [StructLayout(LayoutKind.Sequential, Pack = 1)]\n    public struct IMAGE_OPTIONAL_HEADER32\n    {\n        public UInt16 Magic;\n        public Byte MajorLinkerVersion;\n        public Byte MinorLinkerVersion;\n        public UInt32 SizeOfCode;\n        public UInt32 SizeOfInitializedData;\n        public UInt32 SizeOfUninitializedData;\n        public UInt32 AddressOfEntryPoint;\n        public UInt32 BaseOfCode;\n        public UInt32 BaseOfData;\n        public UInt32 ImageBase;\n        public UInt32 SectionAlignment;\n        public UInt32 FileAlignment;\n        public UInt16 MajorOperatingSystemVersion;\n        public UInt16 MinorOperatingSystemVersion;\n        public UInt16 MajorImageVersion;\n        public UInt16 MinorImageVersion;\n        public UInt16 MajorSubsystemVersion;\n        public UInt16 MinorSubsystemVersion;\n        public UInt32 Win32VersionValue;\n        public UInt32 SizeOfImage;\n        public UInt32 SizeOfHeaders;\n        public UInt32 CheckSum;\n        public UInt16 Subsystem;\n        public UInt16 DllCharacteristics;\n        public UInt32 SizeOfStackReserve;\n        public UInt32 SizeOfStackCommit;\n        public UInt32 SizeOfHeapReserve;\n        public UInt32 SizeOfHeapCommit;\n        public UInt32 LoaderFlags;\n        public UInt32 NumberOfRvaAndSizes;\n\n        public IMAGE_DATA_DIRECTORY ExportTable;\n        public IMAGE_DATA_DIRECTORY ImportTable;\n        public IMAGE_DATA_DIRECTORY ResourceTable;\n        public IMAGE_DATA_DIRECTORY ExceptionTable;\n        public IMAGE_DATA_DIRECTORY CertificateTable;\n        public IMAGE_DATA_DIRECTORY BaseRelocationTable;\n        public IMAGE_DATA_DIRECTORY Debug;\n        public IMAGE_DATA_DIRECTORY Architecture;\n        public IMAGE_DATA_DIRECTORY GlobalPtr;\n        public IMAGE_DATA_DIRECTORY TLSTable;\n        public IMAGE_DATA_DIRECTORY LoadConfigTable;\n        public IMAGE_DATA_DIRECTORY BoundImport;\n        public IMAGE_DATA_DIRECTORY IAT;\n        public IMAGE_DATA_DIRECTORY DelayImportDescriptor;\n        public IMAGE_DATA_DIRECTORY CLRRuntimeHeader;\n        public IMAGE_DATA_DIRECTORY Reserved;\n    }\n\n    [StructLayout(LayoutKind.Sequential, Pack = 1)]\n    public struct IMAGE_OPTIONAL_HEADER64\n    {\n        public UInt16 Magic;\n        public Byte MajorLinkerVersion;\n        public Byte MinorLinkerVersion;\n        public UInt32 SizeOfCode;\n        public UInt32 SizeOfInitializedData;\n        public UInt32 SizeOfUninitializedData;\n        public UInt32 AddressOfEntryPoint;\n        public UInt32 BaseOfCode;\n        public UInt64 ImageBase;\n        public UInt32 SectionAlignment;\n        public UInt32 FileAlignment;\n        public UInt16 MajorOperatingSystemVersion;\n        public UInt16 MinorOperatingSystemVersion;\n        public UInt16 MajorImageVersion;\n        public UInt16 MinorImageVersion;\n        public UInt16 MajorSubsystemVersion;\n        public UInt16 MinorSubsystemVersion;\n        public UInt32 Win32VersionValue;\n        public UInt32 SizeOfImage;\n        public UInt32 SizeOfHeaders;\n        public UInt32 CheckSum;\n        public UInt16 Subsystem;\n        public UInt16 DllCharacteristics;\n        public UInt64 SizeOfStackReserve;\n        public UInt64 SizeOfStackCommit;\n        public UInt64 SizeOfHeapReserve;\n        public UInt64 SizeOfHeapCommit;\n        public UInt32 LoaderFlags;\n        public UInt32 NumberOfRvaAndSizes;\n\n        public IMAGE_DATA_DIRECTORY ExportTable;\n        public IMAGE_DATA_DIRECTORY ImportTable;\n        public IMAGE_DATA_DIRECTORY ResourceTable;\n        public IMAGE_DATA_DIRECTORY ExceptionTable;\n        public IMAGE_DATA_DIRECTORY CertificateTable;\n        public IMAGE_DATA_DIRECTORY BaseRelocationTable;\n        public IMAGE_DATA_DIRECTORY Debug;\n        public IMAGE_DATA_DIRECTORY Architecture;\n        public IMAGE_DATA_DIRECTORY GlobalPtr;\n        public IMAGE_DATA_DIRECTORY TLSTable;\n        public IMAGE_DATA_DIRECTORY LoadConfigTable;\n        public IMAGE_DATA_DIRECTORY BoundImport;\n        public IMAGE_DATA_DIRECTORY IAT;\n        public IMAGE_DATA_DIRECTORY DelayImportDescriptor;\n        public IMAGE_DATA_DIRECTORY CLRRuntimeHeader;\n        public IMAGE_DATA_DIRECTORY Reserved;\n    }\n\n    [StructLayout(LayoutKind.Sequential, Pack = 1)]\n    public struct IMAGE_FILE_HEADER\n    {\n        public UInt16 Machine;\n        public UInt16 NumberOfSections;\n        public UInt32 TimeDateStamp;\n        public UInt32 PointerToSymbolTable;\n        public UInt32 NumberOfSymbols;\n        public UInt16 SizeOfOptionalHeader;\n        public UInt16 Characteristics;\n    }\n\n    // Grabbed the following 2 definitions from http://www.pinvoke.net/default.aspx/Structures/IMAGE_SECTION_HEADER.html\n\n    [StructLayout(LayoutKind.Explicit)]\n    public struct IMAGE_SECTION_HEADER\n    {\n        [FieldOffset(0)]\n        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]\n        public char[] Name;\n        [FieldOffset(8)]\n        public UInt32 VirtualSize;\n        [FieldOffset(12)]\n        public UInt32 VirtualAddress;\n        [FieldOffset(16)]\n        public UInt32 SizeOfRawData;\n        [FieldOffset(20)]\n        public UInt32 PointerToRawData;\n        [FieldOffset(24)]\n        public UInt32 PointerToRelocations;\n        [FieldOffset(28)]\n        public UInt32 PointerToLinenumbers;\n        [FieldOffset(32)]\n        public UInt16 NumberOfRelocations;\n        [FieldOffset(34)]\n        public UInt16 NumberOfLinenumbers;\n        [FieldOffset(36)]\n        public DataSectionFlags Characteristics;\n\n        public string Section\n        {\n            get { return new string(Name); }\n        }\n    }\n\n    [Flags]\n    public enum DataSectionFlags : uint\n    {\n        /// &lt;summary&gt;\n        /// Reserved for future use.\n        /// &lt;/summary&gt;\n        TypeReg = 0x00000000,\n        /// &lt;summary&gt;\n        /// Reserved for future use.\n        /// &lt;/summary&gt;\n        TypeDsect = 0x00000001,\n        /// &lt;summary&gt;\n        /// Reserved for future use.\n        /// &lt;/summary&gt;\n        TypeNoLoad = 0x00000002,\n        /// &lt;summary&gt;\n        /// Reserved for future use.\n        /// &lt;/summary&gt;\n        TypeGroup = 0x00000004,\n        /// &lt;summary&gt;\n        /// The section should not be padded to the next boundary. This flag is obsolete and is replaced by IMAGE_SCN_ALIGN_1BYTES. This is valid only for object files.\n        /// &lt;/summary&gt;\n        TypeNoPadded = 0x00000008,\n        /// &lt;summary&gt;\n        /// Reserved for future use.\n        /// &lt;/summary&gt;\n        TypeCopy = 0x00000010,\n        /// &lt;summary&gt;\n        /// The section contains executable code.\n        /// &lt;/summary&gt;\n        ContentCode = 0x00000020,\n        /// &lt;summary&gt;\n        /// The section contains initialized data.\n        /// &lt;/summary&gt;\n        ContentInitializedData = 0x00000040,\n        /// &lt;summary&gt;\n        /// The section contains uninitialized data.\n        /// &lt;/summary&gt;\n        ContentUninitializedData = 0x00000080,\n        /// &lt;summary&gt;\n        /// Reserved for future use.\n        /// &lt;/summary&gt;\n        LinkOther = 0x00000100,\n        /// &lt;summary&gt;\n        /// The section contains comments or other information. The .drectve section has this type. This is valid for object files only.\n        /// &lt;/summary&gt;\n        LinkInfo = 0x00000200,\n        /// &lt;summary&gt;\n        /// Reserved for future use.\n        /// &lt;/summary&gt;\n        TypeOver = 0x00000400,\n        /// &lt;summary&gt;\n        /// The section will not become part of the image. This is valid only for object files.\n        /// &lt;/summary&gt;\n        LinkRemove = 0x00000800,\n        /// &lt;summary&gt;\n        /// The section contains COMDAT data. For more information, see section 5.5.6, COMDAT Sections (Object Only). This is valid only for object files.\n        /// &lt;/summary&gt;\n        LinkComDat = 0x00001000,\n        /// &lt;summary&gt;\n        /// Reset speculative exceptions handling bits in the TLB entries for this section.\n        /// &lt;/summary&gt;\n        NoDeferSpecExceptions = 0x00004000,\n        /// &lt;summary&gt;\n        /// The section contains data referenced through the global pointer (GP).\n        /// &lt;/summary&gt;\n        RelativeGP = 0x00008000,\n        /// &lt;summary&gt;\n        /// Reserved for future use.\n        /// &lt;/summary&gt;\n        MemPurgeable = 0x00020000,\n        /// &lt;summary&gt;\n        /// Reserved for future use.\n        /// &lt;/summary&gt;\n        Memory16Bit = 0x00020000,\n        /// &lt;summary&gt;\n        /// Reserved for future use.\n        /// &lt;/summary&gt;\n        MemoryLocked = 0x00040000,\n        /// &lt;summary&gt;\n        /// Reserved for future use.\n        /// &lt;/summary&gt;\n        MemoryPreload = 0x00080000,\n        /// &lt;summary&gt;\n        /// Align data on a 1-byte boundary. Valid only for object files.\n        /// &lt;/summary&gt;\n        Align1Bytes = 0x00100000,\n        /// &lt;summary&gt;\n        /// Align data on a 2-byte boundary. Valid only for object files.\n        /// &lt;/summary&gt;\n        Align2Bytes = 0x00200000,\n        /// &lt;summary&gt;\n        /// Align data on a 4-byte boundary. Valid only for object files.\n        /// &lt;/summary&gt;\n        Align4Bytes = 0x00300000,\n        /// &lt;summary&gt;\n        /// Align data on an 8-byte boundary. Valid only for object files.\n        /// &lt;/summary&gt;\n        Align8Bytes = 0x00400000,\n        /// &lt;summary&gt;\n        /// Align data on a 16-byte boundary. Valid only for object files.\n        /// &lt;/summary&gt;\n        Align16Bytes = 0x00500000,\n        /// &lt;summary&gt;\n        /// Align data on a 32-byte boundary. Valid only for object files.\n        /// &lt;/summary&gt;\n        Align32Bytes = 0x00600000,\n        /// &lt;summary&gt;\n        /// Align data on a 64-byte boundary. Valid only for object files.\n        /// &lt;/summary&gt;\n        Align64Bytes = 0x00700000,\n        /// &lt;summary&gt;\n        /// Align data on a 128-byte boundary. Valid only for object files.\n        /// &lt;/summary&gt;\n        Align128Bytes = 0x00800000,\n        /// &lt;summary&gt;\n        /// Align data on a 256-byte boundary. Valid only for object files.\n        /// &lt;/summary&gt;\n        Align256Bytes = 0x00900000,\n        /// &lt;summary&gt;\n        /// Align data on a 512-byte boundary. Valid only for object files.\n        /// &lt;/summary&gt;\n        Align512Bytes = 0x00A00000,\n        /// &lt;summary&gt;\n        /// Align data on a 1024-byte boundary. Valid only for object files.\n        /// &lt;/summary&gt;\n        Align1024Bytes = 0x00B00000,\n        /// &lt;summary&gt;\n        /// Align data on a 2048-byte boundary. Valid only for object files.\n        /// &lt;/summary&gt;\n        Align2048Bytes = 0x00C00000,\n        /// &lt;summary&gt;\n        /// Align data on a 4096-byte boundary. Valid only for object files.\n        /// &lt;/summary&gt;\n        Align4096Bytes = 0x00D00000,\n        /// &lt;summary&gt;\n        /// Align data on an 8192-byte boundary. Valid only for object files.\n        /// &lt;/summary&gt;\n        Align8192Bytes = 0x00E00000,\n        /// &lt;summary&gt;\n        /// The section contains extended relocations.\n        /// &lt;/summary&gt;\n        LinkExtendedRelocationOverflow = 0x01000000,\n        /// &lt;summary&gt;\n        /// The section can be discarded as needed.\n        /// &lt;/summary&gt;\n        MemoryDiscardable = 0x02000000,\n        /// &lt;summary&gt;\n        /// The section cannot be cached.\n        /// &lt;/summary&gt;\n        MemoryNotCached = 0x04000000,\n        /// &lt;summary&gt;\n        /// The section is not pageable.\n        /// &lt;/summary&gt;\n        MemoryNotPaged = 0x08000000,\n        /// &lt;summary&gt;\n        /// The section can be shared in memory.\n        /// &lt;/summary&gt;\n        MemoryShared = 0x10000000,\n        /// &lt;summary&gt;\n        /// The section can be executed as code.\n        /// &lt;/summary&gt;\n        MemoryExecute = 0x20000000,\n        /// &lt;summary&gt;\n        /// The section can be read.\n        /// &lt;/summary&gt;\n        MemoryRead = 0x40000000,\n        /// &lt;summary&gt;\n        /// The section can be written to.\n        /// &lt;/summary&gt;\n        MemoryWrite = 0x80000000\n    }\n\n    #endregion File Header Structures\n\n    #region Private Fields\n\n    /// &lt;summary&gt;\n    /// The DOS header\n    /// &lt;/summary&gt;\n    private IMAGE_DOS_HEADER dosHeader;\n    /// &lt;summary&gt;\n    /// The file header\n    /// &lt;/summary&gt;\n    private IMAGE_FILE_HEADER fileHeader;\n    /// &lt;summary&gt;\n    /// Optional 32 bit file header \n    /// &lt;/summary&gt;\n    private IMAGE_OPTIONAL_HEADER32 optionalHeader32;\n    /// &lt;summary&gt;\n    /// Optional 64 bit file header \n    /// &lt;/summary&gt;\n    private IMAGE_OPTIONAL_HEADER64 optionalHeader64;\n    /// &lt;summary&gt;\n    /// Image Section headers. Number of sections is in the file header.\n    /// &lt;/summary&gt;\n    private IMAGE_SECTION_HEADER[] imageSectionHeaders;\n\n    #endregion Private Fields\n\n    #region Public Methods\n\n    public PeHeaderReader(string filePath)\n    {\n        // Read in the DLL or EXE and get the timestamp\n        using (FileStream stream = new FileStream(filePath, System.IO.FileMode.Open, System.IO.FileAccess.Read))\n        {\n            BinaryReader reader = new BinaryReader(stream);\n            dosHeader = FromBinaryReader&lt;IMAGE_DOS_HEADER&gt;(reader);\n\n            // Add 4 bytes to the offset\n            stream.Seek(dosHeader.e_lfanew, SeekOrigin.Begin);\n\n            UInt32 ntHeadersSignature = reader.ReadUInt32();\n            fileHeader = FromBinaryReader&lt;IMAGE_FILE_HEADER&gt;(reader);\n            if (this.Is32BitHeader)\n            {\n                optionalHeader32 = FromBinaryReader&lt;IMAGE_OPTIONAL_HEADER32&gt;(reader);\n            }\n            else\n            {\n                optionalHeader64 = FromBinaryReader&lt;IMAGE_OPTIONAL_HEADER64&gt;(reader);\n            }\n\n            imageSectionHeaders = new IMAGE_SECTION_HEADER[fileHeader.NumberOfSections];\n            for (int headerNo = 0; headerNo &lt; imageSectionHeaders.Length; ++headerNo)\n            {\n                imageSectionHeaders[headerNo] = FromBinaryReader&lt;IMAGE_SECTION_HEADER&gt;(reader);\n            }\n\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Gets the header of the .NET assembly that called this function\n    /// &lt;/summary&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public static PeHeaderReader GetCallingAssemblyHeader()\n    {\n        // Get the path to the calling assembly, which is the path to the\n        // DLL or EXE that we want the time of\n        string filePath = System.Reflection.Assembly.GetCallingAssembly().Location;\n\n        // Get and return the timestamp\n        return new PeHeaderReader(filePath);\n    }\n\n    /// &lt;summary&gt;\n    /// Gets the header of the .NET assembly that called this function\n    /// &lt;/summary&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public static PeHeaderReader GetAssemblyHeader()\n    {\n        // Get the path to the calling assembly, which is the path to the\n        // DLL or EXE that we want the time of\n        string filePath = System.Reflection.Assembly.GetAssembly(typeof(PeHeaderReader)).Location;\n\n        // Get and return the timestamp\n        return new PeHeaderReader(filePath);\n    }\n\n    /// &lt;summary&gt;\n    /// Reads in a block from a file and converts it to the struct\n    /// type specified by the template parameter\n    /// &lt;/summary&gt;\n    /// &lt;typeparam name=\"T\"&gt;&lt;/typeparam&gt;\n    /// &lt;param name=\"reader\"&gt;&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public static T FromBinaryReader&lt;T&gt;(BinaryReader reader)\n    {\n        // Read in a byte array\n        byte[] bytes = reader.ReadBytes(Marshal.SizeOf(typeof(T)));\n\n        // Pin the managed memory while, copy it out the data, then unpin it\n        GCHandle handle = GCHandle.Alloc(bytes, GCHandleType.Pinned);\n        T theStructure = (T)Marshal.PtrToStructure(handle.AddrOfPinnedObject(), typeof(T));\n        handle.Free();\n\n        return theStructure;\n    }\n\n    #endregion Public Methods\n\n    #region Properties\n\n    /// &lt;summary&gt;\n    /// Gets if the file header is 32 bit or not\n    /// &lt;/summary&gt;\n    public bool Is32BitHeader\n    {\n        get\n        {\n            UInt16 IMAGE_FILE_32BIT_MACHINE = 0x0100;\n            return (IMAGE_FILE_32BIT_MACHINE &amp; FileHeader.Characteristics) == IMAGE_FILE_32BIT_MACHINE;\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Gets the file header\n    /// &lt;/summary&gt;\n    public IMAGE_FILE_HEADER FileHeader\n    {\n        get\n        {\n            return fileHeader;\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Gets the optional header\n    /// &lt;/summary&gt;\n    public IMAGE_OPTIONAL_HEADER32 OptionalHeader32\n    {\n        get\n        {\n            return optionalHeader32;\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Gets the optional header\n    /// &lt;/summary&gt;\n    public IMAGE_OPTIONAL_HEADER64 OptionalHeader64\n    {\n        get\n        {\n            return optionalHeader64;\n        }\n    }\n\n    public IMAGE_SECTION_HEADER[] ImageSectionHeaders\n    {\n        get\n        {\n            return imageSectionHeaders;\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Gets the timestamp from the file header\n    /// &lt;/summary&gt;\n    public DateTime TimeStamp\n    {\n        get\n        {\n            // Timestamp is a date offset from 1970\n            DateTime returnValue = new DateTime(1970, 1, 1, 0, 0, 0);\n\n            // Add in the number of seconds since 1970/1/1\n            returnValue = returnValue.AddSeconds(fileHeader.TimeDateStamp);\n            // Adjust to local timezone\n            returnValue += TimeZone.CurrentTimeZone.GetUtcOffset(returnValue);\n\n            return returnValue;\n        }\n    }\n\n    #endregion Properties\n}\n</code></pre>\n\n<p>Использовать так:</p>\n\n<pre><code>System.Reflection.Assembly ass = System.Reflection.Assembly.GetExecutingAssembly();\n\nPeHeaderReader reader = new PeHeaderReader(ass.ManifestModule.FullyQualifiedName);\n\nif (reader.Is32BitHeader)\n{    \n    PeHeaderReader.IMAGE_OPTIONAL_HEADER32 header32 = reader.OptionalHeader32;               \n    uint address = header32.AddressOfEntryPoint;\n}\nelse MessageBox.Show(\"not 32-bit header\");\n</code></pre>\n"}