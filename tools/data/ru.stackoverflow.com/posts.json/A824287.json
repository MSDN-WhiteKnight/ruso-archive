{"owner":{"reputation":16068,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":2,"last_activity_date":1525669258,"creation_date":1525669258,"answer_id":824287,"question_id":115854,"body":"<p>Используя функцию <em>WSCEnumProtocols</em>. Код на основе примера из <a href=\"https://github.com/pauldotknopf/WindowsSDK7-Samples/tree/e8fe83b043727e71f5179da11fc6228475e7973c/netds/winsock/lsp\" rel=\"nofollow noreferrer\">Windows SDK</a>:</p>\n\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;locale.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;tchar.h&gt;\n\n#include &lt;winsock2.h&gt;\n#include &lt;Windows.h&gt;\n#include &lt;ws2spi.h&gt;\n//https://github.com/pauldotknopf/WindowsSDK7-Samples/blob/e8fe83b043727e71f5179da11fc6228475e7973c/netds/winsock/lsp/install/instlsp.cpp\n\n#pragma comment(lib,\"Ws2_32.lib\")\n\ntypedef enum\n{\n    LspCatalogBoth = 0,\n    LspCatalog32Only,\n    LspCatalog64Only\n} WINSOCK_CATALOG;\n\n//*** private LSP heap ****\nHANDLE gLspHeap = NULL;\n\nint LspCreateHeap( int *lpErrno    )\n{\n    gLspHeap = HeapCreate( 0, 128000, 0 );\n    if ( NULL == gLspHeap )\n    {\n        *lpErrno = WSAEPROVIDERFAILEDINIT;\n        return SOCKET_ERROR;\n    }\n    return NO_ERROR;\n}\n\nvoid * LspAlloc(    SIZE_T  size,    int    *lpErrno    )\n{\n    void *mem = NULL;\n    mem = HeapAlloc( \n            gLspHeap, \n            HEAP_ZERO_MEMORY, \n            size\n            );\n    if ( NULL == mem )\n    {\n        *lpErrno = WSAENOBUFS;\n    }\n\n    return mem;\n}\n\nvoid LspFree(    LPVOID  buf    )\n{\n    HeapFree( gLspHeap, 0, buf );\n}\n\n//**********************************************\n\nLPWSAPROTOCOL_INFOW EnumerateProviders(\n    WINSOCK_CATALOG Catalog, \n    LPINT           TotalProtocols\n    )\n{\n    LPWSAPROTOCOL_INFOW ProtocolInfo = NULL;\n    DWORD               ProtocolInfoSize = 0;\n    INT                 ErrorCode = NO_ERROR,\n                        rc;\n\n    if ( NULL == TotalProtocols )\n        goto cleanup;\n\n    *TotalProtocols = 0;\n\n#ifdef _WIN64\n    // Find out how many entries we need to enumerate\n    if ( LspCatalog64Only == Catalog )\n    {\n        // Find the size of the buffer\n        rc = WSCEnumProtocols( NULL, ProtocolInfo, &amp;ProtocolInfoSize, &amp;ErrorCode );\n        if ( SOCKET_ERROR == rc )\n        {\n            if ( WSAENOBUFS != ErrorCode )\n                goto cleanup;\n            ErrorCode = NO_ERROR;\n        }\n\n        // Allocate the buffer\n        ProtocolInfo = (LPWSAPROTOCOL_INFOW) LspAlloc(\n                ProtocolInfoSize,\n               &amp;ErrorCode\n                );\n        if (ProtocolInfo == NULL)\n            goto cleanup;\n\n        // Enumerate the catalog for real\n        rc = WSCEnumProtocols( NULL, ProtocolInfo, &amp;ProtocolInfoSize, &amp;ErrorCode );\n        if ( SOCKET_ERROR == rc )\n            goto cleanup;\n\n        // Update the count\n        *TotalProtocols = rc;\n    }\n    else if ( LspCatalog32Only == Catalog )\n    {\n        HMODULE            hModule;\n        LPWSCENUMPROTOCOLS fnWscEnumProtocols32 = NULL;\n\n        // Load ws2_32.dll\n        hModule = LoadLibrary( TEXT( \"ws2_32.dll\" ) );\n        if ( NULL == hModule )\n            goto cleanup;\n\n        // Find the 32-bit catalog enumerator\n        fnWscEnumProtocols32 = (LPWSCENUMPROTOCOLS) GetProcAddress(\n                hModule, \n                \"WSCEnumProtocols32\" \n                );\n        if ( NULL == fnWscEnumProtocols32 )\n            goto cleanup;\n\n        // Find the required buffer size\n        rc = fnWscEnumProtocols32(NULL, ProtocolInfo, &amp;ProtocolInfoSize, &amp;ErrorCode);\n        if ( SOCKET_ERROR == rc )\n        {\n            if ( WSAENOBUFS != ErrorCode )\n                goto cleanup;\n            ErrorCode = NO_ERROR;\n        }\n\n        // Allocate the buffer\n        ProtocolInfo = (LPWSAPROTOCOL_INFOW) LspAlloc(\n                ProtocolInfoSize,\n               &amp;ErrorCode\n                );\n        if ( NULL == ProtocolInfo )\n            goto cleanup;\n\n        // Enumrate the catalog for real this time\n        rc = fnWscEnumProtocols32( NULL, ProtocolInfo, &amp;ProtocolInfoSize, &amp;ErrorCode );\n        if ( SOCKET_ERROR == rc )\n            goto cleanup;\n\n        // Update the count \n        *TotalProtocols = rc;\n\n        FreeLibrary( hModule );\n    }\n#else\n    if ( LspCatalog32Only == Catalog )\n    {\n        // Find the size of the buffer\n        rc = WSCEnumProtocols( NULL, ProtocolInfo, &amp;ProtocolInfoSize, &amp;ErrorCode );\n        if ( SOCKET_ERROR == rc )\n        {\n            if ( WSAENOBUFS != ErrorCode )\n                goto cleanup;\n            ErrorCode = NO_ERROR;\n        }\n\n        // Allocate the buffer\n        ProtocolInfo = (LPWSAPROTOCOL_INFOW) LspAlloc(\n                ProtocolInfoSize,\n               &amp;ErrorCode\n                );\n        if ( NULL == ProtocolInfo )\n            goto cleanup;\n\n        // Enumerate the catalog for real\n        rc = WSCEnumProtocols( NULL, ProtocolInfo, &amp;ProtocolInfoSize, &amp;ErrorCode );\n        if ( SOCKET_ERROR == rc )\n            goto cleanup;\n\n        // Update the count\n        *TotalProtocols = rc;\n    }\n    else if ( LspCatalog64Only == Catalog )\n    {\n        puts( \"Unable to enumerate 64-bit Winsock catalog from 32-bit process!\");\n    }\n#endif\n    else\n    {\n        // Find the size of the buffer\n        rc = WSCEnumProtocols( NULL, ProtocolInfo, &amp;ProtocolInfoSize, &amp;ErrorCode );\n        if ( SOCKET_ERROR == rc )\n        {\n            if ( WSAENOBUFS != ErrorCode )\n                goto cleanup;\n            ErrorCode = NO_ERROR;\n        }\n\n        // Allocate the buffer\n        ProtocolInfo = (LPWSAPROTOCOL_INFOW) LspAlloc(\n                ProtocolInfoSize,\n               &amp;ErrorCode\n                );\n        if ( NULL == ProtocolInfo )\n            goto cleanup;\n\n        // Enumerate the catalog for real\n        rc = WSCEnumProtocols( NULL, ProtocolInfo, &amp;ProtocolInfoSize, &amp;ErrorCode );\n        if ( SOCKET_ERROR == rc )\n            goto cleanup;\n\n        // Update the count\n        *TotalProtocols = rc;\n    }\n\ncleanup:\n\n    if ( ( NO_ERROR != ErrorCode ) &amp;&amp; ( NULL != ProtocolInfo ) )\n    {\n        LspFree( ProtocolInfo );\n        ProtocolInfo = NULL;\n    }\n\n    return ProtocolInfo;\n}\n\nvoid PrintProtocolInfo( WSAPROTOCOL_INFOW *wsapi)\n{\n    WCHAR       szGuidString[MAX_PATH],\n                wszProviderPath[MAX_PATH];\n    INT         dwProviderPathLen=MAX_PATH-1;\n    int         rc, error, i;\n\n    rc = WSCGetProviderPath(\n           &amp;wsapi-&gt;ProviderId,\n            wszProviderPath,\n           &amp;dwProviderPathLen,\n           &amp;error\n            );\n    if ( 0 != rc )\n    {\n        fprintf(stderr, \"WSCGetProviderPath failed: %d\\n\", error);\n        lstrcpyW(wszProviderPath, L\"(error)\");\n    }\n\n    //\n    // Display protocol information\n    //\n\n    printf(\"*** %S ***\\n\", wsapi-&gt;szProtocol);\n    printf(\"Path: %S\\n\", wszProviderPath);      \n\n    //\n    // Display provider ID and catalog ID as well as LSP chain information\n    //\n\n    StringFromGUID2( wsapi-&gt;ProviderId, szGuidString, MAX_PATH-1 );\n\n    printf(\"Provider Id: %S\\n\", szGuidString);\n\n    if(wsapi-&gt;ProtocolChain.ChainLen == LAYERED_PROTOCOL)printf(\"LSP: Yes\\n\");\n    else printf(\"LSP: No\\n\");\n\n    printf(\"Catalog Entry Id: %ld\\n\", wsapi-&gt;dwCatalogEntryId);\n    printf(\"Number of Chain Entries: %d   {\",wsapi-&gt;ProtocolChain.ChainLen);\n\n    for(i=0; i &lt; wsapi-&gt;ProtocolChain.ChainLen ;i++)\n        printf(\"%ld \", wsapi-&gt;ProtocolChain.ChainEntries[i]);\n\n    printf(\"}\\n\");    \n\n    printf(\"Version: %d\\n\\n\", wsapi-&gt;iVersion);    \n}\n\n\n\nvoid FreeProviders( LPWSAPROTOCOL_INFOW ProtocolInfo )\n{\n    LspFree( ProtocolInfo );\n}\n\n\n\n\nvoid PrintProviders( WINSOCK_CATALOG Catalog)\n{\n    WSAPROTOCOL_INFOW  *pProtocolInfo = NULL;\n    INT                 iProtocolCount = 0,\n                        i;\n\n    // Enumerate catalog and print it\n    pProtocolInfo = EnumerateProviders( Catalog, &amp;iProtocolCount );\n    if ( NULL == pProtocolInfo )\n    {\n        fprintf( stderr, \"PrintProviders: Unable to enumerate catalog!\\n\" );\n        goto cleanup;\n    }\n\n\n    for(i=0; i &lt; iProtocolCount ;i++)\n    {       \n       PrintProtocolInfo( &amp;pProtocolInfo[ i ] );            \n    }\n\ncleanup:\n\n    if ( NULL != pProtocolInfo )\n        FreeProviders( pProtocolInfo );\n\n    return;\n}\n\nint main(void)\n{\n#ifdef _WIN64\n    WINSOCK_CATALOG     eCatalog        = /*LspCatalog64Only*/LspCatalogBoth;\n#else\n    WINSOCK_CATALOG     eCatalog        = LspCatalog32Only;\n#endif  \n\n    WSADATA  wsd;\n    int rc;\n\n    setlocale(LC_ALL,\"Russian\");    \n    // Load Winsock\n    rc = WSAStartup( MAKEWORD(2,2), &amp;wsd );\n    if ( 0 != rc )\n    {\n        fprintf( stderr, \"Unable to load Winsock: %d\\n\", rc );\n        return -1;\n    }\n\n    // Initialize data structures\n    LspCreateHeap( &amp;rc );\n\n    // Print the 32-bit catalog\n    if ( ( LspCatalogBoth == eCatalog ) || ( LspCatalog32Only == eCatalog ) )\n    {\n            printf( \"\\n32-bit providers:\\n\\n\" );            \n            PrintProviders( LspCatalog32Only);\n            printf( \"=======================\\n\" );\n    }\n    // Print the 64-bit catalog\n    if ( ( LspCatalogBoth == eCatalog ) || ( LspCatalog64Only == eCatalog ) )\n    {\n            printf( \"\\n64-bit providers:\\n\\n\" );            \n            PrintProviders( LspCatalog64Only);\n            printf( \"=======================\\n\" );\n\n    }       \n\n    system(\"PAUSE\");    \n    return 0;\n}\n</code></pre>\n"}