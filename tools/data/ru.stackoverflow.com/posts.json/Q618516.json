{"tags":["vbscript","wmi","wsh"],"owner":{"reputation":131,"user_id":197563,"user_type":"registered","profile_image":"https://i.stack.imgur.com/YvdTT.jpg?s=128&g=1","display_name":"omegastripes","link":"https://ru.stackoverflow.com/users/197563/omegastripes"},"is_answered":true,"view_count":82,"answer_count":1,"score":3,"last_activity_date":1515180629,"creation_date":1485200793,"last_edit_date":1515180629,"question_id":618516,"link":"https://ru.stackoverflow.com/questions/618516/%d0%9f%d0%be%d0%bb%d1%83%d1%87%d0%b5%d0%bd%d0%b8%d0%b5-%d0%bd%d0%b0%d0%b3%d0%bb%d1%8f%d0%b4%d0%bd%d0%be%d0%b3%d0%be-%d0%b7%d0%bd%d0%b0%d1%87%d0%b5%d0%bd%d0%b8%d1%8f-wmi-win32-processor-family-%d0%b2%d0%bc%d0%b5%d1%81%d1%82%d0%be-%d0%b8%d0%bd%d0%b4%d0%b5%d0%ba%d1%81%d0%b0","title":"Получение наглядного значения WMI Win32_Processor.Family вместо индекса","body":"<p>С помощью приведенного ниже кода я получаю значения свойств <code>Caption</code> и <code>Family</code> для экземпляров класса WMI <code>Win32_Processor</code>, а также получаю массивы в качестве значений квалификаторов <code>Values</code> и <code>ValueMap</code> свойства <code>Family</code> класса <code>Win32_Processor</code>, и составляю из них таблицу соответствия <code>oMap</code>, предназначенную для перевода целочисленного значения свойства в связанное с ним строковое значение:</p>\n\n<pre><code>Const wbemFlagUseAmendedQualifiers = 131072\nSet oService = GetObject(\"winmgmts:{impersonationLevel=impersonate}!\\\\.\\Root\\CIMV2\")\ns = \"\"\nFor Each oInstance In oService.InstancesOf(\"Win32_Processor\")\n    For Each sName In Array(\"Caption\", \"Family\")\n        s = s &amp; sName &amp; \" = \" &amp; oInstance.Properties_.Item(sName).Value &amp; vbCrLf\n    Next\nNext\ns = s &amp; vbCrLf\nSet oClass = oService.Get(\"Win32_Processor\", wbemFlagUseAmendedQualifiers)\nSet oProperty = oClass.Properties_.Item(\"Family\")\naValues = oProperty.Qualifiers_.Item(\"Values\")\naValueMap = oProperty.Qualifiers_.Item(\"ValueMap\")\nSet oMap = CreateObject(\"Scripting.Dictionary\")\nFor i = 0 To UBound(aValues)\n    oMap(aValueMap(i)) = aValues(i)\nNext\nFor Each sKey In oMap\n    s = s &amp; sKey &amp; \" = \" &amp; oMap(sKey) &amp; vbCrLf\nNext\nWScript.Echo s\n</code></pre>\n\n<p>Получаю следующий вывод:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Caption = Intel64 Family 6 Model 42 Stepping 7\nFamily = 198\n\n1 = Other\n2 = Unknown\n3 = 8086\n4 = 80286\n5 = 80386\n6 = 80486\n7 = 8087\n8 = 80287\n9 = 80387\n10 = 80487\n11 = Pentium(R) brand\n12 = Pentium(R) Pro\n13 = Pentium(R) II\n14 = Pentium(R) processor with MMX(TM) technology\n15 = Celeron(TM)\n16 = Pentium(R) II Xeon(TM)\n17 = Pentium(R) III\n18 = M1 Family\n19 = M2 Family\n24 = K5 Family\n25 = K6 Family\n26 = K6-2\n27 = K6-3\n28 = AMD Athlon(TM) Processor Family\n29 = AMD(R) Duron(TM) Processor\n30 = AMD29000 Family\n31 = K6-2+\n32 = Power PC Family\n33 = Power PC 601\n34 = Power PC 603\n35 = Power PC 603+\n36 = Power PC 604\n37 = Power PC 620\n38 = Power PC X704\n39 = Power PC 750\n48 = Alpha Family\n49 = Alpha 21064\n50 = Alpha 21066\n51 = Alpha 21164\n52 = Alpha 21164PC\n53 = Alpha 21164a\n54 = Alpha 21264\n55 = Alpha 21364\n64 = MIPS Family\n65 = MIPS R4000\n66 = MIPS R4200\n67 = MIPS R4400\n68 = MIPS R4600\n69 = MIPS R10000\n80 = SPARC Family\n81 = SuperSPARC\n82 = microSPARC II\n83 = microSPARC IIep\n84 = UltraSPARC\n85 = UltraSPARC II\n86 = UltraSPARC IIi\n87 = UltraSPARC III\n88 = UltraSPARC IIIi\n96 = 68040\n97 = 68xxx Family\n98 = 68000\n99 = 68010\n100 = 68020\n101 = 68030\n112 = Hobbit Family\n120 = Crusoe(TM) TM5000 Family\n121 = Crusoe(TM) TM3000 Family\n122 = Efficeon(TM) TM8000 Family\n128 = Weitek\n130 = Itanium(TM) Processor\n131 = AMD Athlon(TM) 64 Processor Family\n132 = AMD Opteron(TM) Family\n144 = PA-RISC Family\n145 = PA-RISC 8500\n146 = PA-RISC 8000\n147 = PA-RISC 7300LC\n148 = PA-RISC 7200\n149 = PA-RISC 7100LC\n150 = PA-RISC 7100\n160 = V30 Family\n176 = Pentium(R) III Xeon(TM)\n177 = Pentium(R) III Processor with Intel(R) SpeedStep(TM) Technology\n178 = Pentium(R) 4\n179 = Intel(R) Xeon(TM)\n180 = AS400 Family\n181 = Intel(R) Xeon(TM) processor MP\n182 = AMD AthlonXP(TM) Family\n183 = AMD AthlonMP(TM) Family\n184 = Intel(R) Itanium(R) 2\n185 = Intel Pentium M Processor\n190 = K7\n200 = IBM390 Family\n201 = G4\n202 = G5\n203 = G6\n204 = z/Architecture base\n250 = i860\n251 = i960\n260 = SH-3\n261 = SH-4\n280 = ARM\n281 = StrongARM\n300 = 6x86\n301 = MediaGX\n302 = MII\n320 = WinChip\n350 = DSP\n500 = Video Processor\n</code></pre>\n\n<p>Пробовал также на другом ПК:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Caption = AMD64 Family 21 Model 56 Stepping 1\nFamily = 72\n\n...\n</code></pre>\n\n<p>На MSDN приведено описание стандартных квалификаторов <a href=\"https://msdn.microsoft.com/en-us/library/aa393650(v=vs.85).aspx\" rel=\"nofollow noreferrer\">Standard Qualifiers</a>:</p>\n\n<blockquote>\n  <p><strong>ValueMap</strong><br>\n  This qualifier can be used alone or in combination with the Values qualifier. When used in combination with the Values qualifier, the location of the value in the ValueMap array provides the location of the corresponding entry in the Values array. Use the ValueMap qualifier only with string and integer values. The syntax for representing an integer value in the value map array is [+|=]digit[*digit]. The content, maximum number of digits, and represented value are constrained by the type of the associated property. For example, uint8 may not be signed, must be less than four digits, and must represent a value less than 256.<br>\n  <br>\n  <strong>Values</strong><br>\n  This property also specifies an array of string values to be mapped to an enumeration property. This qualifier can be applied to either an integer property or a string property, and the mapping can be implicit or explicit. If the mapping is implicit, integer or string property values represent ordinal positions in the Values array. If the mapping is explicit, the property must be an integer, and valid property values are listed in the array defined by the ValueMap qualifier. For more information, see Value Map.<br>\n  If a ValueMap qualifier is not present, the Values array is indexed (zero-relative) by using the value in the associated property, method return type, or method parameter. If a ValueMap qualifier is present, the values index is defined by the location of the property value in the value map.<br></p>\n</blockquote>\n\n<p>В двух словах там сказано, что если в свойстве присутствуют оба квалификатора, то массив <code>ValueMap</code> содержит все допустимые значения свойства, и позиция в нем элемента, равного значению свойства, определяет позицию соответствующего ему строкового значения в массиве <code>Values</code>, а если присутствует только квалификатор <code>Values</code>, то значение свойства является целочисленным индексом и определяет позицию соответствующего строкового значения в этом массиве.</p>\n\n<p>Проблема заключается в получении надлежащего строкового значения, поскольку квалификатор <code>ValueMap</code> не содержит ни значения <code>198</code>, ни <code>72</code>.</p>\n"}