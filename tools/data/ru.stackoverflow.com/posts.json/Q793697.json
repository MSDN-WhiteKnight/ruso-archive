{"tags":["windows","c++-cli","аудио","звукозапись"],"owner":{"reputation":1415,"user_id":238013,"user_type":"registered","accept_rate":64,"profile_image":"https://www.gravatar.com/avatar/d4dab84aa4c67525aecd5da391a8e68a?s=128&d=identicon&r=PG&f=1","display_name":"D .Stark","link":"https://ru.stackoverflow.com/users/238013/d-stark"},"is_answered":true,"view_count":218,"accepted_answer_id":794133,"answer_count":1,"score":1,"last_activity_date":1521653764,"creation_date":1520228343,"last_edit_date":1520314241,"question_id":793697,"link":"https://ru.stackoverflow.com/questions/793697/wasapi-%d0%97%d0%b0%d0%bf%d0%b8%d1%81%d1%8c-%d0%b7%d0%b2%d1%83%d0%ba%d0%b0","title":"WASAPI Запись звука","body":"<p>В результате записи получается полная ерунда. В чём ошибка?</p>\n\n<pre><code>#include \"stdafx.h\"\n#include \"iostream\"\n#include \"windows.h\"\n#include \"mmdeviceapi.h\"\n#include \"audioclient.h\"\n\n#pragma comment(lib, \"ole32.lib\")\n\nusing namespace System;\nusing namespace System::Collections::Generic;\n\n#define REFTIMES_PER_SEC  10000000\n#define REFTIMES_PER_MILLISEC  10000\n\n#define EXIT_ON_ERROR(hres)     if (FAILED(hres)) { goto Exit; }\n#define SAFE_RELEASE(punk)      if ((punk) != NULL) { (punk)-&gt;Release(); (punk) = NULL; }\n\nconst CLSID CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);\nconst IID IID_IMMDeviceEnumerator = __uuidof(IMMDeviceEnumerator);\nconst IID IID_IAudioClient = __uuidof(IAudioClient);\nconst IID IID_IAudioCaptureClient = __uuidof(IAudioCaptureClient);\n\nList&lt;BYTE&gt;^ RecordAudioStream() {\n\n    HRESULT hr;\n\n    REFERENCE_TIME hnsRequestedDuration = REFTIMES_PER_SEC;\n    REFERENCE_TIME hnsActualDuration;\n    UINT32 bufferFrameCount;\n    UINT32 numFramesAvailable;\n    UINT32 packetLength = 0;\n    BYTE *pData;\n    List&lt;BYTE&gt;^ buf = gcnew List&lt;BYTE&gt;();\n    DWORD flags;\n    WAVEFORMATEX *pwfx = NULL;\n\n    IMMDeviceEnumerator *pEnumerator = NULL;\n    IMMDevice *pDevice = NULL;\n    IAudioClient *pAudioClient = NULL;\n    IAudioCaptureClient *pCaptureClient = NULL;\n\n    // Get default audio device IMMDevice object.\n\n    hr = CoCreateInstance(CLSID_MMDeviceEnumerator,\n        NULL, CLSCTX_ALL,\n        IID_IMMDeviceEnumerator,\n        (void**)&amp;pEnumerator);\n    EXIT_ON_ERROR(hr);\n\n    hr = pEnumerator-&gt;GetDefaultAudioEndpoint(eCapture, eConsole, &amp;pDevice);\n    EXIT_ON_ERROR(hr);\n\n    hr = pDevice-&gt;Activate(IID_IAudioClient,\n        CLSCTX_ALL, NULL,\n        (void**)&amp;pAudioClient);\n    EXIT_ON_ERROR(hr);\n\n    hr = pAudioClient-&gt;GetMixFormat(&amp;pwfx);\n    EXIT_ON_ERROR(hr);\n\n    // Create audio client object.\n\n    hr = pAudioClient-&gt;Initialize(AUDCLNT_SHAREMODE_SHARED, 0, hnsRequestedDuration, 0, pwfx, NULL);\n    EXIT_ON_ERROR(hr);\n\n    // Get the size of the allocated buffer.\n    hr = pAudioClient-&gt;GetBufferSize(&amp;bufferFrameCount);\n    EXIT_ON_ERROR(hr);\n\n    hr = pAudioClient-&gt;GetService(IID_IAudioCaptureClient, (void**)&amp;pCaptureClient);\n    EXIT_ON_ERROR(hr);\n\n    Console::WriteLine(\"Used format:\\nChannels: {0}\\nFreq: {1}\\nSample bits: {2}\", pwfx-&gt;nChannels, pwfx-&gt;nSamplesPerSec, pwfx-&gt;wBitsPerSample);\n\n    // Calculate the actual duration of the allocated buffer.\n    hnsActualDuration = (double)REFTIMES_PER_SEC * bufferFrameCount / pwfx-&gt;nSamplesPerSec;\n\n    hr = pAudioClient-&gt;Start(); // Start recording.\n    EXIT_ON_ERROR(hr);\n\n    // 4 sec recording.\n    System::Diagnostics::Stopwatch^ s = gcnew System::Diagnostics::Stopwatch();\n    s-&gt;Start();\n\n    // Each loop fills about half of the shared buffer.\n    while (s-&gt;ElapsedMilliseconds &lt; 4000)\n    {\n        // Sleep for half the buffer duration.\n        Sleep(hnsActualDuration / REFTIMES_PER_MILLISEC / 2);\n\n        hr = pCaptureClient-&gt;GetNextPacketSize(&amp;packetLength);\n        EXIT_ON_ERROR(hr);\n\n        while (packetLength != 0)\n        {\n            // Get the available data in the shared buffer.\n            hr = pCaptureClient-&gt;GetBuffer(&amp;pData, &amp;numFramesAvailable, &amp;flags, NULL, NULL);\n            EXIT_ON_ERROR(hr);\n\n            if (flags &amp; AUDCLNT_BUFFERFLAGS_SILENT)\n            {\n                pData = NULL; // Tell CopyData to write silence.\n            }\n            else\n            {\n                // Copy the available capture data.\n                for (int i = 0; i &lt; packetLength; i++)\n                    buf-&gt;Add(*(pData + i));\n            }\n\n            hr = pCaptureClient-&gt;ReleaseBuffer(numFramesAvailable);\n            EXIT_ON_ERROR(hr);\n\n            hr = pCaptureClient-&gt;GetNextPacketSize(&amp;packetLength);\n            EXIT_ON_ERROR(hr);\n        }\n    }\n\n    hr = pAudioClient-&gt;Stop(); // Stop recording.\n\nExit:\n    CoTaskMemFree(pwfx);\n    SAFE_RELEASE(pEnumerator);\n    SAFE_RELEASE(pDevice);\n    SAFE_RELEASE(pAudioClient);\n    SAFE_RELEASE(pCaptureClient);\n    SAFE_RELEASE(pRenderClient);\n\n    return buf;\n}\n</code></pre>\n\n<p><a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/dd370800(v=vs.85).aspx\" rel=\"nofollow noreferrer\">Capturing a Stream (Windows)</a></p>\n\n<hr>\n\n<p>Тестовое воспроизведение в NAudio:</p>\n\n<pre><code>WaveOut^ waveOut = gcnew WaveOut();\nwaveOut-&gt;DeviceNumber = 0;\nwaveOut-&gt;Init(gcnew RawSourceWaveStream(buf-&gt;ToArray(), 0, buf-&gt;Count, gcnew WaveFormat(44100, 32, 2)));\nSystem::Threading::ThreadStart^ thStart = gcnew System::Threading::ThreadStart(waveOut, &amp;WaveOut::Play);\n(gcnew System::Threading::Thread(thStart))-&gt;Start();\n</code></pre>\n"}