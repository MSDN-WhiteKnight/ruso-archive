{"tags":["c#"],"owner":{"reputation":1421,"user_id":302509,"user_type":"registered","profile_image":"https://lh6.googleusercontent.com/-x8QmbIo9LI8/AAAAAAAAAAI/AAAAAAAAAAA/AB6qoq3KC2lIH0PmFSEV1qACEI-wMEAPYw/mo/photo.jpg?sz=128","display_name":"Vladimr Vladimirovoch","link":"https://ru.stackoverflow.com/users/302509/vladimr-vladimirovoch"},"is_answered":true,"view_count":62,"accepted_answer_id":872861,"answer_count":1,"score":1,"last_activity_date":1535102344,"creation_date":1535098269,"last_edit_date":1535101692,"question_id":872846,"link":"https://ru.stackoverflow.com/questions/872846/%d0%9a%d0%b0%d0%ba-%d0%bf%d1%80%d0%b0%d0%b2%d0%b8%d0%bb%d1%8c%d0%bd%d0%be-%d0%bf%d0%be%d0%bb%d1%83%d1%87%d0%b8%d1%82%d1%8c-%d0%b7%d0%bd%d0%b0%d1%87%d0%b5%d0%bd%d0%b8%d0%b5-%d0%bf%d1%83%d1%82%d0%b8-%d0%b4%d0%bb%d1%8f-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d0%bd%d1%8f%d0%b5%d0%bc%d0%be%d0%b3%d0%be-%d1%84%d0%b0%d0%b9%d0%bb%d0%b0","title":"Как правильно получить значение пути для исполняемого файла","body":"<p>Как правильно отделить путь к исполняемому файлу от аргументов командной строки, не могу обойти ошибку. Суть, есть метод, который достает все запускаемые файлы из реестра,(из определенной ветки) У меня Win 64  и в сборке проекта я убрал галочку предпочтительно 32 разрядная, в надежде чтобы все работало хорошо и для 32 и для 64 разрядов. И теперь когда я через linq достаю имена и пути  к файлу, то получается ошибка FileNotFoundException, так как вместо пути возвращается строка вида <code>\"rundll32.exe xrWCbgnd.dll,LaunchBgTask 1\"</code>.  Вот мой код.</p>\n\n<pre><code>  public  List&lt;info&gt; PrintKeys(string rkey)\n            {\n\n\n                    List&lt;info&gt; stroka=new List&lt;info&gt;();\n                    string F = \"Цифровая подпись найдена \";\n                    string G = \"Цифровая подпись корректна\";\n                    string G0 = \"Цифровая подпись не корректна\";\n                    string tipzapuska = \"Реестр\";\n                    String rp = rkey;\n                    RegistryKey rk;\n                    X509Certificate2 theCertificate;\n                    using (rk = Registry.LocalMachine.OpenSubKey(rp))\n                    {\n\n\n                        var e = rk.GetValueNames().Select(n =&gt; new\n                        {\n                            Name = n,\n                            Value = rk.GetValue(n),\n                            Exec = rk.GetValue(n).ToString()\n                                .Split('\"').Where(i =&gt; !String.IsNullOrEmpty(i)).First()\n                        });\n                        foreach (var x in e)\n                        {\n\n                            string path = x.Exec;\n                            var ext = Path.GetExtension(path).Split(' ')[0];\n                            var file = path.Substring(0, path.IndexOf(ext) + ext.Length);\n\n\n\n\n                            var icon1 = Icon.ExtractAssociatedIcon(file).ToBitmap();\n                            try\n                            {\n                            X509Certificate theSigner = X509Certificate.CreateFromSignedFile(x.Exec);\n                            theCertificate = new X509Certificate2(theSigner);\n                             // проверяем на валидность\n                            byte[] mashash =theCertificate.GetCertHash();// хеш из сертификата файла в sha1\n                            byte[] fileSha1 = GetSha1Hash(x.Exec);// получаем хеш файла в sha1\n\n                                // сравниваем два массива\n\n                            bool bEqual = false;\n                            if (fileSha1.Length == mashash.Length)\n                            {\n                                int i = 0;\n                                while ((i &lt; fileSha1.Length) &amp;&amp; (fileSha1[i] == mashash[i]))\n                                {\n                                    i += 1;\n                                }\n                                if (i == fileSha1.Length)\n                                {\n                                    bEqual = true;\n                                }\n                            }\n\n\n\n                                // готовим строку\n                                if (bEqual)\n                                {\n                                    stroka.Add(new info() { A = icon1, F1 = F, G1 = G, Namefile1 = x.Name, Path1 = (string) x.Value, Company = theCertificate.Issuer,TipZapuska = tipzapuska});  \n                                }\n    //                           \n                                stroka.Add(new info() { A = icon1, F1 = F, G1 = G0, Namefile1 = x.Name, Path1 = (string) x.Value, Company = theCertificate.Issuer, TipZapuska = tipzapuska});  \n\n\n\n                            }\n                            catch (Exception exception)\n                            {\n\n                                stroka.Add(new info() { A = icon1, F1 = \"Цифровая подпись отсутсвует\", G1 = \"Цифровая подпись отсутсвует\", Namefile1 = x.Name, Path1 = (string)x.Value, TipZapuska = tipzapuska });\n                            }\n\n\n\n                        }\n                    }\n                    return stroka;\n                } // local mashin\n\n public class info\n    {\n        public Bitmap A { get; set; } // иконка файла\n        public string Namefile1 { get; set; } //Имя исполняемого файла.\n        public string C1 { get; set; } //Параметры командной строки для запуска файла.\n        public string Path1 { get; set; }// путь\n        public string F1 { get; set; }//Флаг наличия цифровой подписи.\n        public string G1 { get; set; }//Флаг корректности цифровой подписи\n        public string Company { get; set; }//Информация о компании\n        public string TipZapuska { get; set; }\n\n\n        public info()\n        {\n\n\n        }\n\n\n    }\n   public byte[] GetSha1Hash(string filePath)\n        {\n            using (FileStream fs = File.OpenRead(filePath))\n            {\n                SHA1 sha = new SHA1Managed();\n                return sha.ComputeHash(fs).ToArray();\n            }\n        }\n</code></pre>\n"}