{"owner":{"reputation":187498,"user_id":10105,"user_type":"registered","accept_rate":73,"profile_image":"https://i.stack.imgur.com/d8Z7F.png?s=128&g=1","display_name":"VladD","link":"https://ru.stackoverflow.com/users/10105/vladd"},"is_accepted":false,"score":14,"last_activity_date":1533674383,"last_edit_date":1533674383,"creation_date":1533673740,"answer_id":865724,"question_id":865721,"body":"<p>Согласно <a href=\"https://docs.microsoft.com/ru-ru/dotnet/api/system.math.pow?view=netframework-4.7.1#remarks\" rel=\"noreferrer\">документации</a>, при конечном отрицательном основании и конечном нецелом показателе результат равен <code>NaN</code>. Это значит, что <code>Math.Pow</code> ведёт себя не совсем так, как стандартная математическая степень, и вам придётся самим обрабатывать случай отрицательного основания.</p>\n\n<hr>\n\n<p>Почему так сделано? Думаю, потому, что дроби наподобие 1/3 нельзя представить точно значением типа <code>double</code>. Поскольку в случае чётного знаменателя результат получается комплексным, мы видим, что малая ошибка в показатели степени ведёт к большой ошибке в результате. Поэтому разумным было бы просто не пытаться подсчитать результат для таких вот случаев.</p>\n\n<hr>\n\n<p>Хорошо, а как решать задачу по извлечению корня целой степени? Ну просто анализируйте знак.</p>\n\n<pre><code>int rootpower = 3;\ndouble value = -8;\n\nint sign = Math.Sign(value);\ndouble absRoot = Math.Pow(Math.Abs(value), 1.0/rootpower);\n\nif (rootpower % 2 == 0 &amp;&amp; sign == -1)\n{\n    Complex root = Complex.ImaginaryOne * absRoot;\n    // результат комплексный, работайте с ним\n}\nelse\n{\n    double root = sign * absRoot;\n    // результат действительный, работайте с ним\n}\n</code></pre>\n"}