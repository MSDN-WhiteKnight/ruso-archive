{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":3,"last_activity_date":1552301161,"last_edit_date":1552301161,"creation_date":1552283842,"answer_id":954876,"question_id":954674,"body":"<p>Со строками национальных алфавитов можно работать как с многобайтовыми (UTF8) или как со строками широких символов.</p>\n\n<p>При использовании UTF8 каждый символ строки занимает переменное число байтов, поэтому работать со строкой как с массивом символов нельзя! Для доступа к отдельным символам надо проходить по всей строке, получая длину каждого символа функцией mbrlen:</p>\n\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;wchar.h&gt;\n#include &lt;locale.h&gt;\n\nint mbcompare(const char* pStr, int index, const char* pMatch)\n{   \n    mbstate_t mbs = { 0 };  \n    int len = 0;\n    int i = 0;\n\n    const char* pEnd = pStr + strlen(pStr);\n    mbrlen(NULL, 0, &amp;mbs);\n\n    while ((len = mbrlen(pStr, pEnd - pStr, &amp;mbs)) &gt; 0)\n    {\n        if (i == index) {\n            return strncmp(pStr, pMatch, len) == 0;\n        }\n        pStr += len;\n        i++;\n    }\n    return 0;\n}\n\nvoid mbprint(const char* pStr)\n{\n    mbstate_t mbs = { 0 };\n    int len = 0;\n    int i = 0;\n    char buf[6];\n\n    const char* pEnd = pStr + strlen(pStr);\n    mbrlen(NULL, 0, &amp;mbs);\n\n    while ((len = mbrlen(pStr, pEnd - pStr, &amp;mbs)) &gt; 0)\n    {\n\n        strncpy_s(buf,sizeof(buf), pStr, len);\n        printf(u8\"%2d: %s (%d байт)\\n\", i,buf,len);\n\n        pStr += len;\n        i++;\n    }   \n}\n\nint main()\n{\n    setlocale(LC_ALL, \"ru_RU.utf8\");    \n\n    char str[] = u8\"Привет Мир!\";   \n    mbprint(str);\n\n    if (mbcompare(str, 1, u8\"р\")) printf(u8\"Символ 1 == [р]\\n\");\n    else printf(u8\"Символ 1 != [р]\\n\");\n\n    getchar();\n}\n\n/* Вывод:\n\n 0: П (2 байт)\n 1: р (2 байт)\n 2: и (2 байт)\n 3: в (2 байт)\n 4: е (2 байт)\n 5: т (2 байт)\n 6:   (1 байт)\n 7: М (2 байт)\n 8: и (2 байт)\n 9: р (2 байт)\n10: ! (1 байт)\nСимвол 1 == [р]\n*/\n</code></pre>\n\n<p>Выглядит не очень удобно? Возможно, проще будет использовать широкие символы:</p>\n\n<pre><code>setlocale(LC_ALL, \"ru_RU\");\nwchar_t str[] = L\"Привет Мир!\";\n\nint c = wcslen(str);\nfor (int i = 0; i &lt; c; i++) {\n    wprintf(L\"%2d: %lc\\n\", i, str[i]);\n}\n\nif (str[1]==L'р') wprintf(L\"Символ 1 == [р]\\n\");\nelse wprintf(L\"Символ 1 != [р]\\n\\n\"); \n</code></pre>\n"}