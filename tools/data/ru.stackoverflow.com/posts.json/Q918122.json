{"tags":["c#","roslyn"],"owner":{"reputation":3657,"user_id":222188,"user_type":"registered","accept_rate":95,"profile_image":"https://i.stack.imgur.com/3FpZd.jpg?s=128&g=1","display_name":"trydex","link":"https://ru.stackoverflow.com/users/222188/trydex"},"is_answered":true,"view_count":144,"accepted_answer_id":918327,"answer_count":1,"score":3,"last_activity_date":1554117024,"creation_date":1544464108,"last_edit_date":1544481541,"question_id":918122,"link":"https://ru.stackoverflow.com/questions/918122/%d0%9a%d0%b0%d0%ba-%d0%b2-roslyn-%d0%b2%d1%8b%d0%bf%d0%be%d0%bb%d0%bd%d0%b8%d1%82%d1%8c-%d0%ba%d0%be%d0%b4-%d1%81-%d1%82%d0%be%d1%87%d0%ba%d0%b8-%d0%b2%d1%85%d0%be%d0%b4%d0%b0","title":"Как в Roslyn выполнить код с точки входа","body":"<p>Нужно сделать, чтобы пользователь мог выполнять C#-код на моем сервере (что-то вроде <a href=\"http://dotnetfiddle.net\" rel=\"nofollow noreferrer\">dotnetfiddle.net</a>). Приложение Asp.net Core.</p>\n\n<p>Есть такой метод, который вполне нормально работает:</p>\n\n<pre><code>public static async Task&lt;ScriptState&lt;object&gt;&gt; ExecuteScriptAsync(string code, IEnumerable&lt;Assembly&gt; references,\n    IEnumerable&lt;string&gt; usings)\n{\n    var options = ScriptOptions.Default.WithReferences(references).WithImports(usings);\n\n    return await CSharpScript.RunAsync(code, options);\n}\n</code></pre>\n\n<p>Проблема метода <code>ExecuteScript</code> в том, что такой код он уже не будет выполнять: </p>\n\n<pre><code>class Program \n{\n    public static void Main() \n    {\n        throw new System.Exception();   \n    }\n}\n</code></pre>\n\n<p>Как сделать чтобы код выполнялся как в консольном приложении, т.е. метод <code>Main</code> был точкой входа?\n<hr>\n<strong>Update</strong></p>\n\n<p>Нашел такой код. Срабатывает, но если в скрипт дописать <code>Console.WriteLine(\"hi\")</code>, то он ломается с ошибкой \"Имя <code>Console</code> не существует в текущем контексте\". </p>\n\n<pre><code>var script = @\"using System;\n                public static class Program\n                {\n                    public static int Main(string[] args)\n                    {\n                        var x = 7 * 8;\n                        return x;\n                    }\n                }\";\n\nvar assemblyPath = Path.GetDirectoryName(typeof(object).Assembly.Location);\nvar refs = new List&lt;PortableExecutableReference&gt;\n{\n    MetadataReference.CreateFromFile(typeof(object).Assembly.Location),\n    MetadataReference.CreateFromFile(Path.Combine(assemblyPath, \"mscorlib.dll\")),\n    MetadataReference.CreateFromFile(Path.Combine(assemblyPath, \"System.dll\")),\n    MetadataReference.CreateFromFile(Path.Combine(assemblyPath, \"System.Core.dll\")),\n    MetadataReference.CreateFromFile(Path.Combine(assemblyPath, \"System.Runtime.dll\")),\n    MetadataReference.CreateFromFile(Assembly.GetEntryAssembly().Location)\n};\n\n// Parse the script to a SyntaxTree\nvar syntaxTree = CSharpSyntaxTree.ParseText(script);\nvar options = new CSharpCompilationOptions(OutputKind.ConsoleApplication);\n// Compile the SyntaxTree to a CSharpCompilation\nvar compilation = CSharpCompilation.Create(\"Script\",\n    new[] { syntaxTree },\n    refs,\n    new CSharpCompilationOptions(\n        OutputKind.ConsoleApplication,\n        optimizationLevel: OptimizationLevel.Release,\n        assemblyIdentityComparer: DesktopAssemblyIdentityComparer.Default));\n\n//CodeDomProvider codeDomProvider = new CodeDomProvider();\nusing (var outputStream = new MemoryStream())\nusing (var pdbStream = new MemoryStream())\n{\n    // Emit assembly to streams.\n    var result = compilation.Emit(outputStream, pdbStream);\n    if (!result.Success)\n    {\n        return;\n    }\n\n    // Load the emitted assembly.\n    var assembly = Assembly.Load(outputStream.ToArray(), pdbStream.ToArray());\n\n    // Invoke the entry point.\n    var x = assembly.EntryPoint.Invoke(null, null);\n</code></pre>\n"}