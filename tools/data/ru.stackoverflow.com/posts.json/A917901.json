{"owner":{"reputation":16137,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":1,"last_activity_date":1544436226,"creation_date":1544436226,"answer_id":917901,"question_id":914156,"body":"<p>Директива <code>#define</code> сама по себе осуществляет только текстовую подстановку, но не предвычисление выражений с константами. То есть, если исправить объявление PRIMERF на корректное (у вас пропущена запятая):</p>\n\n<pre><code>#define PRIMERF(V1,V2) (V1+2)*(V2+2)\n</code></pre>\n\n<p>, то на этапе обработки препроцессором <code>PRIMERF(2,3)</code> превратится в <code>(2+2)*(3+2)</code>.</p>\n\n<p>Предвычисление константного выражения может быть выполнено на этапе компиляции, но это не гарантируется. Скажем, Visual C++ выполняет его, в том числе и при отключенной оптимизации:</p>\n\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define PRIMERP 315\n#define PRIMERF(V1,V2)(V1+2)*(V2+2)\n\nint main(int argc, char **argv)\n{   \n    int i = PRIMERP;\n    int j = PRIMERF(2,3);\n    printf(\"%d %d\",i,j);\n    ;\n\n    getchar();\n    return 0;\n}\n\n/* Disassembly:\n\n_main:\n push        ebp  \n mov         ebp,esp  \n sub         esp,8  \n push        esi  \n mov         dword ptr [j],0CCCCCCCCh  \n mov         dword ptr [i],0CCCCCCCCh  \n mov         dword ptr [i],13Bh           // int i = PRIMERP;\n mov         dword ptr [j],14h            // int j = PRIMERF(2,3);\n mov         esi,esp  \n mov         eax,dword ptr [j]  \n push        eax  \n mov         ecx,dword ptr [i]  \n push        ecx  \n push        0F05858h  \n call        dword ptr ds:[0F092C0h]  // printf(\"%d %d\",i,j);\n add         esp,0Ch  \n cmp         esi,esp  \n call        _RTC_CheckEsp (0F01220h)  \n mov         esi,esp  \n call        dword ptr ds:[0F092C8h]  // getchar();\n cmp         esi,esp  \n call        _RTC_CheckEsp (0F01220h)  \n xor         eax,eax  \n pop         esi  \n add         esp,8  \n cmp         ebp,esp  \n call        _RTC_CheckEsp (0F01220h)  \n mov         esp,ebp  \n pop         ebp  \n ret  \n*/\n</code></pre>\n\n<p>14h - это предвычисленное значение выражения (20 в шестнадцатеричном виде)</p>\n"}