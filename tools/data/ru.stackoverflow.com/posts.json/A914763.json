{"owner":{"reputation":1234,"user_id":267609,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/cbcf8c969e4c9a3a678823bd8fc081a2?s=128&d=identicon&r=PG&f=1","display_name":"ffk","link":"https://ru.stackoverflow.com/users/267609/ffk"},"is_accepted":false,"score":2,"last_activity_date":1543816936,"creation_date":1543816936,"answer_id":914763,"question_id":914740,"body":"<p>Чтоб работать с бинарной сереализацией надо гарантировать, что C++, будет генерить одинаковую структуру при любых опциях компиляции. По умолчанию, размер структуры не обязан совпадать с суммой размеров всех полей, т.к. все поля структуры выравниваются по своему размеру. Например, <code>int16_t</code> поле должно лежать по смещению кратному 2, <code>int32_t</code> - кратно 4 и т.д.</p>\n\n<p>В твоем примере поля engine_enabled и trailer_attached имеют тип bool, что занимает по байту каждое, а вот поле speed имеет размер 4 байта и компилятор попытается его разместить со смещение 4 от начала структуры <code>tel_rev1</code>, т.е между двумя булами и флоатом будет дополнительная дырка в 2 байта.</p>\n\n<p>Далее, типа int и long в разных архитектурах могут иметь разный размер, что нормально сериализоваться, замени их типы фиксированного размера, например, <code>int32_t</code></p>\n\n<p>Далее, чтоб быть уверенным что структура \"не поплыла\", надо вставить <code>static_assert</code> с проверкой размеров и смещений. Типа такого:</p>\n\n<pre><code>typedef struct ets2TelemetryMap_s\n{\n    ...\n};\nstatic_assert(sizeof(ets2TelemetryMap_s) == 1024, \"error\"); // И сколько там должно быть?\nstatic_assert(sizeof(ets2TelemetryMap_s::tel_revId) == 12, \"error\");\n..\nstatic_assert(sizeof(ets2TelemetryMap_s::tel_rev4) == 152, \"error\");\nstatic_assert(offsetof(ets2TelemetryMap_s::tel_revId) == 8, \"error\") // &lt;-- проверяем что ключевые поля лежат по правильным смещениям\n...\nstatic_assert(offsetof(ets2TelemetryMap_s, tel_rev5.jobFinished) == 1021, \"error\")\n</code></pre>\n\n<p>После это, можно использовать бинарную сереализацию, про big-endian и litle-endian не забываем.</p>\n\n<p>P.S. #pragma pack(1) не советую, дурная практика для данной затеии. IMHO</p>\n"}