{"owner":{"reputation":187498,"user_id":10105,"user_type":"registered","accept_rate":73,"profile_image":"https://i.stack.imgur.com/d8Z7F.png?s=128&g=1","display_name":"VladD","link":"https://ru.stackoverflow.com/users/10105/vladd"},"is_accepted":true,"score":14,"last_activity_date":1523005950,"last_edit_date":1523005950,"creation_date":1522936994,"answer_id":810044,"question_id":809884,"body":"<p>Смотрите, у вас на самом деле довольно сложное задание. Но в современном C# есть инструменты, которые облегчат вам его. Например, вы можете воспользоваться Roslyn API.</p>\n\n<p>Давайте напишем простой пример, на основе которого вы сможете добавлять нужную функциональность.</p>\n\n<p>Итак, для начала создадим консольный проект на C#, назовём его HelloWorld, и положим туда такой вот код:</p>\n\n<pre><code>using System;\n\nnamespace HelloWorld\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] strings = { \"Hello \", \"world\" };\n            foreach (var s in strings)\n                Console.Write(s);\n            Console.WriteLine();\n        }\n    }\n}\n</code></pre>\n\n<p>Этот проект мы будем использовать как тестовый для нашего анализатора.\nЦелью нашего анализатора будет найти, что переменная <code>s</code> на самом деле имеет тип <code>string</code>.</p>\n\n<p>Создадим проект самого анализатора. Для этого поставьте Roslyn SDK через Visual Studio Installer:</p>\n\n<p><a href=\"https://i.stack.imgur.com/VFKgv.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/VFKgv.png\" alt=\"Roslyn SDK, без него никак в нашем мире\"></a></p>\n\n<p>Теперь, в Visual Studio появится проект типа «Stand-Alone Code Analysis Tool». Создаём его.</p>\n\n<p><a href=\"https://i.stack.imgur.com/iMgoR.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/iMgoR.png\" alt=\"и проект тоже я сломал?\"></a></p>\n\n<p>Затем, зайдём в Dependencies → Manage NuGet Packages, обязательно обновим пакеты до последней версии и доустановим Microsoft.Tpl.DataFlow (без него у меня не работает, и это, кажется, известный баг).</p>\n\n<p><a href=\"https://i.stack.imgur.com/w0xOV.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/w0xOV.png\" alt=\"Отака фигня, малята\"></a></p>\n\n<p>Теперь, собственно наш анализатор.</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.MSBuild;\nusing Microsoft.CodeAnalysis.Text;\n\nnamespace CodeAnalyzer\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var workspace = MSBuildWorkspace.Create();\n            // подправьте путь на путь к вашему solution'у\n            var solution = await workspace.OpenSolutionAsync(@\"D:\\HelloWorld.sln\");\n            // у нас только один проект\n            var project = solution.Projects.Single();\n            var compilation = await project.GetCompilationAsync();\n\n            // для каждого из файлов в проекте у нас отдельное синтаксическое дерево\n            // даже в пустом проекте их несколько, например, AssemblyInfo.cs\n            foreach (var syntaxTree in compilation.SyntaxTrees)\n            {\n                var root = await syntaxTree.GetRootAsync();\n                // создаём семантический анализатор\n                var model = compilation.GetSemanticModel(syntaxTree);\n                // получаем все типы переменных\n                foreach (var type in GetVariableTypes(root))\n                {\n                    // спрашиваем у анализатора, что это за тип\n                    var typeSymbol = (ITypeSymbol)model.GetSymbolInfo(type).Symbol;\n                    // проверяем, не строка ли это\n                    if (typeSymbol.Name == \"String\" &amp;&amp;\n                        typeSymbol.ContainingNamespace?.Name == \"System\" &amp;&amp;\n                        typeSymbol.ContainingAssembly?.Name == \"mscorlib\")\n                    {\n                        // если да, выдаём положение этой строки в исходниках\n                        var position = type.GetLocation().GetLineSpan();\n                        Console.WriteLine($\"String is used, location = {position}\");\n                    }\n                }\n            }\n        }\n\n        // этот вспомогательный метод получает типы всех локальных переменных\n        static IEnumerable&lt;TypeSyntax&gt; GetVariableTypes(SyntaxNode root)\n        {\n            // получаем декларации переменных\n            var localVariableTypes =\n                    root.DescendantNodes()\n                        .OfType&lt;VariableDeclarationSyntax&gt;()\n                        .Select(decl =&gt; decl.Type);\n            // не забываем foreach, он почему-то отдельно\n            var foreachVariableTypes =\n                    root.DescendantNodes()\n                        .OfType&lt;ForEachStatementSyntax&gt;()\n                        .Select(decl =&gt; decl.Type);\n            return localVariableTypes.Concat(foreachVariableTypes);\n        }\n    }\n}\n</code></pre>\n\n<p>Запускаем на нашем тестовом проекте, получаем:</p>\n\n<blockquote>\n<pre><code>String is used, location = D:\\HelloWorld\\Program.cs: (9,21)-(9,24)\n</code></pre>\n</blockquote>\n\n<p>Литература:</p>\n\n<ul>\n<li><a href=\"https://github.com/dotnet/roslyn/wiki/Getting-Started-C%23-Semantic-Analysis\" rel=\"nofollow noreferrer\">Документация на семантический анализ Roslyn</a>.</li>\n<li><a href=\"https://sharplab.io/#v2:EYLgtghgzgLgpgJwDQxNGAfAAgBgARYCMA3ALABQFAdhGHFAA4QDGceAEnADZcD2A6rwRcAJhQDeFPNIIAmAoQDsUmZPIyNCgGwEALAoAcACiI4A2gF08EBAHMoAShWa8aly9OWFOKHgC8rngARJw8vMFIwQDuQqJBeAC+ZOruGgBmQnAsABZ4RgBuNni+AJZU3o7OqZoAwrxUULxccAB0/Agl8EaOydUyRACcRg697glV4+QJQA\" rel=\"nofollow noreferrer\">А здесь можно посмотреть синтаксическое дерево</a>.</li>\n</ul>\n\n<hr>\n\n<p>Небольшое дополнение. Вы не можете узнать, какие типы используются в классе, по одному только тексту файла. Например, если у вас в соседнем файле есть такое определение:</p>\n\n<pre><code>namespace HelloWorld\n{\n    struct String\n    {\n        public static implicit operator String(System.String s) =&gt; default;\n    }\n}\n</code></pre>\n\n<p>то ваш код</p>\n\n<pre><code>String s = \"\";\nConsole.WriteLine(s.GetType());\n</code></pre>\n\n<p>выдаст не <code>System.String</code>, а <code>HelloWorld.String</code>. Именно поэтому для правильного анализа нужен не текст, а весь проект.</p>\n"}