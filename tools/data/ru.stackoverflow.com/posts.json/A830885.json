{"owner":{"reputation":16068,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":0,"last_activity_date":1526879364,"creation_date":1526879364,"answer_id":830885,"question_id":729787,"body":"<p>Можно использовать NtQueryInformationThread:</p>\n\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n#include &lt;Winternl.h&gt;\n\nLPVOID GetThreadAddress(DWORD thid){\n\n    HANDLE thread = OpenThread(THREAD_ALL_ACCESS,FALSE,thid);\n    if(thread == NULL || thread == INVALID_HANDLE_VALUE) {wprintf(L\"OpenThread failed\");return NULL;}\n\n    HMODULE hm=LoadLibrary(L\"ntdll.dll\");\n    if(hm == NULL){ wprintf (L\"LoadLibrary failed\\n\"); return NULL;}\n\n    NTSTATUS (__stdcall *NtQueryInformationThread ) (IN HANDLE , IN THREADINFOCLASS , OUT PVOID, IN ULONG, OUT PULONG OPTIONAL )  \n        = (NTSTATUS  (__stdcall *) (IN HANDLE , IN THREADINFOCLASS , OUT PVOID ,  IN ULONG , OUT PULONG OPTIONAL))\n        GetProcAddress(hm,\"NtQueryInformationThread\");  \n    if(NtQueryInformationThread == NULL){ wprintf (L\"GetProcAddress failed\\n\"); return NULL;}\n\n    LPVOID info=NULL;   \n    NTSTATUS ntstatus = NtQueryInformationThread(thread,(THREADINFOCLASS)9 ,&amp;info,sizeof(info),NULL);\n    if(ntstatus != 0) {wprintf (L\"NtQueryInformationThread NTSTATUS 0x%x\\n\",(UINT)ntstatus); return NULL;}\n    else return info;\n\n}\n</code></pre>\n\n<p>При наличии отладочных символов также можно получить стек с помощью DbgHelp и пройти его до тех пор, пока не встретится системная функция создания потока (BaseThreadInitThunk):</p>\n\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n#include &lt;process.h&gt;\n#include \"DbgHelp.h\"\n#pragma comment(lib, \"Dbghelp.lib\")\n\nconst int MaxNameLen = 256;\n\nLPVOID GetThreadAddress2( DWORD thid )\n{\n    BOOL    result;\n    HANDLE  process;\n    HANDLE thread = OpenThread(THREAD_ALL_ACCESS,FALSE,thid);\n\n    if(thread == NULL || thread == INVALID_HANDLE_VALUE) {printf(\"OpenThread failed\");return 0;}\n\n    CONTEXT cont={0};\n    cont.ContextFlags = CONTEXT_DEBUG_REGISTERS|CONTEXT_INTEGER|CONTEXT_CONTROL;    \n    SuspendThread(thread);\n    result = GetThreadContext(thread,&amp;cont);\n    if(result == FALSE)  {printf(\"GetThreadContext failed\\n\");return 0;}\n    ResumeThread(thread);\n\n    STACKFRAME64        stack;\n    ULONG               frame;    \n    DWORD64             displacement;\n\n    char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)];\n    char name[ MaxNameLen ];\n\n    PSYMBOL_INFO pSymbol = (PSYMBOL_INFO)buffer;\n\n    ULONG64 prevaddr = 0;\n    char prevname[MaxNameLen];\n\n    memset( &amp;stack, 0, sizeof( STACKFRAME64 ) );\n\n    process                = GetCurrentProcess();\n\n    displacement           = 0;\n#if !defined(_M_AMD64)\n    stack.AddrPC.Offset    = (cont).Eip;\n    stack.AddrPC.Mode      = AddrModeFlat;\n    stack.AddrStack.Offset = (cont).Esp;\n    stack.AddrStack.Mode   = AddrModeFlat;\n    stack.AddrFrame.Offset = (cont).Ebp;\n    stack.AddrFrame.Mode   = AddrModeFlat;\n#endif\n\n    result = SymInitialize( process, NULL, TRUE ); //загружаем символы\n    if(result == FALSE)  {printf(\"SymInitialize failed\\n\"); return 0;}\n\n    for( frame = 0; ; frame++ )\n    {\n        //получаем следующий вызов из стека\n        result = StackWalk64\n        (\n#if defined(_M_AMD64)\n            IMAGE_FILE_MACHINE_AMD64\n#else\n            IMAGE_FILE_MACHINE_I386\n#endif\n            ,\n            process,\n            thread,\n            &amp;stack,\n            &amp;cont,\n            NULL,\n            SymFunctionTableAccess64,\n            SymGetModuleBase64,\n            NULL\n        );\n\n        if( !result ) break;        \n\n        //получаем имя символа для адреса\n        pSymbol-&gt;SizeOfStruct = sizeof(SYMBOL_INFO);\n        pSymbol-&gt;MaxNameLen = MAX_SYM_NAME;\n        result = SymFromAddr(process, ( ULONG64 )stack.AddrPC.Offset, &amp;displacement, pSymbol);\n        if(result == FALSE)  {printf(\"SymFromAddr failed\");continue;}        \n\n        if(lstrcmpA(pSymbol-&gt;Name,\"BaseThreadInitThunk\") == 0){                       \n            break;\n        }     \n\n        lstrcpyA(prevname,pSymbol-&gt;Name);\n        prevaddr = ( ULONG64 )pSymbol-&gt;Address;\n    }\n\n    return (LPVOID)prevaddr;\n}\n</code></pre>\n"}