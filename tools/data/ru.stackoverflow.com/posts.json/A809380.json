{"owner":{"reputation":6054,"user_id":17974,"user_type":"registered","accept_rate":83,"profile_image":"https://www.gravatar.com/avatar/e65c04f96eb45f1dec239d85c76d6afa?s=128&d=identicon&r=PG","display_name":"nick_n_a","link":"https://ru.stackoverflow.com/users/17974/nick-n-a"},"is_accepted":false,"score":2,"last_activity_date":1523435307,"last_edit_date":1523435307,"creation_date":1522838680,"answer_id":809380,"question_id":805934,"body":"<p>Получим xml с docx это не сложно <a href=\"https://ru.stackoverflow.com/a/677294/17974\">вот</a></p>\n\n<p>Давайте рассмотрим такую таблицу</p>\n\n<blockquote>\n<pre><code>1 4 &lt; 5\n2 - - ^  \n</code></pre>\n</blockquote>\n\n<p>Где &lt; и ^ - направление обьединения ячеек.\nТогда получим следующее (оставляю только значащие теги)</p>\n\n<pre><code>&lt;w:document&gt;\n &lt;w:body&gt;\n  &lt;w:tbl&gt;\n      &lt;w:tr&gt;\n         &lt;w:tc&gt;(1)&lt;/w:tc&gt;\n         &lt;w:tc&gt;&lt;w:rcPr&gt;&lt;w:gridSpan w:val=\"2\"/&gt;&lt;/w:rcPr&gt;(4)&lt;/w:tc&gt;\n         &lt;!-- отсутствует колонка --&gt;\n         &lt;w:tc&gt;&lt;w:rcPr&gt;&lt;w:vMerge w:val=\"restart\"/&gt;&lt;/w:rcPr&gt;(5)&lt;/w:tc&gt;\n      &lt;/w:tr&gt;\n      &lt;w:tr&gt;\n         &lt;w:tc&gt;(2)&lt;/w:tc&gt;\n         &lt;w:tc&gt;-&lt;/w:tc&gt;\n         &lt;w:tc&gt;-&lt;/w:tc&gt;\n         &lt;w:tc&gt;&lt;w:rcPr&gt;&lt;w:vMerge/&gt;&lt;/w:rcPr&gt;&lt;/w:tc&gt;\n      &lt;/w:tr&gt; \n</code></pre>\n\n<p>Текст хранится в тегах <code>&lt;w:t&gt;текст&lt;/w:t&gt;</code>.  Вычислить обьеденённый столбец этим способом легче - по тегу gridSpan. Обьеденённые строки прийдется перелистывать <code>vMerge</code> тег.</p>\n\n<p>Вот пример как получить доступ к тегам внутри docx</p>\n\n<pre><code>using System;\nusing System.IO;\nusing System.Xml;\npublic class Demo {\n public static void docx2process(Stream file) {\n        int isTable = 0; /*Для парсинга xml*/\n        int  col = 0;\n        int  row = 0;\n        int colSpan = 1;\n        /*Парсинг архива*/\n        int ready = 0; while (ready++ &lt; 10){ /*защита от повисания, обход архива*/\n            byte[] head = new byte[30]; file.Read(head, 0, 30); if (head[0] != 'P') break;  //zip-header\n            int i = (head[27] + head[29]) * 256 + head[28]; //  extra len\n            long paked = BitConverter.ToInt32(head,18);\n            byte[] nam = new byte[255];\n            file.Read(nam, 0, head[26]);\n            if (i != 0) file.Seek(i, SeekOrigin.Current);\n            String aname = System.Text.Encoding.ASCII.GetString(nam, 0, head[26]);\n            if (aname == \"word/document.xml\"){\n                long lastpos = file.Position;\n                using (System.IO.Compression.DeflateStream deflate = new System.IO.Compression.DeflateStream(file, System.IO.Compression.CompressionMode.Decompress)){                        \n                    System.Xml.XmlReader rd = System.Xml.XmlReader.Create(deflate);\n                    // Тут парсинг документа\n                    while (rd.Read()){\n                       if (rd.NodeType == XmlNodeType.Element) \n                          switch (rd.Name){\n                              case \"w:gridSpan\":  colSpan = int.Parse(rd.GetAttribute(\"w:val\"));break;\n                              case \"w:vMerge\":; /*Тут нужно допилить обьединение строк*/  break;\n                              case \"w:tbl\": row=0; isTable = rd.Depth ; break;\n                              case \"w:tr\": col=0; row++; break;\n                              case \"w:tc\": col+= colSpan; colSpan=1; break;\n                              case \"w:t\":/*Теги с текстом*/\n                                 if (rd.Read() &amp;&amp; rd.NodeType == XmlNodeType.Text)\n                                     /*Тут нужно написать свой вывод куда-либо*/\n                                     if (isTable&gt;0) \n                                         Console.WriteLine(string.Format(\"c={0}.{3} r={1} t={2}\",col,row,rd.Value, colSpan)); \n                                      else Console.WriteLine(rd.Value);\n                                 break;                                    \n                              case \"w:p\": /*Параграф*/ if (isTable == rd.Depth) isTable = 0; break;\n                              }\n                       }\n                    return;\n                }                                        \n               file.Position = lastpos + paked;\n            }else file.Seek(paked, SeekOrigin.Current);\n        };                \n       }\n\n\n   public static void docx2process(string filename) {\n        using (Stream f = File.OpenRead(filename))  docx2process(f);\n       }\n\n    public static void Main(string[] args) {\n       docx2process(\"1.docx\");    \n      }\n }\n</code></pre>\n\n<p>этот пример почти решает поставленую задачу. Обьедененные столбцы - видно. Обьеденённые строки - ещё нужно доработать.</p>\n"}