{"owner":{"reputation":508,"user_id":193189,"user_type":"registered","profile_image":"https://i.stack.imgur.com/ik1J3.jpg?s=128&g=1","display_name":"Netch","link":"https://ru.stackoverflow.com/users/193189/netch"},"is_accepted":false,"score":11,"last_activity_date":1561875261,"last_edit_date":1561875261,"creation_date":1460876930,"answer_id":513786,"question_id":513736,"body":"<p>Действие по умолчанию зависит от процессора, компилятора и настроек. На MIPS, например, его \"классические\" компиляторы превращали сложение знаковых в команду add, которая генерирует исключение при переполнении, а беззнаковых - addu, которая не генерирует. Но gcc, clang уже такого не делали, всё через addu. На x86 - родные команды add, sub  игнорируют переполнение (точнее, ставят флаг CF или OF, но не генерируют исключение).<br>\nКомпиляторы современного типа считают, что переполнения в операциях с целыми со знаком не должно быть, иногда из-за этого возникают интересные эффекты - вот <a href=\"http://rsdn.org/forum/cpp/5654034.all\" rel=\"nofollow noreferrer\">самый убойный пример</a> из тех, что я видел. Стандарт тут действует по принципу \"мы вам даём возможность писать максимально эффективно, потому что это C, а не учебный язык, а защита от кривостей - ваша проблема\".</p>\n\n<p>Для C++ есть, например, библиотечка (шаблонный заголовочный файл) <code>SafeInt3</code> от Microsoft, под свободной лицензией; ею можно покрыть все основные операции, хотя она не использует специфику процессоров (даже x86) и оттого во многих случаях неэффективна - там, где достаточно одного OF или CF, она городит много сложных расчётов.</p>\n\n<p>Для C придётся всё писать вручную, заменяя обычные операции на свои эквиваленты функциями или макросами.</p>\n\n<p>UPDATE: про новые встроенные функции последних gcc и clang (<code>__builtin_add_overflow</code>, <code>__builtin_mul_overflow</code> и вся группа)уже писали. Но и без них можно сделать достаточно неплохо. Например, в случае сложения двух int, проверка вида <code>a &gt; INT_MAX - b</code>, если b > 0, иначе <code>a &lt; INT_MIN - b</code>, достаточна, чтобы проверить разрешимость сложения.</p>\n"}