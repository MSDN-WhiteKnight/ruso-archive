{"owner":{"reputation":16137,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":2,"last_activity_date":1545213994,"last_edit_date":1545213994,"creation_date":1545201597,"answer_id":922784,"question_id":922744,"body":"<p>Физические диски можно получить через Setup API. Как-то так (С++):</p>\n\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;tchar.h&gt;\n#include &lt;locale.h&gt;\n#include &lt;windows.h&gt;\n#include &lt;Setupapi.h&gt;\n#include &lt;LM.h&gt;\n#define INITGUID\n#include &lt;Devpkey.h&gt;\n\n#pragma comment(lib,\"Setupapi.lib\")\n#pragma comment(lib,\"Netapi32.lib\")\n\nvoid ErrorMes(LPCTSTR lpszFunction)\n{\n    // Retrieve the system error message for the last-error code\n\n    LPVOID lpMsgBuf;\n    LPVOID lpDisplayBuf;\n    DWORD dw = GetLastError();\n\n    FormatMessage(\n        FORMAT_MESSAGE_ALLOCATE_BUFFER |\n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,\n        dw,\n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n        (LPTSTR)&amp;lpMsgBuf,\n        0, NULL);\n\n    // Display the error message \n\n    lpDisplayBuf = (LPVOID)LocalAlloc(LMEM_ZEROINIT,\n        (lstrlen((LPCTSTR)lpMsgBuf) + lstrlen(lpszFunction) + 40) * sizeof(TCHAR));\n    wprintf(L\"%s failed with error %d: %s\",\n        lpszFunction, dw, (LPSTR)lpMsgBuf);\n\n    LocalFree(lpMsgBuf);\n    LocalFree(lpDisplayBuf);\n}\n\nvoid PrintDisks(const GUID * guidInterface) {\n\n    DEVPROPTYPE dpt = 0;\n    wchar_t buffer[1024] = L\"\";\n\n    DWORD RequiredSize = 0;\n    SP_DEVINFO_DATA devinfo = { 0 };\n    SP_DEVICE_INTERFACE_DATA deviceInterface = { 0 };\n    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceInterfaceDetail = NULL;\n    BOOL res;\n\n    USE_INFO_2 info;\n    info.ui2_asg_type = USE_WILDCARD;\n    info.ui2_local = NULL;\n    info.ui2_domainname = (LPWSTR)L\"DOMEN\";\n    info.ui2_username = (LPWSTR)L\"User\";\n    info.ui2_password = (LPWSTR)L\"123\";\n    info.ui2_remote = (LPWSTR)L\"\\\\\\\\server\\\\IPC$\";  \n\n    DWORD parm = 0;\n    DWORD dwRes = NetUseAdd(NULL, 2, (LPBYTE)&amp;info, &amp;parm);\n    if(dwRes != NERR_Success)printf(\"NetUseAdd failed: %u (%u)\\n\",dwRes,parm);  \n\n    HDEVINFO deviceInfoHandle = SetupDiGetClassDevsEx(guidInterface, 0, 0, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE,\n        NULL, L\"\\\\\\\\server\",NULL);\n\n    if (deviceInfoHandle != INVALID_HANDLE_VALUE)\n    {\n        int deviceIndex = 0;\n        while (true)\n        {\n            ZeroMemory(&amp;deviceInterface, sizeof(deviceInterface));\n            deviceInterface.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);\n\n            //получение всех дисков\n            if (SetupDiEnumDeviceInterfaces(deviceInfoHandle, 0, guidInterface, deviceIndex, &amp;deviceInterface))\n            {\n                DWORD cbRequired = 0;\n\n                SetupDiGetDeviceInterfaceDetail(deviceInfoHandle, &amp;deviceInterface, 0, 0, &amp;cbRequired, 0);\n                if (ERROR_INSUFFICIENT_BUFFER == GetLastError())\n                {\n                    deviceInterfaceDetail = (PSP_DEVICE_INTERFACE_DETAIL_DATA)(new char[cbRequired]);\n                    memset(deviceInterfaceDetail, 0, cbRequired);\n                    deviceInterfaceDetail-&gt;cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);\n\n                    if (!SetupDiGetDeviceInterfaceDetail(deviceInfoHandle, &amp;deviceInterface,\n                        deviceInterfaceDetail, cbRequired, &amp;cbRequired, 0))\n                    {\n                        goto Next;\n                    }\n\n                    // Initialize the structure before using it.\n                    memset(deviceInterfaceDetail, 0, cbRequired);\n                    deviceInterfaceDetail-&gt;cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);\n\n                    // Call the API a second time to retrieve the actual\n                    // device path string.\n                    BOOL status = SetupDiGetDeviceInterfaceDetail(\n                        deviceInfoHandle,  // Handle to device information set\n                        &amp;deviceInterface,     // Pointer to current node in devinfo set\n                        deviceInterfaceDetail,   // Pointer to buffer to receive device path\n                        cbRequired,   // Length of user-allocated buffer\n                        &amp;cbRequired,  // Pointer to arg to receive required buffer length\n                        NULL);        // Not interested in additional data\n\n\n                    //получение информации о устройстве \n                    ZeroMemory(&amp;devinfo, sizeof(devinfo));\n                    devinfo.cbSize = sizeof(SP_DEVINFO_DATA);\n                    BOOL success = SetupDiEnumDeviceInfo(deviceInfoHandle, deviceIndex, &amp;devinfo);\n                    if (success == FALSE) { ErrorMes(L\"SetupDiEnumDeviceInfo\"); goto Next; }\n\n                    res = SetupDiGetDeviceProperty(deviceInfoHandle, &amp;devinfo,\n                        &amp;DEVPKEY_NAME, &amp;dpt, (PBYTE)buffer, 1000, NULL, 0);\n                    if (res == FALSE) { ErrorMes(L\"SetupDiGetDeviceProperty\"); goto Next; }\n\n                    wprintf(L\"%s: %s\\n\", buffer, deviceInterfaceDetail-&gt;DevicePath);\n                }\n            }\n            else\n            {\n                break;\n            }\n\n        Next:\n            if (deviceInterfaceDetail != NULL) {\n                delete[] deviceInterfaceDetail;\n                deviceInterfaceDetail = NULL;\n            }\n\n\n\n            deviceIndex++; //следующее устройство\n        }\n\n        SetupDiDestroyDeviceInfoList(deviceInfoHandle);\n    }\n    else ErrorMes(L\"SetupDiGetClassDevsEx\");\n\n}\n\nint __cdecl main(int argc, char **argv)\n{\n    setlocale(LC_ALL, \"Russian\");\n    PrintDisks(&amp;GUID_DEVINTERFACE_DISK);\n    PrintDisks(&amp;GUID_DEVINTERFACE_CDROM);\n    getchar();\n    return 0;\n\n}\n</code></pre>\n\n<p>Однако, этот способ не работает на Windows 10. Удаленный диспетчер устройств в ней был исключен, а вместе с ним и используемые им API.</p>\n\n<p>Список букв разделов можно получить, подключившись к удаленному реестру, он хранится в ветке <code>HKEY_LOCAL_MACHINE\\SYSTEM\\MountedDevices</code>. Способа получить метки разделов для удаленного компьютера вроде нет.</p>\n"}