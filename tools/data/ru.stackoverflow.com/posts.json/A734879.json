{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":0,"last_activity_date":1509079776,"last_edit_date":1509079776,"creation_date":1508783845,"answer_id":734879,"question_id":268206,"body":"<h2>Решение на C++ для Windows</h2>\n\n<p>Определить версию USB можно с помощью <a href=\"https://docs.microsoft.com/en-us/windows-hardware/drivers/install/setupapi\" rel=\"nofollow noreferrer\">Setup API</a> и запросов <code>DeviceIoControl</code>. Нас интересуют запросы:</p>\n\n<p><a href=\"https://msdn.microsoft.com/en-us/library/windows/hardware/ff537321(v=vs.85).aspx\" rel=\"nofollow noreferrer\">IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX</a> - возвращает сведения о фактически используемой в данный момент версии USB</p>\n\n<p><a href=\"https://msdn.microsoft.com/en-us/library/windows/hardware/hh450861(v=vs.85).aspx\" rel=\"nofollow noreferrer\">IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX_V2</a> - возвращает сведения о поддерживаемых версиях USB</p>\n\n<p>Алгоритм следующий:</p>\n\n<ol>\n<li><p>Функцией <code>SetupDiEnumDeviceInterfaces</code> найти все интерфейсы USB-концентраторов.</p></li>\n<li><p>Для каждого концентратора функцией <code>SetupDiGetDeviceInterfaceDetail</code> получить путь к устройству - строку, которую можно скармливать функции <code>CreateFile</code> вместо пути к файлу, для отправки IOCTL.</p></li>\n<li><p>Через <code>IOCTL_USB_GET_HUB_INFORMATION_EX</code> получить число портов на концентраторе.</p></li>\n<li><p>Для каждого порта отправкой <code>IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX</code> и/или <code>IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX_V2</code> получить сведения о порте.</p></li>\n<li><p>Пользуясь полями полученной структуры <code>USB_DEVICE_DESCRIPTOR</code>, можно определить <em>VID</em> и <em>PID</em>, и далее с помощью них другие необходимые параметры для идентификации устройства (<em>Friendly Name, Service</em> и т.п.)</p></li>\n</ol>\n\n<hr>\n\n<p>Пример кода на c++ для вывода названия, идентификатора, версий USB-протокола и текущей скорости для всех запоминающих USB-устройств, основан на <a href=\"https://stackoverflow.com/a/36728329/8674428\">коде из ответа MrMoDoJoJr на stackoverflow.com</a>:</p>\n\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;tchar.h&gt;    \n#include &lt;Windows.h&gt;\n#include &lt;Setupapi.h&gt;\n#include &lt;winusb.h&gt;\n\n#undef LowSpeed\n#include &lt;Usbioctl.h&gt;\n\n#include &lt;stdlib.h&gt;\n#include &lt;Devpkey.h&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;memory&gt;\n#include &lt;strsafe.h&gt;\n\n#pragma comment(lib,\"Setupapi.lib\")\n\n\nvoid ErrorMes(LPTSTR lpszFunction) \n{ \n    // Retrieve the system error message for the last-error code\n\n    LPVOID lpMsgBuf;\n    LPVOID lpDisplayBuf;\n    DWORD dw = GetLastError(); \n\n    FormatMessage(\n        FORMAT_MESSAGE_ALLOCATE_BUFFER | \n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,\n        dw,\n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n        (LPTSTR) &amp;lpMsgBuf,\n        0, NULL );\n\n    // Display the error message \n\n    lpDisplayBuf = (LPVOID)LocalAlloc(LMEM_ZEROINIT, \n        (lstrlen((LPCTSTR)lpMsgBuf) + lstrlen((LPCTSTR)lpszFunction) + 40) * sizeof(TCHAR)); \n    wprintf(L\"%s failed with error %d: %s\", \n        lpszFunction, dw, lpMsgBuf);     \n\n    LocalFree(lpMsgBuf);\n    LocalFree(lpDisplayBuf);\n\n}\n\ntypedef struct {\n    wchar_t name[1024];//friendly name\n    wchar_t id[1024];//instance id\n\n} USB_DEVICE_PARAMS;\n\n/*Получение имени устройства с указанным InstanceID*/\nBOOL GetDevice(wchar_t* id,wchar_t* output)\n{\n    unsigned index;\n    HDEVINFO hDevInfo;\n    SP_DEVINFO_DATA DeviceInfoData;\n    TCHAR id_upper[1024]=L\"\";\n    TCHAR buf[1024]=L\"\";\n    TCHAR match[1024];\n    DEVPROPTYPE dpt=0;\n\n\n        for(int i=0;i&lt;wcslen(id);i++){\n            id_upper[i]=toupper(id[i]);//преобразование в заглавные буквы\n        }\n\n\n\n    // List all connected devices\n    hDevInfo = SetupDiGetClassDevs(NULL, NULL, NULL, DIGCF_PRESENT | DIGCF_ALLCLASSES);\n    for (index = 0; ; index++) {\n        DeviceInfoData.cbSize = sizeof(DeviceInfoData);\n        if (!SetupDiEnumDeviceInfo(hDevInfo, index, &amp;DeviceInfoData)) {\n            return FALSE;     // no match\n        }\n\n        BOOL res=SetupDiGetDeviceProperty(hDevInfo,&amp;DeviceInfoData,\n                        &amp;DEVPKEY_Device_InstanceId,&amp;dpt,(PBYTE)buf,1000,NULL,0);\n            if(res==FALSE)continue;\n\n\n        if(wcscmp(buf,id_upper)==0){\n            //устройство найдено\n            res=SetupDiGetDeviceProperty(hDevInfo,&amp;DeviceInfoData,\n                        &amp;DEVPKEY_Device_FriendlyName,&amp;dpt,(PBYTE)buf,1000,NULL,0);\n\n            wcscpy(output,buf);//возврат имени\n\n            return TRUE;\n        }\n\n\n    }\n    return FALSE;//устройство не найдено\n\n}\n\n/*Получение USB Mass Storage Device по указанным VID и PID*/\nBOOL GetMassStorageDevice(int vid,int pid,USB_DEVICE_PARAMS* output)\n{\n    unsigned index;\n    HDEVINFO hDevInfo;\n    SP_DEVINFO_DATA DeviceInfoData;\n    TCHAR HardwareID[1024];\n    TCHAR buf[1024];\n\n    TCHAR match[1024];\n    DEVPROPTYPE dpt=0;\n    BOOL res;\n\n    //формируем строку для поиска\n    StringCchPrintf(match,1024,L\"VID_%04X&amp;PID_%04X\",vid,pid);\n\n\n    // List all connected USB devices\n    hDevInfo = SetupDiGetClassDevs(NULL, TEXT(\"USB\"), NULL, DIGCF_PRESENT | DIGCF_ALLCLASSES);\n    for (index = 0; ; index++) {\n        DeviceInfoData.cbSize = sizeof(DeviceInfoData);\n        if (!SetupDiEnumDeviceInfo(hDevInfo, index, &amp;DeviceInfoData)) {\n            return FALSE;     // no match\n        }\n\n        res=SetupDiGetDeviceRegistryProperty(hDevInfo, &amp;DeviceInfoData, SPDRP_HARDWAREID, NULL, \n            (BYTE*)HardwareID, sizeof(HardwareID),  NULL);\n        if(res==FALSE)continue;\n\n        if (_tcsstr(HardwareID, match)) {//найдено устройство, проверяем его тип\n            res=SetupDiGetDeviceRegistryProperty(hDevInfo, &amp;DeviceInfoData, SPDRP_SERVICE, NULL, \n            (BYTE*)buf, sizeof(buf),    NULL);\n            if(res==FALSE)continue;\n\n             if(wcscmp(buf,L\"USBSTOR\")==0){//устройство является Mass Storage\n                res=SetupDiGetDeviceRegistryProperty(hDevInfo, &amp;DeviceInfoData, SPDRP_DEVICEDESC, NULL, \n                (BYTE*)buf, sizeof(buf),    NULL);\n                if(res==FALSE)continue;\n\n                //получаем дочернее устройство\n                res=SetupDiGetDeviceProperty(hDevInfo,&amp;DeviceInfoData,\n                        &amp;DEVPKEY_Device_Children,&amp;dpt,(PBYTE)buf,1000,NULL,0);\n                if(res==FALSE)continue;//нет дочерних устройств\n\n                wcscpy(output-&gt;id,buf);//возврат ID\n\n                GetDevice(buf,output-&gt;name);//возврат имени устройства\n\n                return TRUE;     // найдено \n             }\n        }\n    }\n    return FALSE;//не найдено\n\n}\n\n\n\nint main()\n{\n    setlocale(LC_ALL,\"Russian\");\n\n    GUID guid;\n    /*USB HUB Interface class GUID*/\n    HRESULT hr = CLSIDFromString(L\"{F18A0E88-C30C-11D0-8815-00A0C906BED8}\", (LPCLSID)&amp;guid);\n\n    HDEVINFO deviceInfoHandle = SetupDiGetClassDevs(&amp;guid, 0, 0, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);\n\n    if (deviceInfoHandle != INVALID_HANDLE_VALUE)\n    {\n        int deviceIndex = 0;\n        while (true)\n        {\n            SP_DEVICE_INTERFACE_DATA deviceInterface = { 0 };\n            deviceInterface.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);\n\n            //получение всех USB-концентраторов\n            if (SetupDiEnumDeviceInterfaces(deviceInfoHandle, 0, &amp;guid, deviceIndex, &amp;deviceInterface))\n            {\n                DWORD cbRequired = 0;\n\n                SetupDiGetDeviceInterfaceDetail(deviceInfoHandle, &amp;deviceInterface, 0, 0, &amp;cbRequired, 0);\n                if (ERROR_INSUFFICIENT_BUFFER == GetLastError())\n                {\n                    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceInterfaceDetail = \n                        (PSP_DEVICE_INTERFACE_DETAIL_DATA)(new char[cbRequired]);\n                    memset(deviceInterfaceDetail, 0, cbRequired);\n                    deviceInterfaceDetail-&gt;cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);\n\n                    if (!SetupDiGetDeviceInterfaceDetail(deviceInfoHandle, &amp;deviceInterface, \n                        deviceInterfaceDetail, cbRequired, &amp;cbRequired, 0))\n                    {\n                        deviceIndex++;\n                        continue;\n                    }\n\n                    // Initialize the structure before using it.\n                    memset(deviceInterfaceDetail, 0, cbRequired);\n                    deviceInterfaceDetail-&gt;cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);\n\n                    // Call the API a second time to retrieve the actual\n                    // device path string.\n                    BOOL status = SetupDiGetDeviceInterfaceDetail(\n                        deviceInfoHandle,  // Handle to device information set\n                        &amp;deviceInterface,     // Pointer to current node in devinfo set\n                        deviceInterfaceDetail,   // Pointer to buffer to receive device path\n                        cbRequired,   // Length of user-allocated buffer\n                        &amp;cbRequired,  // Pointer to arg to receive required buffer length\n                        NULL);        // Not interested in additional data\n\n                    BOOL res;                   \n\n                    /*Открываем устройство для отправки IOCTL*/\n                    HANDLE handle = CreateFile(deviceInterfaceDetail-&gt;DevicePath, GENERIC_WRITE, FILE_SHARE_WRITE, \n                        0, OPEN_EXISTING, 0, 0);\n\n                    if(handle!=INVALID_HANDLE_VALUE) {\n\n                        //получаем число портов на концентраторе\n                        DWORD bytes_read=0;\n                        USB_HUB_INFORMATION_EX hubinfo;\n                        hubinfo.HighestPortNumber=0;\n\n                        res=DeviceIoControl(handle,IOCTL_USB_GET_HUB_INFORMATION_EX  ,\n                            &amp;hubinfo,sizeof(hubinfo),&amp;hubinfo,sizeof(hubinfo),&amp;bytes_read,0);\n                        if(res==FALSE)ErrorMes(L\"DeviceIoControl\");                     \n\n                        USB_NODE_CONNECTION_INFORMATION_EX coninfo={0};//get conn info\n                        USB_NODE_CONNECTION_INFORMATION_EX_V2 con2={0};\n\n                        for(int j=1;j&lt;=(int)hubinfo.HighestPortNumber;j++){\n\n                            coninfo.ConnectionIndex=j;\n\n                            //получаем инфу о порте\n                            res=DeviceIoControl(handle,IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX ,\n                            &amp;coninfo,sizeof(coninfo),&amp;coninfo,sizeof(coninfo),&amp;bytes_read,0);\n\n                            if(res==FALSE){ErrorMes(L\"DeviceIoControl\");continue;}\n\n                            if(coninfo.ConnectionStatus==0)continue;\n\n                            USB_DEVICE_PARAMS usbdev={0};\n\n                            //если на порте запоминающее устройство, вывести его данные\n\n                            if(GetMassStorageDevice(coninfo.DeviceDescriptor.idVendor,\n                                    coninfo.DeviceDescriptor.idProduct,&amp;usbdev)!=FALSE)\n                            {\n                                printf(\"\\n- Hub %2d, Port %2d: USB v%x device\\n\",deviceIndex,\n                                    j,(int)coninfo.DeviceDescriptor.bcdUSB);\n                                printf(\"VID_%04X PID_%04X\\n\",(int)coninfo.DeviceDescriptor.idVendor\n                                    ,(int)coninfo.DeviceDescriptor.idProduct);\n                                wprintf(L\"Device ID: %s\\n\",usbdev.id);\n                                wprintf(L\"Device name: %s\\n\",usbdev.name);\n                                printf(\"Speed: %d\",(int)coninfo.Speed);\n\n                                switch((int)coninfo.Speed){\n                                    case UsbLowSpeed:printf(\" (low)\\n\");break;\n                                    case UsbFullSpeed:printf(\" (full)\\n\");break;\n                                    case UsbHighSpeed:printf(\" (high)\\n\");break;\n                                    case UsbSuperSpeed:printf(\" (super)\\n\");break;\n                                    default:printf(\"\\n\");break;\n                                }\n\n                                //получение поддерживаемых протоколов\n                                con2.ConnectionIndex=j;\n                                con2.Length=sizeof(USB_NODE_CONNECTION_INFORMATION_EX_V2 );\n                                con2.SupportedUsbProtocols.Usb300=1;\n\n                                res=DeviceIoControl(handle, IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX_V2 ,\n                                &amp;con2,sizeof(con2),&amp;con2,sizeof(con2),&amp;bytes_read,0);\n                                if(res==FALSE){ErrorMes(L\"DeviceIoControl\");continue;}\n\n                                printf(\"Supported protocols: \");\n                                if(con2.SupportedUsbProtocols.Usb110)printf(\"USB 1.1; \");\n                                if(con2.SupportedUsbProtocols.Usb200)printf(\"USB 2.0; \");\n                                if(con2.SupportedUsbProtocols.Usb300)printf(\"USB 3.0; \");                               \n                                printf(\"\\n\");\n                            }\n\n\n                        }//end for\n\n                        CloseHandle(handle);\n                    }else{\n                        ErrorMes(L\"CreateFile\");//failed to open device\n                    }//endif\n\n\n                    delete[] deviceInterfaceDetail;\n                }\n            }\n            else\n            {\n                break;\n            }\n\n            ++deviceIndex;\n        }\n\n        SetupDiDestroyDeviceInfoList(deviceInfoHandle);\n    }\n\n    system(\"PAUSE\");\n    return 0;\n}\n</code></pre>\n\n<p>Так выглядит результат:</p>\n\n<p><a href=\"https://i.stack.imgur.com/uRZTO.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/uRZTO.png\" alt=\"введите сюда описание изображения\"></a></p>\n\n<p><strong>Примечание.</strong> Информация выше относится к Windows 8-10. В более ранних ОС запросы на получение версии не поддерживаются, но можно получить признак поддержки High Speed:</p>\n\n<pre><code>DWORD bytes_read=0;\nUSB_HUB_CAPABILITIES_EX hubinfo={0};\n\nres=DeviceIoControl(handle, IOCTL_USB_GET_HUB_CAPABILITIES  ,\n                            &amp;hubinfo,sizeof(hubinfo),&amp;hubinfo,sizeof(hubinfo),&amp;bytes_read,0);\nif(res==FALSE)ErrorMes(L\"DeviceIoControl\");                     \n\nprintf(\"Supports High speed: %d\\n\",hubinfo.CapabilityFlags.HubIsHighSpeedCapable);\n</code></pre>\n"}