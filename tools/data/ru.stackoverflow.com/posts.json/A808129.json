{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":2,"last_activity_date":1522616835,"creation_date":1522616835,"answer_id":808129,"question_id":760083,"body":"<p>Данные WAV-файла, при использовании способа кодирования PCM или IEEE Float, располагаются в памяти как последовательность мгновенных значений звукового сигнала, считанных через равные промежутки времени (для каждого канала, если их несколько).</p>\n\n<ul>\n<li>Для 8-битных PCM данных, значения лежат в диапазоне от 0 до 255.</li>\n<li>Для 16-битных PCM данных, значения лежат в диапазоне от -32768 до 32767.</li>\n<li>Для 32-битных IEEE Float данных, значения могут быть любыми, но обычно они нормализованы в диапазон от -1.0 до 1.0</li>\n</ul>\n\n<p>Отсутствие звука представляется не обязательно нулями, а любым постоянным значением (звук - это изменение сигнала, следовательно постоянный сигнал любой величины означает тишину). Графически звук можно представить как сумму синусоид, а тишину - как прямую линию, параллельную оси абсцисс.</p>\n\n<p>Увеличение громкости звука нужно производить умножением семплов на какое-то значение, а не прибавлением, так как громкость - это амплитуда колебаний (синусоиду надо \"растянуть\" вдоль оси ординат, а не просто параллельно сдвинуть вверх). Для этого проще всего преобразовать значения в тип float и все промежуточные операции делать с ним, чтобы избежать переполнения. Если после умножения значение выходит за рамки допустимого диапазона, его нужно обрезать (таким образом, чем больше увеличение громкости, тем больше потери информации).</p>\n\n<p>Пример кода на C# для работы с 8/16 битными PCM или 32 битными IEEE Float данными:</p>\n\n<p><em>Вспомогательные классы</em></p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\n\nnamespace WaveRead\n{   \n    /// &lt;summary&gt;\n    /// Класс, осуществляющий чтение/запись RIFF WAV файлов\n    /// &lt;/summary&gt;\n    public class WavFile\n    {\n        public string FilePath { get; set; }\n\n        public WavFile(string file)\n        {\n            FilePath = file;\n        }\n\n        public WavData ReadData()\n        {\n            var header = new WavHeader();\n            byte[] data;\n            using (var fs = new FileStream(FilePath, FileMode.Open, FileAccess.Read))\n            {\n                using (var reader = new BinaryReader(fs))\n                {\n                    //считываем заголовок\n                    header.ChunkId = reader.ReadInt32();\n                    header.ChunkSize = reader.ReadInt32();\n                    header.Format = reader.ReadInt32();\n                    header.Subchunk1Id = reader.ReadInt32();\n                    header.Subchunk1Size = reader.ReadInt32();\n                    header.AudioFormat = reader.ReadInt16();\n                    header.NumChannels = reader.ReadInt16();\n                    header.SampleRate = reader.ReadInt32();\n                    header.ByteRate = reader.ReadInt32();\n                    header.BlockAlign = reader.ReadInt16();\n                    header.BitsPerSample = reader.ReadInt16();\n\n                    if (header.Subchunk1Size == 18)\n                    {                        \n                        header.FmtExtraSize = reader.ReadInt16();\n                        reader.ReadBytes(header.FmtExtraSize);\n                    }\n\n                    //пытаемся считать данные\n                    header.Subchunk2Id = reader.ReadInt32();\n                    header.Subchunk2Size = reader.ReadInt32();\n\n                    while (true)\n                    {\n                        data = reader.ReadBytes(header.Subchunk2Size);\n                        if (header.Subchunk2Id == 0x61746164) { break; }//данные найдены\n\n                        //если Subchunk2Id нет тот, что ожидался, пропускаем и пробуем снова\n                        header.Subchunk2Id = reader.ReadInt32();\n                        header.Subchunk2Size = reader.ReadInt32();\n                    }    \n                }\n            }\n\n            var result = new WavData(header, data);           \n\n            return result;\n        }\n\n        public void WriteData(WavData input)\n        {\n            var header = input.Header;\n            byte[] data = input.Data;\n            using (var fs = new FileStream(FilePath, FileMode.Create, FileAccess.Write))\n            {\n                using (var writer = new BinaryWriter(fs))\n                {\n                    //пишем заголовок\n                    writer.Write((int)header.ChunkId);\n                    writer.Write((int) header.ChunkSize);\n                    writer.Write((int) header.Format);\n                    writer.Write((int) header.Subchunk1Id);\n                    writer.Write((int) header.Subchunk1Size);\n                    writer.Write((short) header.AudioFormat);\n                    writer.Write((short) header.NumChannels );\n                    writer.Write((int) header.SampleRate);\n                    writer.Write((int)  header.ByteRate);\n                    writer.Write((short) header.BlockAlign);\n                    writer.Write((short) header.BitsPerSample);                    \n\n                    if (header.Subchunk1Size == 18)\n                    {\n                        writer.Write((short) 0);    \n                    }\n\n                    //пишем данные\n                    writer.Write((int) header.Subchunk2Id);\n                    writer.Write((int)header.Subchunk2Size);\n                    writer.Write(data);\n\n                }\n            }            \n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Представляет звуковые данные в формате PCM или IEEE Float\n    /// Позволяет осуществлять чтение/запись семплов для форматов 8/16 бит PCM и 32 бит IEEE Float\n    /// &lt;/summary&gt;\n    public class WavData : IDisposable\n    {\n        public WavHeader Header {get;set;}\n        public byte[] Data { get; set; }\n        BinaryReader _read;\n        BinaryWriter _write;\n\n        /// &lt;summary&gt;\n        /// Создает экземпляр WavData с указанным заголовком и пустым массивом данных указанного размера\n        /// &lt;/summary&gt;        \n        public WavData(WavHeader hdr, int size)\n        {\n            Header = hdr;\n            Data = new byte[size];\n            MemoryStream ms = new MemoryStream(Data);\n            _read = new BinaryReader(ms);\n            _write = new BinaryWriter(ms);\n        }\n\n        /// &lt;summary&gt;\n        /// Создает экземпляр WavData с указанным заголовком и массивом данных\n        /// &lt;/summary&gt;\n        public WavData(WavHeader hdr, byte[] d)\n        {\n            Header = hdr; Data = d;\n            MemoryStream ms = new MemoryStream(Data);\n            _read = new BinaryReader(ms);\n            _write = new BinaryWriter(ms);\n\n        }\n\n        /// &lt;summary&gt;\n        /// Возвращает число семплов в массиве данных\n        /// &lt;/summary&gt;        \n        public int GetSamplesCount()\n        {\n            return Data.Length / ((int)Header.BitsPerSample / 8);\n        }\n\n        /// &lt;summary&gt;\n        /// Читает следующий семпл в виде float-значения. Целочисленные данные нормализуются в диапазон от -1 до 1\n        /// &lt;/summary&gt;        \n        public float ReadNextSample()\n        {\n            float res = 0.0f;\n\n            switch (Header.AudioFormat)\n            {\n                case 1://PCM\n                    if (Header.BitsPerSample == 8)\n                    {                        \n                        res = (_read.ReadByte() - 128.0f) / 255.0f;\n                    }\n                    else if (Header.BitsPerSample == 16)\n                    {\n                        res = (_read.ReadInt16()) / 32767.0f;\n                    }\n                    else throw new ApplicationException(\"BitsPerSample value not supported\");\n                    if (res &gt; 1.0f) res = 1.0f;\n                    if (res &lt; -1.0f) res = -1.0f;\n                    break;\n\n                case 3: //IEEE Float\n                    if (Header.BitsPerSample != 32) throw new ApplicationException(\"BitsPerSample value not supported\");\n                    res = _read.ReadSingle();\n                    break;\n                default: throw new ApplicationException(\"AudioFormat value not supported\");\n            }\n\n            return res;\n        }\n\n        /// &lt;summary&gt;\n        /// Записывает значение следующего семпла. Для PCM значение должно быть нормализовано в диапазон от -1 до 1\n        /// &lt;/summary&gt;        \n        public void WriteSample(float val)\n        {\n            switch (Header.AudioFormat)\n            {\n                case 1://PCM\n                    if (Header.BitsPerSample == 8)\n                    {\n                        _write.Write((byte)((val + 2.0f)*128.0f));                        \n                    }\n                    else if (Header.BitsPerSample == 16)\n                    {\n                        _write.Write((short)(val * 32767.0f)); \n                    }\n                    else throw new ApplicationException(\"BitsPerSample value not supported\");                    \n                    break;\n\n                case 3://IEEE Float\n                    if (Header.BitsPerSample != 32) throw new ApplicationException(\"BitsPerSample value not supported\");\n                    _write.Write(val); \n                    break;\n                default: throw new ApplicationException(\"AudioFormat value not supported\");\n            }\n        }\n\n        public void Dispose()\n        {\n            _read.Dispose();\n            _write.Dispose();\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Представляет заголовок RIFF WAV файла\n    /// &lt;/summary&gt;\n    public struct WavHeader\n    {        \n        public int ChunkId { get; set; }\n        public int ChunkSize { get; set; }\n        public int Format { get; set; } //\"WAVE\"\n        public int Subchunk1Id { get; set; }//\"fmt \"\n        public int Subchunk1Size { get; set; }\n        public short AudioFormat { get; set; }\n        public short NumChannels { get; set; }\n        public int SampleRate { get; set; }\n        public int ByteRate { get; set; }\n        public short BlockAlign { get; set; }\n        public short BitsPerSample { get; set; }\n        public int FmtExtraSize { get; set; }\n\n        public int Subchunk2Id { get; set; } //\"data\" (0x61746164)\n        public int Subchunk2Size { get; set; }// numSamples * numChannels * bitsPerSample/8   \n    }\n\n}\n</code></pre>\n\n<p><em>Пример использования (увеличение или уменьшение громкости на заданный коэффициент)</em></p>\n\n<pre><code>WavFile file = new WavFile(tbInputFile.Text); //входной файл\nWavData orig = file.ReadData();\nWavData processed = new WavData(orig.Header, orig.Data.Length);\n\nusing(processed)\nusing (orig)\n{\n    int c=orig.GetSamplesCount();\n\n    float x;\n    float y;\n    int clipped = 0;\n\n    for (int i = 0; i &lt; c; i++)\n    {\n        x = orig.ReadNextSample(); //читаем следующий семпл                    \n\n        y = x * (float)numericUpDown1.Value; //умножаем значение на коэффициент\n\n        //если значение выходит за рамки поддерживаемого диапазона, обрезаем\n        if (y &gt; 1.0f) { y = 1.0f; clipped++; }\n        if (y &lt; -1.0f) { y = -1.0f; clipped++; }\n\n        processed.WriteSample(y); //записываем полученный семпл\n    }\n\n    WavFile new_file = new WavFile(tbOutputFile.Text); //выходной файл\n    new_file.WriteData(processed);\n\n    MessageBox.Show(\"Файл обработан! Потери данных: \"+\n        ((clipped * 100.0f) / (float)c).ToString(\"F2\")+\" %\");\n\n}\n</code></pre>\n\n<p>Подробную информацию о формате WAV-файлов можно найти здесь: <a href=\"http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html\" rel=\"nofollow noreferrer\">http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html</a></p>\n"}