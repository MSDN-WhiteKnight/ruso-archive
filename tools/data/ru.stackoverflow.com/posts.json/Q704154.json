{"tags":["c++","c++-cli","directx","direct3d"],"owner":{"reputation":1415,"user_id":238013,"user_type":"registered","accept_rate":64,"profile_image":"https://www.gravatar.com/avatar/d4dab84aa4c67525aecd5da391a8e68a?s=128&d=identicon&r=PG&f=1","display_name":"D .Stark","link":"https://ru.stackoverflow.com/users/238013/d-stark"},"is_answered":true,"view_count":549,"answer_count":2,"score":5,"last_activity_date":1505317061,"creation_date":1502307769,"question_id":704154,"link":"https://ru.stackoverflow.com/questions/704154/%d0%98%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-desktop-duplication-api","title":"Использование Desktop Duplication API","body":"<pre><code>#include \"stdafx.h\"\n\n#include \"stdafx.h\"\n#include \"iostream\"\n\n#include \"D3D9.h\"\n#include &lt;Wincodec.h&gt;\n#include &lt;chrono&gt;\n\n#include &lt;shellapi.h&gt;\n#include &lt;d3d11.h&gt;\n#include &lt;dxgi1_2.h&gt;\n#include &lt;Atlbase.h&gt;\n#include &lt;comdef.h&gt;\n\n#include &lt;windows.h&gt;\n#include &lt;shlobj.h&gt;\n#include &lt;shellapi.h&gt;\n#include &lt;dxgi1_2.h&gt;\n#include &lt;d3d11.h&gt;\n#include &lt;memory&gt;\n#include &lt;algorithm&gt;\n#include &lt;string&gt;\n\n#pragma comment(lib, \"D3D11.lib\")\n#pragma comment(lib, \"D3d9.lib\")\n#pragma comment(lib, \"dxgi.lib\")\n\n#pragma comment(lib, \"gdi32.lib\")\n\nusing namespace System;\n\n#define EXIT(hr) { if (FAILED(hr)) \\\n                { Console::WriteLine(\"Error!\"); \\\n                Console::ReadKey(); return -1; } }\n\nHBITMAP ExtractBitmap(ID3D11Texture2D* d3dtex, ID3D11Device* pDevice) \n{\n    HRESULT hr;\n\n    HBITMAP hBitmapTexture = NULL;\n    HGDIOBJ hBitmap;\n\n    D3D11_TEXTURE2D_DESC desc;\n    ID3D11Texture2D* pNewTexture = NULL;\n\n    D3D11_TEXTURE2D_DESC description;\n\n    d3dtex-&gt;GetDesc(&amp;desc);\n    d3dtex-&gt;GetDesc(&amp;description);\n\n    description.BindFlags = 0;\n    description.CPUAccessFlags = D3D11_CPU_ACCESS_READ | D3D11_CPU_ACCESS_WRITE;\n    description.Usage = D3D11_USAGE_STAGING;\n\n    if (FAILED(pDevice-&gt;CreateTexture2D(&amp;description, NULL, &amp;pNewTexture)))\n    {\n        Console::WriteLine(\"CreateTexture2D failed!\");\n        return NULL;\n    }\n\n    ID3D11DeviceContext* ctx = NULL;\n    pDevice-&gt;GetImmediateContext(&amp;ctx);\n\n    ctx-&gt;CopyResource(pNewTexture, d3dtex);\n\n    D3D11_MAPPED_SUBRESOURCE resource;\n    UINT subresource = D3D11CalcSubresource(0, 0, 0);\n    ctx-&gt;Map(pNewTexture, subresource, D3D11_MAP_READ_WRITE, 0, &amp;resource);\n\n    // Copy from texture to bitmap buffer.\n    uint8_t* sptr = reinterpret_cast&lt;uint8_t*&gt;(resource.pData);\n    uint8_t* dptr = new uint8_t[desc.Width*desc.Height * 4];\n\n    for (size_t h = 0; h &lt; desc.Height; ++h)\n    {\n        size_t msize = std::min&lt;size_t&gt;(desc.Width * 4, resource.RowPitch);\n        memcpy_s(dptr, desc.Width * 4, sptr, msize);\n        sptr += resource.RowPitch;\n        dptr += desc.Width * 4;\n    }\n\n    dptr -= desc.Width*desc.Height * 4;\n\n    // Swap BGR to RGB bitmap.\n    uint32_t *dPtr = reinterpret_cast&lt;uint32_t*&gt;(dptr);\n    for (size_t count = 0; count &lt; desc.Width*desc.Height * 4; count += 4)\n    {\n        uint32_t t = *dPtr;\n        uint32_t t1 = (t &amp; 0x00ff0000) &gt;&gt; 16;\n        uint32_t t2 = (t &amp; 0x000000ff) &lt;&lt; 16;\n        uint32_t t3 = (t &amp; 0x0000ff00);\n        uint32_t ta = (t &amp; 0xFF000000);\n        *(dPtr++) = t1 | t2 | t3 | ta;\n    }\n\n    hBitmapTexture = CreateCompatibleBitmap(GetDC(NULL), desc.Width, desc.Height);\n    SetBitmapBits(hBitmapTexture, desc.Width*desc.Height * 4, dptr);\n\n    return (HBITMAP)CopyImage(hBitmapTexture, IMAGE_BITMAP, desc.Width, desc.Height, LR_CREATEDIBSECTION);\n}\n\n\nint main(array&lt;System::String^&gt; ^args)\n{\n    HRESULT hr;\n\n    // Supported feature levels.\n    D3D_FEATURE_LEVEL featureLevels[] =\n    {\n        D3D_FEATURE_LEVEL_11_0,\n        D3D_FEATURE_LEVEL_10_1,\n        D3D_FEATURE_LEVEL_10_0,\n        D3D_FEATURE_LEVEL_9_1\n    };\n\n    D3D_FEATURE_LEVEL d3dFeatLvl;\n    ID3D11Device* pDevice = nullptr;\n    ID3D11DeviceContext* pImmediateContext = nullptr;\n\n    // Get device object.\n    hr = D3D11CreateDevice(NULL, D3D_DRIVER_TYPE_HARDWARE,\n        NULL, 0, featureLevels,\n        ARRAYSIZE(featureLevels),\n        D3D11_SDK_VERSION,\n        &amp;pDevice,\n        &amp;d3dFeatLvl,\n        &amp;pImmediateContext);\n    EXIT(hr);\n\n    // Get DXGI device.\n    IDXGIDevice* DxgiDevice = nullptr;\n    hr = pDevice-&gt;QueryInterface(__uuidof(IDXGIDevice), reinterpret_cast&lt;void**&gt;(&amp;DxgiDevice));\n    EXIT(hr);\n\n    // Get DXGI adapter.\n    IDXGIAdapter* DxgiAdapter = nullptr;\n    hr = DxgiDevice-&gt;GetParent(__uuidof(IDXGIAdapter), reinterpret_cast&lt;void**&gt;(&amp;DxgiAdapter));\n    DxgiDevice-&gt;Release();\n    DxgiDevice = nullptr;\n    EXIT(hr);\n\n    // Get DXGI output.\n    IDXGIOutput* DxgiOutput = nullptr;\n    hr = DxgiAdapter-&gt;EnumOutputs(0, &amp;DxgiOutput);\n    DxgiAdapter-&gt;Release();\n    DxgiAdapter = nullptr;\n    EXIT(hr);\n\n    DXGI_OUTPUT_DESC OutputDesc;\n    DxgiOutput-&gt;GetDesc(&amp;OutputDesc);\n\n    // Query interface for Output1.\n    IDXGIOutput1* DxgiOutput1 = nullptr;\n    hr = DxgiOutput-&gt;QueryInterface(__uuidof(DxgiOutput1), reinterpret_cast&lt;void**&gt;(&amp;DxgiOutput1));\n    DxgiOutput-&gt;Release();\n    DxgiOutput = nullptr;\n    EXIT(hr);\n\n    // Create desktop duplication.\n    IDXGIOutputDuplication* DeskDupl = nullptr;\n    hr = DxgiOutput1-&gt;DuplicateOutput(pDevice, &amp;DeskDupl);\n    DxgiOutput1-&gt;Release();\n    DxgiOutput1 = nullptr;\n    EXIT(hr);\n\n    DXGI_OUTDUPL_DESC OutputDuplDesc;\n    DeskDupl-&gt;GetDesc(&amp;OutputDuplDesc);\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    ID3D11Texture2D* AcquiredDesktopImage = nullptr;\n\n    IDXGIResource* DesktopResource = nullptr;\n    DXGI_OUTDUPL_FRAME_INFO FrameInfo;\n\n    // Get new frame.\n    hr = DeskDupl-&gt;AcquireNextFrame(500, &amp;FrameInfo, &amp;DesktopResource);\n    EXIT(hr);\n\n    // If still holding old frame, destroy it.\n    if (AcquiredDesktopImage)\n    {\n        AcquiredDesktopImage-&gt;Release();\n        AcquiredDesktopImage = nullptr;\n    }\n\n    // Query interface for IDXGIResource.\n    hr = DesktopResource-&gt;QueryInterface(__uuidof(ID3D11Texture2D), reinterpret_cast&lt;void**&gt;(&amp;AcquiredDesktopImage));\n    DesktopResource-&gt;Release();\n    DesktopResource = nullptr;\n    EXIT(hr);\n\n    HBITMAP hBmp = (HBITMAP)ExtractBitmap(AcquiredDesktopImage, pDevice);\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    System::Drawing::Bitmap::FromHbitmap(IntPtr(hBmp))-&gt;Save(\"Screenshot.bmp\");\n\n    Console::WriteLine(\"END!\");\n    Console::ReadKey();\n    return 0;\n}\n</code></pre>\n\n<p>Привожу пример своего исходника по работе с Desktop Duplication API (на C++/CLI).\nК сожалению, не могу добиться от него результата - картинка получается пустая.\nКаким образом можно поправить этот код, чтобы он работал; +добавить цикл, чтобы можно было получать скрины не вызывая функцию целиком.</p>\n"}