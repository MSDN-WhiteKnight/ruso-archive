{"owner":{"reputation":1063,"user_id":269374,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/171ad8e3bc05e7874987ab5765af4064?s=128&d=identicon&r=PG&f=1","display_name":"John","link":"https://ru.stackoverflow.com/users/269374/john"},"is_accepted":false,"score":1,"last_activity_date":1527015173,"last_edit_date":1527015173,"creation_date":1527004151,"answer_id":831820,"question_id":831776,"body":"<p>Странно. Activate() у меня отрабатывает. Сейчас приведу свой пример программы.</p>\n\n<p>Вот PipeManager, который я использовал. Писал не я, сам нашёл где-то (уже не помню где).\n<div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"false\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>    public class NamedPipeManager\r\n    {\r\n        public static string NamedPipeName { get; } = \"MyApplicationName\";\r\n        public event Action&lt;string&gt; ReceiveString;\r\n\r\n        private const string EXIT_STRING = \"__EXIT__\";\r\n        private BackgroundWorker backgroundWorker;\r\n\r\n        public void Start()\r\n        {\r\n            backgroundWorker = new BackgroundWorker();\r\n            backgroundWorker.WorkerReportsProgress = true;\r\n            backgroundWorker.DoWork += BackgroundWorker_DoWork;\r\n            backgroundWorker.ProgressChanged += BackgroundWorker_ProgressChanged;\r\n            backgroundWorker.RunWorkerCompleted += BackgroundWorker_RunWorkerCompleted;\r\n            backgroundWorker.RunWorkerAsync();\r\n        }\r\n\r\n        public void Stop()\r\n        {\r\n            Write(EXIT_STRING);\r\n        }\r\n\r\n        private void BackgroundWorker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)\r\n        {\r\n            backgroundWorker.Dispose();\r\n        }\r\n\r\n        private void BackgroundWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)\r\n        {\r\n            ReceiveString?.Invoke(e.UserState as string);\r\n        }\r\n\r\n        private void BackgroundWorker_DoWork(object sender, DoWorkEventArgs e)\r\n        {\r\n            while (true)\r\n            {\r\n                string result;\r\n                using (var server = new NamedPipeServerStream(NamedPipeName))\r\n                {\r\n                    server.WaitForConnection();\r\n\r\n                    using (StreamReader reader = new StreamReader(server))\r\n                        result = reader.ReadToEnd();\r\n                }\r\n\r\n                if (result == EXIT_STRING)\r\n                    break;\r\n\r\n                backgroundWorker.ReportProgress(0, result);\r\n            }\r\n        }\r\n\r\n        public static bool Write(string[] text, int connectTimeout = 300)\r\n        {\r\n            using (var client = new NamedPipeClientStream(NamedPipeName))\r\n            {\r\n                try\r\n                {\r\n                    client.Connect(connectTimeout);\r\n                }\r\n                catch\r\n                {\r\n                    return false;\r\n                }\r\n\r\n                if (!client.IsConnected)\r\n                    return false;\r\n\r\n                using (StreamWriter writer = new StreamWriter(client))\r\n                {\r\n                    foreach (var a in text)\r\n                        writer.Write(a + '\\n');\r\n                    writer.Flush();\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        public static bool Write(string text, int connectTimeout = 300)\r\n        {\r\n            using (var client = new NamedPipeClientStream(NamedPipeName))\r\n            {\r\n                try\r\n                {\r\n                    client.Connect(connectTimeout);\r\n                }\r\n                catch\r\n                {\r\n                    return false;\r\n                }\r\n\r\n                if (!client.IsConnected)\r\n                    return false;\r\n\r\n                using (StreamWriter writer = new StreamWriter(client))\r\n                {\r\n                    writer.Write(text);\r\n                    writer.Flush();\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>В Program.cs я добавляю 3 статичных поля:</p>\n\n<pre><code> static Mutex Mutex;\n static NamedPipeManager NamedPipeManager;\n static Form1 main;\n</code></pre>\n\n<p>В Main() я в начало добавляю это:</p>\n\n<pre><code> Mutex = new Mutex(true, \"MyApplicationName\", out bool Is);\n if (!Is)\n {\n     NamedPipeManager.Write(\"1\");\n     Application.Exit();\n     return;\n }\n NamedPipeManager = new NamedPipeManager();\n NamedPipeManager.ReceiveString += NamedPipeManager_ReceiveString;\n NamedPipeManager.Start();\n</code></pre>\n\n<p>Естественно в поле main я храню свою основную форму. А событием ReceiveString вызываю этот метод:</p>\n\n<pre><code> private static void NamedPipeManager_ReceiveString(string obj)\n {\n     if (main.WindowState == FormWindowState.Minimized)\n         main.WindowState = FormWindowState.Normal;\n     main.Activate();\n }\n</code></pre>\n\n<p>Специально сейчас попробовал по быстрому написать этот пример. Запускаю один раз приложение - появляется окно. Потом фокусируюсь обратно на проводник, запускаю - опять открывается первое окно. Если сверну и запускаю с проводника, то опять же первоначальное окно запускается.</p>\n\n<p><a href=\"https://i.stack.imgur.com/MDZnv.gif\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/MDZnv.gif\" alt=\"Как работет\"></a></p>\n"}