{"owner":{"reputation":4267,"user_id":192421,"user_type":"registered","accept_rate":48,"profile_image":"https://www.gravatar.com/avatar/e287adb1e5d34863c9e5a5aa6a73d67a?s=128&d=identicon&r=PG","display_name":"pepsicoca1","link":"https://ru.stackoverflow.com/users/192421/pepsicoca1"},"is_accepted":false,"score":5,"last_activity_date":1571280772,"last_edit_date":1571280772,"creation_date":1571217057,"answer_id":1035214,"question_id":1034758,"body":"<blockquote>\n  <p>Какие особенности androidа (по сравнению с windows) делают\n  приоритетной разработку на java перед нативными языками?</p>\n</blockquote>\n\n<p>Ответ очень прост - эти особенности суть мультиплатформенность андроид и моноплатформенность винды.  </p>\n\n<p>То есть если Вы пишете на С++ для винды, то Вы отдаете пользователю экзешник и все работает на всех виндах. Если Вы пишите на С++ для андроида, то Вы должны перетранслировать свой экзешник для всех мобильных платформ, на которых сейчас живет андроид, а их (если мне не изменяет память) уже сейчас пять штук. Также Вам придется перетранслировать свою программу под новую платформу в случае, если андроид будет портирован на какую-то еще платформу (что происходит с завидной регулярностью).  </p>\n\n<p>Вместе с тем, если Вы пишите на Яве, то Вы делаете только один файл с байт-кодом для Ява-машины. А при запуске на конкретной платформе Ява-машина либо интерпретирует Ваш байт-код. Либо JIT-компилятор в андроиде на конкретной платформе конвертирует Ваш байт-код в нативный код и запускает его. Таким образом, при использовании Явы, Вам не надо делать экзешники для всех целевых платформ, на которых живет (и будет жить в будущем) андроид.  </p>\n\n<p>Есть вариант генерировать байт-код после С++ трансляции. И вроде-бы даже есть такие системы. Но они не в мейнстриме. Пока что мобильные приложения не особо нагруженные и производительности Явы вполне хватает, чтобы открыть окно, нарисовать 5-10 кнопок, обратиться к диску, обратиться к сети и запустить веселую анимацию.</p>\n\n<p>UPD1:</p>\n\n<p>Мобильные платформы это на чем сейчас делают мобильные гаджеты, все эти смартфоны, планшеты, навигаторы и прочее. Имеется ввиду, какие процессоры используются в мобильных гаджетах. Если поглядеть в Википедии, то можно узнать, что: \"Android доступен для различных аппаратных платформ, таких как ARM, MIPS, x86\". Но даже архитектура ARM это не один процессор, а куча разных процессоров, у которых наращивалась система команд начиная от ARMv6 и до современных Cortex-ов. Так что внутри разных мобильных устройств стоят довольно разные процессоры. И использование Ява-машин позволяет не делать экзешники для всего этого зоопарка, а обойтись одним файлом байт-кода.</p>\n\n<p>UPD2:</p>\n\n<blockquote>\n  <p>но windows тоже ставят на компьютеры с разными процессорами. Из вики\n  \"Windows работает на платформах x86, x86-64, IA-64 и ARM.</p>\n</blockquote>\n\n<p>Ставить-то ставят, но без байт-кода невозможно иметь переносимый между платформами исполняемый файл. Приходится транслировать программу для всех возможных вариантов аппаратной платформы, что неудобно. О чем, собственно, и идет речь в Вашем вопросе и моем ответе. </p>\n\n<p>Кроме того, Windows для ARM и прочих это не Windows, а Windows CE. Там от Windows осталось только название, а все API другое. Из той же Википедии:</p>\n\n<blockquote>\n  <p>Windows Embedded — это семейство операционных систем реального\n  времени, которое было специально разработано для применения в\n  различных встраиваемых системах. Ядро системы имеет общее с семейством\n  ОС Windows CE и поддерживает процессоры ARM, MIPS, SuperH и x86.</p>\n</blockquote>\n\n<p>Что касается платформ x86, x86-64, IA-64, то </p>\n\n<ol>\n<li>IA-64 - фактически умерла</li>\n<li>x86, x86-64 имеют разные разрядности. Не думаю, что даже байт-код может осуществить переносимость программ разной разрядности, то есть байт-код в данном случае бесполезен.</li>\n</ol>\n\n<p>Тем не менее мы видим, что Микрософт на платформе .Net тоже стал работать с байт-кодом в виде Common Language Runtime и Common Intermediate Language. То есть Микрософт пытается в своих технологиях на будущее тоже заложиться на многоплатформенность. Конечно, сама Windows намертво привязана к архитектуре x86 в том числе и на уровне вызовов функций API с параметрами-регистрами процессора Intel и вряд-ли Windows получится запустить на другой платформе. Так что все эти Common Intermediate Language это задел на будущее, ну или может быть им удастся применить Common Intermediate Language для обеспечения переносимости веб-технологий.</p>\n\n<p>Вместе с тем GCC генерирует код под Windows x86, x86-64 сразу нативный, без всякого байт-кода и горя не знает.</p>\n\n<p>И да, как раз на примере Windows мы видим что отсутствие байт-кода усложняет поддержку многоплатформенности Windows. А наличие байт-кода упрощает поддержку многоплатформенности. Для мобильных устройств многоплатформенность актуальна, поэтому Ява с ее байт-кодом стала популярна для Андроида и поддерживается производителем Андроида.</p>\n\n<p>Просто когда начинался DOS, а потом Windows как преемник DOS, то никто не думал ни о каких других платформах, да и ресурсов для байт-кода и всяких JIT-компиляторов не было. Потом, когда все поумнели, и выяснилось, что процессоры могут быть не только от Intel, то от программных технологий стали требовать и поддержку многоплатформенности, чему Ява с ее байт-кодом отвечает в гораздо большей степени, чем генерация сразу нативного кода.</p>\n\n<p>Вместе с тем, когда начиналась ОС Unix, поддержка многоплатформенности обеспечивалась не байт-кодом и JIT-компилятором, а тем, что приходилось переписывать примерно 10% кода при портировании ОС Unix на новую платформу, включая переписывание кодогенерации транслятора. Но это уже к собственно вопросу не имеет отношения, просто экскурс в историю как пример того, что многоплатформенность можно обеспечивать или быстро и дешево (байт-кодом) или медленно и дорого (переписывая код под другую аппаратную платформу или перетранслируя программы под другую аппаратную платформу).</p>\n"}