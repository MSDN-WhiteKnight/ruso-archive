{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":0,"last_activity_date":1518596369,"creation_date":1518596369,"answer_id":784952,"question_id":676492,"body":"<p>Список загруженных DLL для процесса можно получить с помощью свойства <code>Process.Modules</code>. Для определения инжектированных DLL нужно составить базовый список загруженных модулей при работе данного приложения в чистой среде, затем при выполнении в реальной среде сравнить список DLL с базовым списком:</p>\n\n<pre><code>using System;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.IO;\n\nnamespace WindowsFormsTest1\n{\n    public class DLL\n    {        \n\n        /*Примерный базовый список загруженных DLL для WinForms-приложения в Windows 7*/\n        public static string[] DllWhiteList =\n            \"ntdll.dll MSCOREE.DLL KERNEL32.dll KERNELBASE.dll apphelp.dll AcLayers.DLL SspiCli.dll msvcrt.dll RPCRT4.dll CRYPTBASE.dll sechost.dll USER32.dll GDI32.dll LPK.dll USP10.dll ADVAPI32.dll SHELL32.dll SHLWAPI.dll ole32.dll OLEAUT32.dll USERENV.dll profapi.dll MPR.dll IMM32.DLL MSCTF.dll mscoreei.dll clr.dll MSVCR110_CLR0400.dll WINHTTP.dll webio.dll VERSION.dll PSAPI.DLL mscorlib.ni.dll uxtheme.dll CRYPTSP.dll CRYPT32.dll MSASN1.dll rsaenh.dll msi.dll clrjit.dll nlssorting.dll System.ni.dll System.Drawing.ni.dll System.Windows.Forms.ni.dll comctl32.dll comctl32.dll System.Configuration.ni.dll System.Xml.ni.dll dwmapi.dll gdiplus.dll RpcRtRemote.dll SXS.DLL System.Core.ni.dll System.Xml.Linq.ni.dll System.Data.DataSetExtensions.ni.dll Microsoft.CSharp.ni.dll System.Data.ni.dll System.Data.dll WS2_32.dll NSI.dll System.Deployment.ni.dll sxs.dll SETUPAPI.dll CFGMGR32.dll DEVOBJ.dll propsys.dll\"\n            .Split(\" \".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);\n\n\n        /*Получение списка DLL, загруженных процессом*/\n        public static List&lt;ProcessModule&gt; GetProcessDLLs(Process pr)\n        {\n            var coll = pr.Modules;\n            List&lt;ProcessModule&gt; res = new List&lt;ProcessModule&gt;();\n\n            foreach (ProcessModule y in coll)\n            {\n                if (Path.GetExtension(y.FileName).ToLower().Contains(\"exe\")) continue;\n                if (Path.GetExtension(y.FileName).ToLower().Contains(\"drv\")) continue;\n\n                res.Add(y);\n            }\n            return res;\n        }\n\n        /*Вывод списка предположительно инжектированных DLL*/\n        public static string PrintInjectedDLLs(List&lt;ProcessModule&gt; dllList)\n        {\n            StringBuilder sb = new StringBuilder(1000);\n            sb.AppendLine(\"*** Injected DLLs: ***\");\n            sb.AppendLine();\n            string s;\n\n            foreach (var x in dllList)\n            {\n                if (DllWhiteList.Contains(x.ModuleName)) continue;\n\n                sb.Append(x.ModuleName);\n                try\n                {\n                    s = x.FileVersionInfo.CompanyName;\n                }\n                catch (Exception ex)\n                {\n                    s = ex.GetType().ToString();\n                    Debug.WriteLine(ex.ToString());\n                }\n\n                sb.Append(\" by \" + s);\n                sb.AppendLine();\n            }\n            return sb.ToString();\n        }        \n\n    }\n}\n</code></pre>\n\n<p>Конечно, настоящие вредоносные программы могут перехватывать вызовы API-функций на обнаружение своих DLL. Но некоторые инжектированные модули такой способ позволяет обнаружить.</p>\n"}