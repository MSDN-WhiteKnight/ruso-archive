{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1522063248,"creation_date":1522063248,"answer_id":804823,"question_id":744941,"body":"<blockquote>\n  <p>потому что в PCM, если верить источнику, не должно быть никаких дополнительных данных между BitsPerSample и data</p>\n</blockquote>\n\n<p>Вероятно, слишком поздно, но источник врет. Во-первых, PCM - это способ кодирования, а не формат файла (формат называется RIFF). Во-вторых, согласно спецификации данного формата, он может расширяться в последующих версиях добавлением новых блоков данных (в любом месте между старыми блоками), поэтому приложения для его считывания должны пропускать неизвестные им блоки, а не падать с ошибкой при их появлении. </p>\n\n<p>В данном случае, между заголовком файла и блоком DATA содержится блок INFO, который содержит текстовые сведения о композиции (отлично заметные кракозябры в HEX-редакторе). </p>\n\n<p>Таким образом, правильный алгоритм считывания блоков RIFF-файла выглядит как-то так:</p>\n\n<ol>\n<li>Считать <em>SubchunkID</em> и <em>SubchunkSize</em></li>\n<li>Если <em>SubchunkID</em> - не то, что ожидалось, пропустить <em>SubchunkSize</em> байтов и вернуться на шаг 1</li>\n<li>Иначе, считать и обработать массив байтов, равный <em>SubchunkSize</em></li>\n</ol>\n\n<p>Информацию о формате и ссылки на нормальную документацию можно найти здесь: <a href=\"http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html\" rel=\"nofollow noreferrer\">Audio File Format Specifications</a></p>\n"}