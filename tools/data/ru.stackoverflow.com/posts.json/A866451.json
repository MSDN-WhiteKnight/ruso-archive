{"owner":{"reputation":16068,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1533809877,"creation_date":1533809877,"answer_id":866451,"question_id":866161,"body":"<p>Можно взять за основу код библиотеки для парсинга IL-кода <a href=\"https://www.codeproject.com/Articles/14058/Parsing-the-IL-of-a-Method-Body\" rel=\"nofollow noreferrer\">SDILReader</a>. </p>\n\n<p>IL-код представляет собой набор инструкций, состоящих и 1 или 2-байтного кода и операнда из 0-8 байт. Вызов метода осуществляется инструкцией call или callvirt, операндом для нее является metadata token, который идентифицирует метод в контексте определенного модуля. Таким образом, найти все методы, которые вызывает указанный метод, можно так:</p>\n\n<pre><code>using System.Reflection;\nusing System.Reflection.Emit;\n…\n\npublic static OpCode FindOpCode(short val)\n{\n    OpCode ret = OpCodes.Nop;\n    FieldInfo[] mas = typeof(OpCodes).GetFields();\n    for (int i = 0; i &lt; mas.Length; i++)\n    {\n        if (mas[i].FieldType == typeof(OpCode))\n        {\n            OpCode opcode = (OpCode)mas[i].GetValue(null);\n            if (opcode.Value == val)\n            {\n                ret = opcode;\n                break;\n            }\n        }\n    }\n    return ret;\n}\n\npublic static List&lt;MethodBase&gt; GetCalledMethods(MethodInfo mi)\n{\n    var mb = mi.GetMethodBody();\n    var msil = mb.GetILAsByteArray();\n    var module = MethodInfo.GetCurrentMethod().Module;\n\n    List&lt;MethodBase&gt; methods = new List&lt;MethodBase&gt;();\n\n    short op;\n    int n = 0;\n\n    while (true)\n    {\n        if (n &gt;= msil.Length) break;\n\n        //получаем код операции\n        if (msil[n] == 0xfe)\n            op = (short)(msil[n + 1] | 0xfe00);\n        else\n            op = (short)(msil[n]);\n\n        //найдем имя операции\n        OpCode opcode = FindOpCode(op);\n        string str = opcode.Name;\n        int size = 0;\n\n        //найдем размер операции\n        switch (opcode.OperandType)\n        {\n            case OperandType.InlineBrTarget:  size = 4;  break;\n            case OperandType.InlineField: size = 4; break;\n            case OperandType.InlineMethod:  size = 4;  break;\n            case OperandType.InlineSig: size = 4; break;\n            case OperandType.InlineTok: size = 4;  break;\n            case OperandType.InlineType: size = 4; break;\n            case OperandType.InlineI: size = 4; break;\n            case OperandType.InlineI8: size = 8; break;\n            case OperandType.InlineNone: size = 0;  break;                        \n            case OperandType.InlineR: size = 8;    break;                        \n            case OperandType.InlineString: size = 4; break;                        \n            case OperandType.InlineSwitch: size = 4; break;                        \n            case OperandType.InlineVar: size = 2; break;                        \n            case OperandType.ShortInlineBrTarget: size = 1; break;\n            case OperandType.ShortInlineI: size = 1; break;\n            case OperandType.ShortInlineR: size = 4; break;                        \n            case OperandType.ShortInlineVar: size = 1; break;\n            default:                        \n                    throw new Exception(\"Unknown operand type.\");                        \n        }\n        size += opcode.Size;\n\n        int token = 0;\n        if (str == \"call\" || str == \"callvirt\")\n        {\n            //если это вызов метода, найдем токен\n            token = (((msil[n + 1] | (msil[n + 2] &lt;&lt; 8)) |\n                (msil[n + 3] &lt;&lt; 0x10)) | (msil[n + 4] &lt;&lt; 0x18));\n\n            //надем метод в текущем модуле по токену\n            var method = module.ResolveMethod(token);\n            if(!methods.Contains(method))methods.Add(method);\n        }\n\n        n += size; //пропускаем нужное число байтов\n    }\n\n    return methods;\n}\n</code></pre>\n\n<p>Пример использования:</p>\n\n<pre><code>public static int F(int x)\n{\n    return x*2;\n}\n\npublic static void Test()\n{\n    int x = System.Diagnostics.Process.GetCurrentProcess().Id;\n    MessageBox.Show(x.ToString());\n}\n\nprivate void button1_Click(object sender, EventArgs e)\n{\n    StringBuilder sb = new StringBuilder();\n    int y = 0;\n    Func&lt;int,int&gt; lambda = (x) =&gt; F(x) &gt; F(y) ? F(y) : F(x / 2);\n\n    var methods = GetCalledMethods(lambda.Method);\n    sb.AppendLine(\"Lambda calls:\");\n    foreach (var x in methods) sb.AppendFormat(\"- {0}.{1}()\\r\\n\", x.DeclaringType.ToString(), x.Name);\n    sb.AppendLine();\n\n    methods = GetCalledMethods(this.GetType().GetMethod(\"Test\"));            \n    sb.AppendLine(\"Test method calls:\");\n    foreach (var x in methods) sb.AppendFormat(\"- {0}.{1}()\\r\\n\", x.DeclaringType.ToString(), x.Name);\n\n    textBox1.Text = sb.ToString();\n}   \n</code></pre>\n\n<p>Должно вывести что-то такое:</p>\n\n<blockquote>\n  <p>Lambda calls:<br>\n  - WindowsFormsTest.Form1.F()    </p>\n  \n  <p>Test method calls:<br>\n  - System.Diagnostics.Process.GetCurrentProcess()<br>\n  - System.Diagnostics.Process.get_Id()<br>\n  - System.Int32.ToString()<br>\n  - System.Windows.Forms.MessageBox.Show()  </p>\n</blockquote>\n\n<p>Что касается изменения кода методов во время выполнения, это значительно сложнее, но тоже возможно. См. например здесь: <a href=\"https://www.codeproject.com/Articles/463508/NET-CLR-Injection-Modify-IL-Code-during-Run-time\" rel=\"nofollow noreferrer\">.NET CLR Injection: Modify IL Code during Run-time</a></p>\n"}