{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":8,"last_activity_date":1569306623,"creation_date":1569306623,"answer_id":1027446,"question_id":1025834,"body":"<p>Анализ кода нужен, чтобы проверять код и выявлять возможные ошибки и нарушения его правильности и соответствия лучшим практикам (например, в плане архитектуры или стиля). В современных версиях студии (2017+) анализаторы можно разделить на две группы:</p>\n\n<ul>\n<li><p><em>Анализаторы исходного кода.</em> Эти анализаторы работают в режиме реального времени и могут проверять код, даже если он не компилируется. Специально включать их не нужно, они работают всегда, и с меню <strong>Анализ</strong> они не связаны. Обычно их предупреждения отображаются как всплывающие подсказки прямо в редакторе кода, реже - в результатах компиляции.</p></li>\n<li><p><em>Анализаторы скомпилированных сборок.</em> Этот вид анализаторов запускается только после сборки проекта и проверяет бинарники на соответствие определенным правилам (в основном по архитектуре), выводя предупреждения в результаты компиляции. Не работает для .NET Core. Меню <strong>Анализ</strong> управляет именно этими, \"старыми\" анализаторами. </p></li>\n</ul>\n\n<p>В каких ситуациях использовать анализаторы? Первого вида - видимо всегда, их даже непонятно как отключить (иногда они падают с ошибкой, выводя сообщение в верхней части окна, и анализ перестает работать сам). Второго вида - в зависимости от требований к проекту. Например, имеет смысл их использовать, если вы делаете библиотеку, которой будут пользоваться другие, а если просто программу для себя - скорее всего, нет.</p>\n\n<h1>Использование анализа исходного кода</h1>\n\n<p>Стандартные анализаторы кода в основном проверяют корректность кода с точки зрения языка, правила именования идентификаторов, а также могут выводить предложения по упрощению некоторых элементов синтаксиса.</p>\n\n<p>Создадим проект C#, и добавим в него такой код:</p>\n\n<pre><code>using System;\nusing System.IO;\n\nnamespace NetCoreTest\n{\n    class Program\n    {        \n        public class foo\n        {\n\n        }\n\n        static void Main(string[] args)\n        {            \n            Console.WriteLine(\"Hello World!\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre>\n\n<p>Студия подчеркнет пунктирной линией класс, названный с маленькой буквы, а также выведет в список ошибок сообщение с кодом IDE1006. (Коды, начинающиеся с IDE, относятся к стилю.) Если навести мышью на пунктир, появляется всплывающая подсказка, в которой можно выбрать предложенный вариант исправления. </p>\n\n<p>Также неиспользуемую директиву using студия выделила серым цветом. Это предупреждение по умолчанию не отображается в списке ошибок, но оно также имеет код (IDE0005). Аналогично, можно навести мышью и применить исправление, удаляющее неиспользуемую директиву. </p>\n\n<p><a href=\"https://i.stack.imgur.com/BfbWm.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/BfbWm.png\" alt=\"source analysis\"></a></p>\n\n<p>После исправления:</p>\n\n<pre><code>using System;\n\nnamespace NetCoreTest\n{\n    class Program\n    {        \n        public class Foo\n        {\n\n        }\n\n        static void Main(string[] args)\n        {            \n            Console.WriteLine(\"Hello World!\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre>\n\n<p>Можно установить дополнительные анализаторы, которые будут также проверять архитектуру (у них коды предупреждений начинаются с \"CA\"). Подробнее см. <a href=\"https://docs.microsoft.com/en-us/visualstudio/code-quality/install-roslyn-analyzers\" rel=\"noreferrer\">Install .NET Compiler Platform code analyzers</a>.</p>\n\n<h1>Использование анализаторов скомпилированных сборок</h1>\n\n<p>Создадим проект .NET Framework, и добавим в него код:</p>\n\n<pre><code>using System;\n\nnamespace ConsoleApplication1\n{\n    public class Program\n    {\n        public class Foo { }\n\n        static void Main(string[] argv)\n        {\n            Console.WriteLine(\"Hello world\");\n            Console.ReadKey();\n        }  \n    }\n}\n</code></pre>\n\n<p>Перейдем в свойства проекта, на вкладке <strong>Анализ кода</strong> установим галку \"Включить анализ кода в сборке\" и выберем набор правил \"Базовые нормы и правила разработки Microsoft\" (BasicDesignGuidelineRules.ruleset), или аналогичный более строгий. Выполним сборку проекта. Результат:</p>\n\n<p><a href=\"https://i.stack.imgur.com/q1Rvi.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/q1Rvi.png\" alt=\"assembly analysis\"></a></p>\n\n<p>Разберем предупреждения:</p>\n\n<blockquote>\n  <p>CA1014: Microsoft.Design : Пометьте 'ConsoleApp1.exe' как CLSCompliant(true), поскольку он предоставляет типы, видимые извне.</p>\n</blockquote>\n\n<p>Сборка, содержащая открытые типы, должна быть помеченной как соответствующая спецификации CLS. Раз мы пишем не библиотеку, а программу, то открытых типов в ней быть не должно (оставляя пока за скобками удобство модульного тестирования), поэтому исправлять логично не добавлением атрибута, а удалением public с класса Program.</p>\n\n<blockquote>\n  <p>CA1053: Microsoft.Design : Поскольку тип 'Program' содержит только статические члены, пометьте его как статический, чтобы компилятором не был добавлен общий конструктор по умолчанию.</p>\n</blockquote>\n\n<p>Тут все понятно, у класса Program нет членов экземпляра, поэтому он должен быть static.</p>\n\n<blockquote>\n  <p>CA1801: Microsoft.Usage : Параметр 'argv' в 'Program.Main(string[])' никогда не используется. Удалите этот параметр или используйте его в теле метода.</p>\n</blockquote>\n\n<p>Это не имеет прямого отношения в архитектуре, среда предупреждает нас о неиспользуемом параметре, который можно удалить для упрощения кода.</p>\n\n<blockquote>\n  <p>CA1034: Microsoft.Design : Не делайте тип 'Program.Foo' вложенным. Вместо этого измените режим доступа к нему так, чтобы он не был виден извне.</p>\n</blockquote>\n\n<p>См. <a href=\"https://ru.stackoverflow.com/questions/1024325/\">Публичные вложенные классы - плохая практика?</a> </p>\n\n<hr>\n\n<p>Исправлять в случае этого типа анализаторов нужно вручную. Получаем такой код после исправления этих предупреждений (он правда выводит новое, о неиспользуемом классе Foo):</p>\n\n<pre><code>using System;\n\nnamespace ConsoleApplication1\n{\n    static class Program\n    {\n        class Foo { }\n\n        static void Main()\n        {\n            Console.WriteLine(\"Hello world\");\n            Console.ReadKey();\n        }  \n    }\n}\n</code></pre>\n\n<p>До сих пор мы не коснулись меню <strong>Анализ</strong>. Зачем оно нужно? Пункт \"Выполнить анализ кода\", видимо, рассчитан на те типы проектов, где он не выполняется автоматически при сборке. Для C# он бесполезен. \"Выполнить анализ кода и подавить активные ошибки\" позволяет пометить все текущие ошибки как игнорируемые, в случае, если мы не собираемся их исправлять. \"Настроить анализ кода\" - это просто другой вариант открыть аналогичную страницу свойств проекта. \"Вычислить метрики кода\" - рассчитывает какие-то количественные показатели для кода, в том числе на уровне проектов и классов. Практическая ценность сомнительна, но по крайней мере можно быстро посчитать число строк кода.</p>\n\n<p><a href=\"https://docs.microsoft.com/en-us/visualstudio/code-quality/code-analysis-for-managed-code-overview\" rel=\"noreferrer\">Документация по анализу кода</a> </p>\n"}