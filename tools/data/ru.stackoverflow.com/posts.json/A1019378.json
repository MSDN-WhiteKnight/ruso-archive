{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":1,"last_activity_date":1567356662,"last_edit_date":1567356662,"creation_date":1567334830,"answer_id":1019378,"question_id":1019276,"body":"<p>Логичным решением было бы использовать прокси-сервер. Но, насколько я знаю, для WebBrowser нельзя локально изменить настройки прокси-сервера в конкретном экземпляре (только глобально для Internet Explorer). Поэтому можно использовать другой подход - <a href=\"https://ru.stackoverflow.com/questions/845750/%D0%9F%D0%B5%D1%80%D0%B5%D1%85%D0%B2%D0%B0%D1%82-http-%D1%82%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0/846042#846042\">перехват пакетов на интерфейсах</a>:</p>\n\n<pre><code>using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Threading;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Net.NetworkInformation;\n\nnamespace WpfApplication1\n{\n    public partial class MainWindow : Window\n    {\n        string navigated_host=\"\";\n        object sync = new object();\n\n        public MainWindow()\n        {\n            InitializeComponent();\n            webbrowser.Navigating += webbrowser_Navigating;\n\n            var ips = GetIpAddresses();\n\n            foreach (IPAddress ip in ips)\n            {\n                Thread th = new Thread(ThreadProc);\n                th.IsBackground = true;\n                th.Start((object)ip);   \n            }\n\n        }\n\n        void TextBoxWriteLine(string s)\n        {\n            this.Dispatcher.Invoke(() =&gt;\n            {\n                textbox.Text += s + Environment.NewLine;\n            });\n        }\n\n        void webbrowser_Navigating(object sender, System.Windows.Navigation.NavigatingCancelEventArgs e)\n        {\n            lock (sync)\n            {\n                navigated_host = e.Uri.Host;\n            }\n        }\n\n        //Получает все локальные IP-адреса\n        public static List&lt;IPAddress&gt; GetIpAddresses()\n        {\n            List&lt;IPAddress&gt; res = new List&lt;IPAddress&gt;(10);\n\n            var ifs = NetworkInterface.GetAllNetworkInterfaces();\n\n            foreach (var interf in ifs)\n            {       \n                var ipprop = interf.GetIPProperties();\n                if (ipprop == null) continue;\n                var unicast = ipprop.UnicastAddresses;\n                if (unicast == null) continue;\n\n                //находим первый Unicast-адрес\n                foreach (var addr in unicast)\n                {\n                    if (addr.Address.AddressFamily != AddressFamily.InterNetwork) continue;\n                    res.Add(addr.Address);\n                    break;\n                }\n            }\n\n            return res;\n        }\n\n        const byte PROTO_TCP = 6;  \n\n        public string ParseIpPacket(byte[] data, IPAddress src_ip)\n        {\n            ushort dummy;\n            byte b;\n\n            MemoryStream ms = new MemoryStream(data);\n            BinaryReader br = new BinaryReader(ms);\n            uint header_len;\n            uint total_len;\n            IPAddress src,dst;\n            string host=\"\";            \n\n            //parse IP packet header\n            using (ms)\n            using (br)\n            {\n                b = br.ReadByte();\n                byte ver = (byte)((b &amp; (byte)0xF0) &gt;&gt; 4); //IP version\n                if (ver != 4)\n                {\n                    TextBoxWriteLine(\"Unsupported IP version: \"+ ver.ToString());\n                    return null;\n                }                \n\n                byte ihl = (byte)(b &amp; (byte)0x0F);//header length\n                header_len = ihl * 4u;\n\n                b = br.ReadByte();\n\n                //packet length\n                byte[] temp = new byte[2];\n                temp[1] = br.ReadByte();\n                temp[0] = br.ReadByte();\n                total_len = BitConverter.ToUInt16(temp, 0);\n\n                dummy = br.ReadUInt16();\n                dummy = br.ReadUInt16();\n\n                byte ttl = br.ReadByte();\n                byte proto = br.ReadByte();\n\n                dummy = br.ReadUInt16();\n\n                //source IP\n                temp = new byte[4];\n                temp[0] = br.ReadByte();\n                temp[1] = br.ReadByte();\n                temp[2] = br.ReadByte();\n                temp[3] = br.ReadByte();\n                src = new IPAddress(temp);                \n\n                //destination IP\n                temp[0] = br.ReadByte();\n                temp[1] = br.ReadByte();\n                temp[2] = br.ReadByte();\n                temp[3] = br.ReadByte();\n                dst = new IPAddress(temp);                \n\n                if (proto != PROTO_TCP) return null;  \n            }\n\n            //Parse TCP packet\n            uint tcp_size = total_len - header_len;\n            byte[] tcp_data = new byte[tcp_size];\n            Array.Copy(data, header_len, tcp_data, 0, tcp_size);\n\n            ms = new MemoryStream(tcp_data);\n            br = new BinaryReader(ms);\n            byte tcp_header_size;\n            uint http_size;\n\n            using (ms)\n            using (br)\n            {\n                var src_port = br.ReadUInt16();\n                var dst_port = br.ReadUInt16();                \n                br.ReadUInt32();\n                br.ReadUInt32();\n                tcp_header_size = (byte)(br.ReadByte() &gt;&gt; 4);\n                tcp_header_size *= 4;\n                http_size = tcp_size - tcp_header_size;\n            }\n\n            byte[] http_data = new byte[http_size];\n            Array.Copy(tcp_data, tcp_header_size, http_data, 0, http_size);                        \n\n            //Parse HTTP data\n            string res = Encoding.UTF8.GetString(http_data);\n            string[] arr = res.Split(\"\\n\\r\".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);\n\n            if (arr.Length &gt; 2 &amp;&amp; arr[0].StartsWith(\"GET\") &amp;&amp; arr[0].Contains(\"HTTP/\"))\n            {\n                //найдем поле Host\n                for (int i = 1; i &lt; arr.Length; i++)\n                {\n                    if (arr[i].StartsWith(\"Host: \"))\n                    {\n                        host = arr[i].Replace(\"Host: \", \"\");\n                        break;\n                    }\n                }\n\n                if (host == \"\")\n                {\n                    //пытаемся получить имя узла из обратного DNS\n                    try\n                    {\n                        host = Dns.GetHostEntry(dst).HostName;\n                    }\n                    catch (SocketException)\n                    {\n                        host = \"\";\n                    }\n                }                \n\n                lock (sync)\n                {\n                    if (host == navigated_host)\n                    {\n                        return res;\n                    }\n                }\n            }\n\n            return null;\n        }        \n\n        public void ThreadProc(object args)\n        {\n            var mainSocket = new Socket(AddressFamily.InterNetwork, SocketType.Raw,\n                       ProtocolType.IP);\n\n            IPAddress ipaddr=(IPAddress)args;            \n\n            //начинаем прослушивание пакетов на интерфейсе...\n            mainSocket.Bind(new IPEndPoint(ipaddr, 0));\n\n            mainSocket.SetSocketOption(SocketOptionLevel.IP,  //Applies only to IP packets\n                           SocketOptionName.HeaderIncluded, //Set the include header\n                           true);                           //option to true\n\n            byte[] byTrue = new byte[4] { 1, 0, 0, 0 };\n            byte[] byOut = new byte[4];\n\n            //Socket.IOControl is analogous to the WSAIoctl method of Winsock 2\n            mainSocket.IOControl(IOControlCode.ReceiveAll,  //SIO_RCVALL of Winsock\n                     byTrue, byOut);\n\n            byte[] buffer = new byte[1024*20];\n            int res;            \n\n            while (true)\n            {\n                try\n                {\n                    res = mainSocket.Receive(buffer);                    \n\n                    var result = ParseIpPacket(buffer, ipaddr);\n\n                    if (result != null)\n                    {\n                        TextBoxWriteLine(result);\n                    }                    \n                }\n                catch (Exception ex)\n                {\n                    if (ex.GetType() != typeof(System.Threading.Tasks.TaskCanceledException))\n                    {\n                        TextBoxWriteLine(ex.ToString());\n                    }\n                }\n            } \n        }          \n    }       \n}\n</code></pre>\n\n<p>Работает только с IPv4-интерфейсами и протоколом HTTP (не HTTPS). Для запуска требуются права администратора.</p>\n"}