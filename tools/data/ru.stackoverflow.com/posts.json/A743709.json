{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":3,"last_activity_date":1510505754,"creation_date":1510505754,"answer_id":743709,"question_id":661489,"body":"<p>У аудиоустройства, помимо задаваемого <code>PKEY_AudioEngine_DeviceFormat</code> формата вывода звука, есть внутренний формат обработки звука. (См. <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/dd370811(v=vs.85).aspx\" rel=\"nofollow noreferrer\">Device Formats</a> ) Этот формат может иметь параметры, отличающиеся от формата вывода (обычно, он использует 32-битные IEEE Float сэмплы, независимо от формата сэмплов в выводе), но число каналов и частота дискретизации у них должны быть одинаковыми, иначе при попытке воспроизведения звука будет выводится ошибка. Таким образом, помимо установки <code>PKEY_AudioEngine_DeviceFormat</code>, нужно установить значения частоты дискретизации и числа каналов, соответствующие новому формату, в свойстве внутреннего формата (при этом не трогая остальные его поля!)</p>\n\n<p>Microsoft не предоставляют документированный API для установки внутреннего формата, видимо потому что они не хотят, чтобы программы без ведома пользователя его меняли. Ключи реестра также не документированы. Если воспользоваться <em>Process Monitor</em> и отследить изменения реестра при переключении формата в панели управления, можно выявить, какие свойства изменяются. (Если также иметь установленный <em>WinDBG</em>, можно увидеть по стеку, что служба Аудио вызывает метод <code>SetDeviceFormat</code> недокументированного интерфейса <a href=\"https://github.com/tartakynov/audioswitch/blob/master/IPolicyConfig.h\" rel=\"nofollow noreferrer\">IPolicyConfig</a>. Наверное, можно попробовать тоже его вызывать, но непонятно, что именно передавать в параметрах...) Итак, исследования показали, что внутренний формат хранится в следующих свойствах:</p>\n\n<p><strong>Windows 7</strong>:</p>\n\n<blockquote>\n  <p>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\MMDevices\\Audio\\Render{...}\\Properties<br>\n  {e4870e26-3cc5-4cd2-ba46-ca0a9a70ed04},0</p>\n</blockquote>\n\n<p><strong>Windows 10</strong>:</p>\n\n<blockquote>\n  <p>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\MMDevices\\Audio\\Render{...}\\Properties<br>\n  {e4870e26-3cc5-4cd2-ba46-ca0a9a70ed04},0<br>\n  {3d6e1656-2e50-4c4c-8d85-d0acae3c6c68},2<br>\n  {3d6e1656-2e50-4c4c-8d85-d0acae3c6c68},3<br>\n  {624f56de-fd24-473e-814a-de40aacaed16},3</p>\n</blockquote>\n\n<p>Вспомогательная функция для изменения свойства аудиоформата:</p>\n\n<pre><code>#define INITGUID\n#include &lt;stdio.h&gt;\n#include &lt;tchar.h&gt;\n#include &lt;Windows.h&gt;\n#include &lt;Objbase.h&gt;\n#include &lt;Shobjidl.h&gt;\n#include &lt;MMDeviceAPI.h&gt;\n#include &lt;Mmreg.h&gt;\n#include &lt;locale.h&gt;\n#include &lt;Functiondiscoverykeys_devpkey.h&gt;\n\n#pragma comment(lib, \"winmm.lib\")\n#pragma comment(lib, \"strmiids.lib\")\n#pragma comment(lib, \"quartz.lib\")\n#pragma comment(lib, \"uuid.lib\")\n\n\n//property key для свойств, представляющих внутренний формат аудио\nDEFINE_PROPERTYKEY(PKEY_InternalAudioFormat, 0xe4870e26, 0x3cc5, 0x4cd2, 0xba, 0x46, 0xca, 0xa, 0x9a, 0x70, 0xed, 0x4, 0);\nDEFINE_PROPERTYKEY(PKEY_InternalAudioFormat2, 0x3d6e1656, 0x2e50, 0x4c4c, 0x8d, 0x85, 0xd0, 0xac, 0xae, 0x3c, 0x6c, 0x68, 2);\nDEFINE_PROPERTYKEY(PKEY_InternalAudioFormat3, 0x3d6e1656, 0x2e50, 0x4c4c, 0x8d, 0x85, 0xd0, 0xac, 0xae, 0x3c, 0x6c, 0x68, 3);\nDEFINE_PROPERTYKEY(PKEY_InternalAudioFormat4, 0x624f56de, 0xfd24, 0x473e, 0x81, 0x4a, 0xde, 0x40, 0xaa, 0xca, 0xed, 0x16, 3);\n\n/* Функция SetFormatProperty: Изменение свойства формата аудио в объекте IPropertyStore, свзянном с AudioEndpoint\nПараметры:\n propertyStore - объект IPropertyStore, в котором необходимо изменить свойство\n PROPERTYKEY - идентификатор свойства\n freq - частота дискретизации (Гц)\n channels - число каналов\n bitsPerSample - битов на сэмпл (0 - не указано)\n*/\nbool SetFormatProperty(IPropertyStore* propertyStore,PROPERTYKEY pkey,int freq,int channels,int bitsPerSample){\n\n    HRESULT hr;\n    PROPVARIANT format;\n    PropVariantInit(&amp;format);\n    WAVEFORMATEXTENSIBLE wext;\n\n    hr = propertyStore-&gt;GetValue(pkey, &amp;format);//получаем текущее значение свойства\n    if(FAILED(hr)) {printf(\"Can't get property: HRESULT 0x%x\\n\",hr);return false;}\n\n    if(format.blob.cbSize!=sizeof(WAVEFORMATEXTENSIBLE)){\n        return false;\n    }\n\n    memcpy_s(&amp;wext,sizeof(wext),format.blob.pBlobData,sizeof(wext));//копируем значение в структуру\n\n    wext.Format.nChannels=channels;//число каналов\n    wext.Format.nSamplesPerSec=freq;//частота дискретизации\n\n    int new_bits=wext.Format.wBitsPerSample;//новое число бит на сэмпл\n    int new_valid_bits=wext.Samples.wValidBitsPerSample;//новое число используемых бит на сэмпл\n\n    if(bitsPerSample!=0){//если указано bitsPerSample, изменяем число бит\n            new_bits=bitsPerSample;\n            new_valid_bits=bitsPerSample;\n    }\n\n    PROPVARIANT varName={0};//переменная для нового значения свойства\n    PropVariantInit(&amp;varName);\n    varName.vt = VT_BLOB;\n    varName.blob.cbSize = sizeof(WAVEFORMATEXTENSIBLE);\n\n    int alignment = wext.Format.nChannels * new_bits / 8;//вычисляем размер блока\n\n    WAVEFORMATEXTENSIBLE fmt = { //заполняем параметры формата\n        {\n                WAVE_FORMAT_EXTENSIBLE,\n                wext.Format.nChannels,\n                wext.Format.nSamplesPerSec,\n                wext.Format.nSamplesPerSec * alignment,\n                alignment,\n                new_bits,\n                (sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX))\n        },\n        {new_valid_bits},\n        wext.dwChannelMask,\n        wext.SubFormat\n    };\n    varName.blob.pBlobData = (BYTE*)&amp;fmt;           \n\n    hr = propertyStore-&gt;SetValue(pkey, varName);//устанавливаем значение свойства\n    if (hr != S_OK)printf(\"SetValue failed. HRESULT: 0x%x\\n\",(int)hr);\n\n    PropVariantClear(&amp;format);\n    return (SUCCEEDED(hr));\n\n}\n</code></pre>\n\n<p>Пример кода для установки формата для устройства с указанным ID (запускать с правами администратора):</p>\n\n<pre><code>int _tmain(int argc, _TCHAR* argv[])\n{\n    DWORD dwMode = STGM_READWRITE;//режим доступа для Property store: Чтение и запись\n    wchar_t DeviceId[]=L\"{0.0.0.00000000}.{ba946f3e-7cb9-4abf-a84c-a71bd014eb1c}\";//ID нужного устройства\n\n    setlocale(LC_ALL,\"Russian\");    \n    CoInitialize(NULL);\n\n    TCHAR* pstr=NULL;\n    DWORD state;\n\n    IMMDeviceEnumerator *deviceEnumerator = NULL;\n    IMMDeviceCollection *deviceCollection = NULL;\n    IMMDevice* dev=NULL;\n    IPropertyStore *propertyStore=NULL;\n\n    WAVEFORMATEXTENSIBLE wext;\n    bool res;\n\n    //Create Device Enumerator\n    HRESULT hr = CoCreateInstance(__uuidof(MMDeviceEnumerator), NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&amp;deviceEnumerator));\n    if(FAILED(hr)) {printf(\"CoCreateInstance fail: HRESULT 0x%x\",hr);goto End;}\n\n    hr = deviceEnumerator-&gt;EnumAudioEndpoints(eRender,  DEVICE_STATE_ACTIVE, &amp;deviceCollection);\n    if(FAILED(hr)) {printf(\"EnumAudioEndpoints fail: HRESULT 0x%x\\n\",hr);goto End;}\n\n    UINT deviceCount;\n    hr = deviceCollection-&gt;GetCount(&amp;deviceCount);\n    if(FAILED(hr)) {printf(\"GetCount fail: HRESULT 0x%x\\n\",hr);goto End;}\n\n    //находим нужное устройство\n    for (UINT DeviceIndex = 0 ; DeviceIndex &lt; deviceCount; DeviceIndex++)\n    {\n        deviceCollection-&gt;Item(DeviceIndex,&amp;dev);\n        if(FAILED(hr)) {printf(\"Item fail: 0x%x\\n\",hr);goto Next;}\n\n        dev-&gt;GetId(&amp;pstr);\n        if(FAILED(hr)) {printf(\"Can't get device ID: HRESULT 0x%x\\n\",hr);goto Next;}\n\n        if(wcscmp(pstr,DeviceId)==0) { //устанавливаем свойства...\n\n            hr = dev-&gt;OpenPropertyStore(dwMode, &amp;propertyStore);        \n            if(FAILED(hr)) {printf(\"Can't open property store: HRESULT 0x%x\\n\",hr);goto Next;}\n\n            //формат вывода: заменяем частоту, число каналов и битность         \n            res=SetFormatProperty(propertyStore,PKEY_AudioEngine_DeviceFormat,44100,2,16);  \n            if(!res){printf(\"Can't set PKEY_AudioEngine_DeviceFormat!\\n\");goto Next;}\n\n            //внутренный формат: заменяем только частоту и число каналов            \n            SetFormatProperty(propertyStore,PKEY_InternalAudioFormat,44100,2,0);            \n            SetFormatProperty(propertyStore,PKEY_InternalAudioFormat2,44100,2,0);           \n            SetFormatProperty(propertyStore,PKEY_InternalAudioFormat3,44100,2,0);           \n            SetFormatProperty(propertyStore,PKEY_InternalAudioFormat4,44100,2,0);           \n        }       \n\n        /* ****************** */\n\nNext:   \n        if(dev!=NULL){dev-&gt;Release();dev=NULL;}\n        if(propertyStore!=NULL){propertyStore-&gt;Release();propertyStore=NULL;}\n\n    }//end for\n\n\nEnd:if(dev!=NULL){dev-&gt;Release();dev=NULL;}\n    if(propertyStore!=NULL){propertyStore-&gt;Release();propertyStore=NULL;}\n    if(deviceEnumerator!=NULL){deviceEnumerator-&gt;Release();deviceEnumerator=NULL;}\n    if(deviceCollection!=NULL){deviceCollection-&gt;Release();deviceCollection=NULL;}  \n\n    CoUninitialize();\n    system(\"PAUSE\");\n    return 0;\n}\n</code></pre>\n"}