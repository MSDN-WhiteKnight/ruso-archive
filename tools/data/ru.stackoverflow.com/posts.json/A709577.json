{"owner":{"reputation":86704,"user_id":2739,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/ab989679e335db72e76f067755f34fdd?s=128&d=identicon&r=PG","display_name":"KoVadim","link":"https://ru.stackoverflow.com/users/2739/kovadim"},"is_accepted":true,"score":4,"last_activity_date":1503491707,"creation_date":1503491707,"answer_id":709577,"question_id":708052,"body":"<p>Есть такая штука - <a href=\"https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9\" rel=\"nofollow noreferrer\">ABI</a> - то есть описание того, как функция/класс будет представлена в бинарном виде. Это очень важно, когда линкуются два разных куска кода (например, exe и статическая библиотка) или просто вызываются (например, обращение к dll). В некоторых случаях линковщик (а это его работа) может проверить, что интерфейс не совпадает и поднять панику. А может и не знать или проигнорировать.</p>\n\n<p>Если два куска кода не совместимы на уровне ABI, то может произойти все что угодно. Самый простой пример - вызывающая сторона ожидает параметры в регистрах, а вызываемая - в стеке. Что именно прочитается со стека - никто не знает. В лучшем случае упадет с Access violation.</p>\n\n<p>В случае чистого Си эту проблему достаточно хорошо решили (всякие stdcall, cdecl и подобное). А вот в случае с++ все сильно сложнее - есть классы, а им нужно хранить данные, которые никак не стандартизированы. Даже если использовать только gcc, он может использовать различное ABI. Из последнего, на что я лично натолкнулся, это сильно измененный ABI при переходе от 4.9.х на 5.4.х (он вроде после 5.2 поменялся). <a href=\"https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html\" rel=\"nofollow noreferrer\">Здесь</a> есть много деталей.</p>\n\n<p><strong>Теперь ближе к проблеме.</strong> По внешнему виду файла обычно сложно догадаться, какой версией компилятора он собран. Но её можно попробовать угадать. Судя по всему, там внутри все собрано с помощью vc6 (это очень древнее существо) и более-менее свежие gcc с ним поэтому и не совместимы. А старые - да. @VadimTagil просто повезло, что он угадал правильную версию.</p>\n\n<p><strong>Что делать?</strong> использовать gcc 3.4 как не очень, как по мне, поэтому, лучше взять сорцы и пересобрать их именно тем gcc, которым будет собираться все остальное. Благое дело, там есть makefile и студийный проект.</p>\n"}