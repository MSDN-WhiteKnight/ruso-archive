{"owner":{"reputation":10115,"user_id":9784,"user_type":"registered","profile_image":"https://i.stack.imgur.com/diiT0.png?s=128&g=1","display_name":"Zergatul","link":"https://ru.stackoverflow.com/users/9784/zergatul"},"is_accepted":true,"score":4,"last_activity_date":1563529808,"last_edit_date":1563529808,"creation_date":1536681658,"answer_id":880147,"question_id":880130,"body":"<p>Есть несколько причин, почему это невозможно.</p>\n\n<p><code>Marshal.PtrToStructure&lt;Point&gt;</code> создает копию структуры. Например,\n   если вы присвоите результат в локальную переменную, копия\n   структуры переместится в стек. После вызова этого метода, вы можете\n   изменять память, откуда была скопирована структура, и с вашей копией\n   ничего не случиться. Как видно, сама операция безопасна с точки зрения целостности программы.</p>\n\n<p>Под <code>Marshal.PtrToClass&lt;MyClass&gt;</code> вы скорее всего подразумеваете разыменование указателя (по аналогии с С++). Сборщик мусора может остановить выполнение целой программы в любом месте, и переместить объекты в памяти. Может случиться что-то такое:</p>\n\n<pre><code>IntPtr ptr = получить_указатель_на_экземпляр_класса();\n// здесь сборщик мусора остановил потоки, и переместил класс в новое место\nMyClass instance = Marshal.PtrToClass&lt;MyClass&gt;(ptr); // ptr указывает непонятно куда\n</code></pre>\n\n<p><code>Marshal.PtrToStructure</code> был придуман для взаимодействия с нативным кодом. <code>.NET</code>-классы не могут в обычном понимании существовать в нативном коде, поэтому <code>PtrToClass</code> не существует.</p>\n\n<p>Так же есть простой способ при помощи <code>GCHandle</code>, который запрещает перемещение объектов в памяти.</p>\n\n<p>Но на C# можно и такое сделать:</p>\n\n<pre><code>private static unsafe T PtrToClass&lt;T&gt;(IntPtr ptr)\n{\n    T temp = default(T);\n    TypedReference tr = __makeref(temp);\n    Marshal.WriteIntPtr(*(IntPtr*)(&amp;tr), ptr);\n\n    T instance = __refvalue(tr, T);\n    return instance;\n}\n</code></pre>\n\n<p>Пример использования:</p>\n\n<pre><code>class MyClass\n{\n    public int Value;\n}\nstatic unsafe void Main(string[] args)\n{\n    var instance1 = new MyClass { Value = 123 };\n    var instance2 = new MyClass { Value = 321 };\n\n    // запрещаем перемещение объектов в памяти\n    var gh1 = GCHandle.Alloc(instance1, GCHandleType.Pinned);\n    var gh2 = GCHandle.Alloc(instance2, GCHandleType.Pinned);\n\n    TypedReference tr1 = __makeref(instance1);\n    TypedReference tr2 = __makeref(instance2);\n\n    IntPtr ptr1 = **(IntPtr**)(&amp;tr1);\n    IntPtr ptr2 = **(IntPtr**)(&amp;tr2);\n\n    var instance3 = PtrToClass&lt;MyClass&gt;(ptr1);\n    var instance4 = PtrToClass&lt;MyClass&gt;(ptr2);\n    Console.WriteLine(instance3.Value);\n    Console.WriteLine(instance4.Value);\n\n    // разрешаем GC перемещать объекты\n    gh1.Free();\n    gh2.Free();\n}\n</code></pre>\n"}