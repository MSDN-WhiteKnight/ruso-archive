{"owner":{"reputation":22878,"user_id":32793,"user_type":"registered","accept_rate":48,"profile_image":"https://i.stack.imgur.com/6Vktl.jpg?s=128&g=1","display_name":"iluxa1810","link":"https://ru.stackoverflow.com/users/32793/iluxa1810"},"is_accepted":false,"score":3,"last_activity_date":1547151805,"creation_date":1547151805,"answer_id":930705,"question_id":930603,"body":"<p>Дополню вопрос касательно нативных DLL на основании этого <a href=\"https://stackoverflow.com/questions/6452951/how-to-dynamically-load-and-unload-a-native-dll-file\">ответа</a>:</p>\n\n<p>Нужно через P/Invoke описать 2 функции:</p>\n\n<pre><code>[DllImport(\"kernel32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\nprivate static extern IntPtr LoadLibrary(string libname);\n\n[DllImport(\"kernel32.dll\", CharSet = CharSet.Auto)]\nprivate static extern bool FreeLibrary(IntPtr hModule);\n\n//Load\nIntPtr Handle = LoadLibrary(fileName);\nif (Handle == IntPtr.Zero)\n{\n     int errorCode = Marshal.GetLastWin32Error();\n     throw new Exception(string.Format(\"Failed to load library (ErrorCode: {0})\",errorCode));\n}\n\n//Free\nif(Handle != IntPtr.Zero)\n        FreeLibrary(Handle);\n</code></pre>\n\n<p>Если мы хотим работать с функцией из загруженной либы(а мы это хотим, иначе не грузили бы), то нужно еще определить <code>GetProcAddress</code></p>\n\n<pre><code>[DllImport(\"kernel32.dll\", CharSet = CharSet.Ansi)]\nprivate static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName); \n\n\n    IntPtr funcaddr = GetProcAddress(Handle,functionName);\n</code></pre>\n\n<p>И потом создать делегат</p>\n\n<pre><code>YourFunctionDelegate function = Marshal.GetDelegateForFunctionPointer(funcaddr,typeof(YourFunctionDelegate )) as YourFunctionDelegate ;\nfunction.Invoke(pass here your parameters);\n</code></pre>\n\n<p>Помните, что C# не поддерживает работу с неуправляемыми объектами=> возможны только API вызовы. Если нужно создавать неуправляемые объекты, то нужно делать прослойку на <code>C++/CLI</code></p>\n"}