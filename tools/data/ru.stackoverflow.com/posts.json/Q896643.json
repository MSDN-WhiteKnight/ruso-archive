{"tags":["c#","winapi","dll","pinvoke","interop"],"owner":{"reputation":4994,"user_id":206435,"user_type":"registered","accept_rate":78,"profile_image":"https://www.gravatar.com/avatar/aff8ab0e5f74d01facde887535318d53?s=128&d=identicon&r=PG","display_name":"ヒミコ","link":"https://ru.stackoverflow.com/users/206435/%e3%83%92%e3%83%9f%e3%82%b3"},"is_answered":true,"view_count":64,"answer_count":2,"score":1,"last_activity_date":1540321637,"creation_date":1540274120,"last_edit_date":1540321637,"question_id":896643,"link":"https://ru.stackoverflow.com/questions/896643/%d0%9f%d0%be%d0%bf%d1%8b%d1%82%d0%ba%d0%b0-%d0%b7%d0%b0%d0%b3%d1%80%d1%83%d0%b7%d0%ba%d0%b0-%d0%b1%d0%b8%d0%b1%d0%bb%d0%b8%d0%be%d1%82%d0%b5%d0%ba%d0%b8-%d0%b8%d0%bb%d0%b8-%d0%bf%d1%80%d0%be%d0%b2%d0%b5%d1%80%d0%ba%d0%b0-%d0%bd%d0%b0-%d0%b7%d0%b0%d0%b3%d1%80%d1%83%d0%b6%d0%b5%d0%bd%d0%bd%d0%be%d1%81%d1%82%d1%8c","title":"Попытка загрузка библиотеки, или проверка на загруженность","body":"<p>Что лучше делать с самого начала, проверить загружен ли модуль в память процесса, или попытаться его загрузить, словить ошибку через <code>GetLastError</code>, проверить ее значение, и в случае если библиотека уже загружена вызвать <code>GetModuleHandle</code>, или сделать все наоборот?</p>\n\n<p>Т.е. примерно так, но не только проверять на <code>IntPtr.Zero</code> а еще проверить <code>LastError</code> на совпадение с кодом ошибки (<em>номер кода ошибки пока не знаю поэтому там нет данной проверки</em>)?</p>\n\n<p>Хотя если модуль был загружен то <code>LoadLibrary</code> возвращает его <code>Handle</code> а не бросает ошибку, что странно.</p>\n\n<pre><code>internal static class WinApi\n{\n    internal static bool FreeLibrary(IntPtr moduleHandle)\n    {\n        return FreeLibraryEx(moduleHandle);\n    }\n\n    internal static TDelegateType GetProcDelegate&lt;TDelegateType&gt;(IntPtr moduleHandle, string procName)\n        where TDelegateType : Delegate\n    {\n        return Marshal.GetDelegateForFunctionPointer&lt;TDelegateType&gt;(GetProcAddressEx(moduleHandle, procName));\n    }\n\n    internal static SafeLibrary LoadLibrary(string modulePath)\n    {\n        IntPtr result = LoadLibraryEx(modulePath);\n        if (result == IntPtr.Zero &amp;&amp; (result = GetModuleHandleEx(Path.GetFileName(modulePath))) == IntPtr.Zero)\n        {\n            throw new Win32Exception(Marshal.GetLastWin32Error());\n        }\n\n        return result;\n    }\n\n    #region Private native Methods\n\n    [DllImport(Libraries.Kernel32, SetLastError = true, EntryPoint = \"LoadLibrary\",\n        CallingConvention = CallingConvention.Winapi)]\n    private static extern IntPtr LoadLibraryEx(string modulePath);\n\n    [DllImport(Libraries.Kernel32, CallingConvention = CallingConvention.Winapi, EntryPoint = \"FreeLibrary\",\n        SetLastError = true)]\n    [return: MarshalAs(UnmanagedType.Bool)]\n    private static extern bool FreeLibraryEx(IntPtr moduleHandle);\n\n    [DllImport(Libraries.Kernel32, CallingConvention = CallingConvention.Winapi, EntryPoint = \"GetProcAddress\",\n        CharSet = CharSet.Ansi, SetLastError = true)]\n    private static extern IntPtr GetProcAddressEx(IntPtr moduleHandle, string procedureName);\n\n    [DllImport(Libraries.Kernel32, CallingConvention = CallingConvention.Winapi, SetLastError = true,\n        EntryPoint = \"GetModuleHandle\")]\n    private static extern IntPtr GetModuleHandleEx(string moduleName);\n\n    #endregion\n}\n</code></pre>\n"}