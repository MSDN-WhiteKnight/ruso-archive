{"owner":{"reputation":316,"user_id":271366,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/b6ed83ad1d797a7b2333c48cb3f6baf2?s=128&d=identicon&r=PG&f=1","display_name":"digital-mag","link":"https://ru.stackoverflow.com/users/271366/digital-mag"},"is_accepted":false,"score":1,"last_activity_date":1564075005,"last_edit_date":1564075005,"creation_date":1564069315,"answer_id":1006715,"question_id":1006349,"body":"<p>Ответ лежит рядом. Все комментарии выше верны, но вы создаете динамический метод <code>DynamicMethod</code>, который не принадлежит ни одному экземпляру класса, к которому принадлежат call() и test(). Это не плохо и не хорошо: ваш метод просто висит в воздухе. То есть ваш emit создает примерно следующее: </p>\n\n<pre><code>class Test{\n    public static int test(string v1, int v2)\n    { \n        return (int)call(new object[]{ v1, v2 });\n    }    \n}\n\nclass Call{\n    public object call(object[] args)\n    {\n        // что-то возвращающее int\n    }\n}\n</code></pre>\n\n<p>Такое не скомпилируется</p>\n\n<p>Чтобы обратиться к методу call экземпляра вашего класса необходимо либо загрузить  (либо передать) в ваш метод экземпляр класса Call (в вашем случае, это, видимо, <code>Form1</code>), либо создать динамический метод call подобно тому, как вы создали test, либо сделать call статическим. Последний способ наиболее простой:</p>\n\n<pre><code>class Program\n{\n    static void Main(string[] args)\n    {\n\n        var a = new MyClass().test(\"d\", 5);\n\n        Console.WriteLine(a);\n\n        Type[] arg_types = new Type[] { typeof(string), typeof(int) };\n        var dn = new DynamicMethod(\"myMethod\", typeof(int), arg_types, typeof(MyClass));\n        var il = dn.GetILGenerator();                        \n        il.Emit(OpCodes.Ldc_I4_2);\n        il.Emit(OpCodes.Newarr, typeof(object));\n        il.Emit(OpCodes.Dup);\n        il.Emit(OpCodes.Ldc_I4_0);\n        il.Emit(OpCodes.Ldarg_0);\n        il.Emit(OpCodes.Stelem_Ref);\n        il.Emit(OpCodes.Dup);\n        il.Emit(OpCodes.Ldc_I4_1);\n        il.Emit(OpCodes.Ldarg_1);\n        il.Emit(OpCodes.Box, typeof(int));\n        il.Emit(OpCodes.Stelem_Ref);\n        il.Emit(OpCodes.Call, typeof(MyClass).GetMethod(\"call\"));\n        il.Emit(OpCodes.Unbox_Any, typeof(int));            \n        il.Emit(OpCodes.Ret);\n        var del = dn.CreateDelegate(typeof(Func&lt;string, int, int&gt;));\n        var r = del.DynamicInvoke(\"test\", 77);\n\n        Console.WriteLine(r);\n\n\n\n        Console.ReadKey();\n    }\n}\n\nclass MyClass\n{\n    public int test(string v1, int v2)\n    {\n        var a = call(new object[] { v1, v2 });\n        return (int)a;\n    }\n\n    public static object call(object[] args)\n    {\n        // что-то возвращающее int\n        return 5;\n    }\n}\n</code></pre>\n\n<p>Обратите внимание, что я использовал перегрузку DynamicMethod с указанием типа. Согласно документации - это тип, к открытым методам которого динамический метод будет иметь доступ. (скорее всего, <code>myMethod</code> будет динамически добавлен как статический метод этого типа. Но это не точно. Довольно любопытная штука). </p>\n"}