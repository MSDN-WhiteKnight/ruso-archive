{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":2,"last_activity_date":1512455782,"creation_date":1512455782,"answer_id":753935,"question_id":753019,"body":"<p>В языке С (без плюсов), для получения информации о железе наверное проще всего брать информацию прямо из таблицы SMBIOS, возвращаемой функцией <code>GetSystemFirmwareTable</code>. </p>\n\n<p>Возьмем <a href=\"https://github.com/cavaliercoder/sysinv/blob/master/smbios.cpp\" rel=\"nofollow noreferrer\">отсюда</a> библиотеку для разбора SMBIOS:</p>\n\n<pre><code>// SMBIOS Table Type numbers\n#define SMB_TABLE_BIOS              0\n#define SMB_TABLE_SYSTEM            1\n#define SMB_TABLE_BASEBOARD         2\n#define SMB_TABLE_CHASSIS           3\n#define SMB_TABLE_PROCESSOR         4\n#define SMB_TABLE_MEMCTRL           5\n#define SMB_TABLE_MEMMODULES        6\n#define SMB_TABLE_PORTS             8\n#define SMB_TABLE_SLOTS             9\n#define SMB_TABLE_OEM_STRINGS       11\n#define SMB_TABLE_SYS_CFG_OPTIONS   12\n#define SMB_TABLE_MEM_ARRAY         16\n#define SMB_TABLE_MEM_DEVICE        17\n#define SMB_TABLE_END_OF_TABLE      127\n\n// CPU registers returned by __cpuid()\n#define EAX                         0\n#define EBX                         1\n#define ECX                         2\n#define EDX                         3\n\n// Virtualization platform providers\n#define VIRT_PLATFORM_NONE          0\n#define VIRT_PLATFORM_VMWARE        1\n#define VIRT_PLATFORM_VBOX          2\n#define VIRT_PLATFORM_QEMU          3\n#define VIRT_PLATFORM_KVM           4\n#define VIRT_PLATFORM_MSVPC         5\n#define VIRT_PLATFORM_HYPERV        6\n#define VIRT_PLATFORM_XEN           7\n#define VIRT_PLATFORM_VTZO          8\n#define VIRT_PLATFORM_PARA          9\n\n// 64bit Word type\ntypedef unsigned long long QWORD;\n\n/*\n* Structures\n*/\ntypedef struct _RawSmbiosData\n{\n    BYTE    Used20CallingMethod;\n    BYTE    SMBIOSMajorVersion;\n    BYTE    SMBIOSMinorVersion;\n    BYTE    DmiRevision;\n    DWORD   Length;\n    BYTE    SMBIOSTableData[1];\n} RAW_SMBIOS_DATA, * PRAW_SMBIOS_DATA;\n\ntypedef struct _SmbiosStructHeader\n{\n    BYTE Type;\n    BYTE Length;\n    WORD Handle;\n} SMBIOS_STRUCT_HEADER, *PSMBIOS_STRUCT_HEADER;\n\n// Structures\ntypedef struct _NODE {\n    wchar_t *Name;                      // Name of the node\n    struct _NODE_ATT_LINK *Attributes;  // Array of attributes linked to the node\n    struct _NODE *Parent;               // Parent node\n    struct _NODE_LINK *Children;        // Array of linked child nodes\n    int Flags;                          // Node configuration flags\n} NODE, * PNODE;\n\ntypedef struct _NODE_LINK {\n    struct _NODE *LinkedNode;           // Node attached to this node\n} NODE_LINK, * PNODE_LINK;\n\ntypedef struct _NODE_ATT {\n    wchar_t *Key;                       // Attribute name\n    wchar_t *Value;                     // Attribute value string (may be null separated multistring if NAFLG_ARRAY is set)\n    int Flags;                          // Attribute configuration flags\n} NODE_ATT, *PNODE_ATT;\n\ntypedef struct _NODE_ATT_LINK {\n    struct _NODE_ATT *LinkedAttribute;  // Attribute linked to this node\n} NODE_ATT_LINK, *PNODE_ATT_LINK;\n\n\n/********************************************************************/\n\nPRAW_SMBIOS_DATA GetSmbiosData()\n{\n    DWORD bufferSize = 0;\n\n    PRAW_SMBIOS_DATA smbios = NULL;\n\n    // Get required buffer size\n    bufferSize = GetSystemFirmwareTable('RSMB', 0, NULL, 0);\n    if (bufferSize) {\n        smbios = (PRAW_SMBIOS_DATA)LocalAlloc(LPTR, bufferSize);\n        bufferSize = GetSystemFirmwareTable('RSMB', 0, (PVOID)smbios, bufferSize);\n    }\n\n    return smbios;\n}\n\nPSMBIOS_STRUCT_HEADER GetNextStructure(PRAW_SMBIOS_DATA smbios,PSMBIOS_STRUCT_HEADER previous)\n{\n    PSMBIOS_STRUCT_HEADER next = NULL;\n    PBYTE c = NULL;\n\n\n\n    // Return NULL is no data found\n    if (NULL == smbios)\n        return NULL;\n\n    // Return first table if previous was NULL\n    if (NULL == previous)\n        return (PSMBIOS_STRUCT_HEADER)(&amp;smbios-&gt;SMBIOSTableData[0]);\n\n    // Move to the end of the formatted structure\n    c = ((PBYTE)previous) + previous-&gt;Length;\n\n    // Search for the end of the unformatted structure (\\0\\0)\n    while (true) {\n        if ('\\0' == *c &amp;&amp; '\\0' == *(c + 1)) {\n            /* Make sure next table is not beyond end of SMBIOS data\n             * (Thankyou Microsoft for ommitting the structure count\n             * in GetSystemFirmwareTable\n             */\n            if ((c + 2) &lt; ((PBYTE)smbios-&gt;SMBIOSTableData + smbios-&gt;Length))\n                return (PSMBIOS_STRUCT_HEADER)(c + 2);\n            else\n                return NULL; // We reached the end\n        }\n\n        c++;\n    }\n\n    return NULL;\n}\n\nPSMBIOS_STRUCT_HEADER GetNextStructureOfType(PRAW_SMBIOS_DATA smbios,PSMBIOS_STRUCT_HEADER previous, DWORD type)\n{\n    PSMBIOS_STRUCT_HEADER next = previous;\n    while (NULL != (next = GetNextStructure(smbios,next))) {\n        if (type == next-&gt;Type)\n            return next;\n    }\n\n    return NULL;\n}\n\nPSMBIOS_STRUCT_HEADER GetStructureByHandle(PRAW_SMBIOS_DATA smbios,WORD handle)\n{\n    PSMBIOS_STRUCT_HEADER header = NULL;\n\n    while (NULL != (header = GetNextStructure(smbios,header)))\n        if (handle == header-&gt;Handle)\n            return header;\n\n    return NULL;\n}\n\nLPTSTR GetSmbiosString(PSMBIOS_STRUCT_HEADER table, BYTE index)\n{\n    DWORD i = 0;\n    DWORD len = 0;\n    LPTSTR unicode = _wcsdup(_T(\"\"));\n\n    if (0 == index)\n        return unicode;\n\n    char *c = NULL;\n\n    for (i = 1, c = (char *)table + table-&gt;Length; '\\0' != *c; c += strlen(c) + 1, i++) {\n        if (i == index) {\n            LocalFree(unicode);\n\n            len = MultiByteToWideChar(CP_UTF8, 0, c, -1, NULL, 0);\n            unicode = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR)* len);\n\n            MultiByteToWideChar(CP_UTF8, 0, c, -1, unicode, len);\n            break;\n        }\n    }\n\n    return unicode;\n}\n</code></pre>\n\n<hr>\n\n<p>Смастерим функции для получения значений по смещению:</p>\n\n<pre><code>//вывод значения числового параметра таблицы SMBIOS по указанному смещению\nvoid PrintBiosValue(PRAW_SMBIOS_DATA smbios,DWORD type,DWORD offset)\n{\n\n    PSMBIOS_STRUCT_HEADER head; \n    head=NULL;\n    PBYTE cursor = NULL; \n\n    head = GetNextStructureOfType(smbios,head, type);\n    if (NULL == head){printf(\"PrintString Error!\\n\");return;}\n    cursor=((PBYTE)head+offset);\n\n        //  value           \n        printf(\"%d\\n\",(int)*cursor);        \n\n}\n\n//вывод значения строкового параметра таблицы SMBIOS по указанному смещению\nvoid PrintBiosString(PRAW_SMBIOS_DATA smbios,DWORD type,DWORD offset)\n{\n\n    PSMBIOS_STRUCT_HEADER head; \n    head=NULL;\n    PBYTE cursor = NULL;\n\n    LPTSTR unicode = NULL;      \n\n    head = GetNextStructureOfType(smbios,head, type);\n    if (NULL == head){printf(\"PrintString Error!\\n\");return;}\n    cursor=((PBYTE)head+offset);\n    BYTE val=*cursor;\n\n    unicode = GetSmbiosString((head), *cursor);\n        //  value           \n        wprintf(unicode);printf(\"\\n\");      \n        LocalFree(unicode); \n\n}\n</code></pre>\n\n<hr>\n\n<p>Значения смещений для конкретных параметров можно найти в <a href=\"http://www.dmtf.org/sites/default/files/standards/documents/DSP0134_2.8.0.pdf\" rel=\"nofollow noreferrer\">спецификации SMBIOS</a>.<br>\nДля получения размера оперативной памяти, к счастью, есть готовая функция <code>GetPhysicallyInstalledSystemMemory</code>.</p>\n\n<p>Пример использования:</p>\n\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n#include &lt;tchar.h&gt;\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    PRAW_SMBIOS_DATA data=GetSmbiosData();\n    if(data==NULL){printf(\"Can't get data!\");goto End;}\n\n    printf(\"BIOS vendor: \");\n    PrintBiosString(data,SMB_TABLE_BIOS,4);\n\n    printf(\"Motherboard vendor: \");\n    PrintBiosString(data,SMB_TABLE_SYSTEM,4);\n\n    printf(\"CPU vendor: \");\n    PrintBiosString(data,SMB_TABLE_PROCESSOR,7);\n\n    printf(\"Type: \");\n    PrintBiosValue(data,SMB_TABLE_CHASSIS,5);//Тип компьютера: 3=desktop,9=laptop,A=notebook, ...\n\n    ULONGLONG memory=0;\n    if(GetPhysicallyInstalledSystemMemory(&amp;memory)==FALSE)printf(\"Can't get memory!\");\n    else printf(\"Memory: %llu KB\\n\",memory);\n\n    End:system(\"PAUSE\");\n    return 0;\n}\n</code></pre>\n"}