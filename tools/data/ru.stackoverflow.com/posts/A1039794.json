{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":2,"last_activity_date":1572330569,"creation_date":1572330569,"answer_id":1039794,"question_id":1037304,"body":"<blockquote>\n  <p>И хотелось бы получить полный ответ почему я немгу pdf считать в байты, затем перевести в строку </p>\n</blockquote>\n\n<p>На это ответ очень прост: PDF - бинарный формат, а не текстовый. Любой код, который вызывает <code>Encoding.GetString</code> на содержимом PDF-файла (в целом) можно смело выбрасывать. Конечно, преобразовывать в строку отдельные его поля, которые гарантированно являются текстом, можно.</p>\n\n<p>Если вам нужно просто грубо заменить вхождение <code>/Producer (Foo)</code> на <code>/Producer (Bar)</code>, не учитывая структуру файла (т.е., если такая последовательность случайно встретится в содержимом файла, он будет поврежден), то можно сделать так:</p>\n\n<pre><code>using System;\nusing System.IO;\nusing System.Text;\n\nclass Program\n{\n    public static bool SequenceEquals(byte[] array, int position, byte[] match)\n    {\n        if (match.Length &gt; (array.Length - position)) return false;\n\n        for (int i = 0; i &lt; match.Length; i++)\n        {\n            if (array[position + i] != match[i])  return false;\n        }\n\n        return true;\n    }\n\n    public static int FindSequence(byte[] arr, byte[] match, int startindex=0)\n    {\n        for (int i = startindex; i &lt; arr.Length; i++)\n        {\n            if (SequenceEquals(arr, i, match)) return i;\n        }\n        return -1;\n    }\n\n    public static void Main()\n    {        \n        string path1 = @\"C:\\Test\\file1.pdf\";\n        string path2 = @\"C:\\Test\\file2.pdf\";\n\n        //считаем данные\n        byte[] data = File.ReadAllBytes(path1);\n\n        //подготовим последовательности для поиска\n        byte[] match_start = Encoding.ASCII.GetBytes(\"/Producer\");\n        byte[] match_end = Encoding.ASCII.GetBytes(\")\");\n\n        //найдем последовательность в массиве\n        int index_start = FindSequence(data, match_start);           \n        int index_end = FindSequence(data, match_end, index_start + 1) + 1;\n        byte[] bytes_old = new byte[index_end - index_start];\n        Array.Copy(data, index_start, bytes_old, 0, bytes_old.Length);\n        string s_old = Encoding.ASCII.GetString(bytes_old);\n\n        //подготовим новые данные\n        string s_new = \"/Producer (MyMy)\";\n        byte[] bytes_new = Encoding.ASCII.GetBytes(s_new);\n        byte[] newdata = new byte[data.Length - bytes_old.Length + bytes_new.Length];\n\n        //запишем результат\n        Array.Copy(data, newdata, index_start);\n        Array.Copy(bytes_new, 0, newdata, index_start, bytes_new.Length);\n        Array.Copy(data, index_end, newdata, index_start+ bytes_new.Length, data.Length - index_end);\n        File.WriteAllBytes(path2, newdata);\n\n        Console.ReadKey();\n    }\n}\n</code></pre>\n\n<p>Корректная замена должна учитывать структуру файла в соответствии с <a href=\"https://www.adobe.com/content/dam/acom/en/devnet/pdf/pdf_reference_archive/PDFReference.pdf\" rel=\"nofollow noreferrer\">документацией Adobe</a>. </p>\n"}