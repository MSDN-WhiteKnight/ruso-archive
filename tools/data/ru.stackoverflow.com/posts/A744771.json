{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":3,"last_activity_date":1510686424,"creation_date":1510686424,"answer_id":744771,"question_id":696333,"body":"<p>Метод <code>Process.Start</code> связывает объект <code>Process</code> с дескриптором процесса только когда его вызов непосредственно порождает новый процесс. При передаче имени файла вместо имени программы класс <code>Process</code> обращается к функциям из <em>shell32.dll</em> и пытается определить, какие ассоциации в реестре установлены для данного расширения.  </p>\n\n<p>Если используется \"традиционный\" способ ассоциации, с вызовом командной строки и передачей имени файла первым параметром (такой используется, например, Блокнотом), вызов <code>Process.Start</code> самостоятельно создает новый процесс, и связь с дескриптором устанавливается нормально. Если же для расширения установлен более новый способ ассоциации, с вызовом специального COM-объекта (который используется многими новыми приложениями, например <em>Windows Media Player</em>), вызов <code>Process.Start</code> лишь отправляет через RPC запрос на вызов метода COM-объекта и завершается, не устанавливая связь с процессом. (Как показали исследования, непосредственное создание процесса в этом случае происходит в контексте <em>svchost.exe</em>) </p>\n\n<p>Для решения этой проблемы можно использовать метод создания процесса, модифицированный следующим образом:</p>\n\n<pre><code>using System;\nusing System.ComponentModel;\nusing System.Text;\nusing System.Windows.Forms;\nusing System.Diagnostics;\nusing System.Threading;\nusing System.Runtime.InteropServices;\n\nnamespace ProcessTest\n{\n    public partial class Form1 : Form\n    {\n        [DllImport(\"Shlwapi.dll\", SetLastError = true, CharSet = CharSet.Auto)]\n        static extern uint AssocQueryString(AssocF flags, AssocStr str, string pszAssoc, string pszExtra, [Out] StringBuilder pszOut, ref uint pcchOut);\n\n        /*Модифицированный метод создания процесса*/\n        public static Process TrueProcessStart(string filename)\n        {\n            ProcessStartInfo psi;\n            string ext = System.IO.Path.GetExtension(filename);//получаем расширение\n\n            var sb = new StringBuilder(500);//буфер для пути к exe-файлу\n            uint size = 500;//размер буфера\n\n            /*Получаем приложение, ассоциированное с файлом*/\n            uint res = AssocQueryString(AssocF.None, AssocStr.Executable, ext,null, sb, ref size);\n\n            if (res != 0)\n            {\n                Debug.WriteLine(\"AssocQueryString returned error: \" + res.ToString(\"X\"));\n                psi = new ProcessStartInfo(filename);//не удалось получить приложение, используем стандартный метод\n            }\n            else\n            {\n                psi = new ProcessStartInfo(sb.ToString(), filename);\n            }\n\n            return Process.Start(psi);//запуск процесса\n        }\n\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        private void button2_Click(object sender, EventArgs e)\n        {            \n            string filename = \"c:\\\\images\\\\clip.wmv\";\n\n            var myProc = TrueProcessStart(filename);\n            if (myProc == null)\n            {\n                MessageBox.Show(\"Process can't be killed\");\n                return;\n            }\n\n            Thread.Sleep(5000);\n            try\n            {\n                myProc.Kill(); \n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.ToString());\n            }\n        }\n    }\n\n    [Flags]\n    enum AssocF : uint\n    {\n        None = 0,\n        Init_NoRemapCLSID = 0x1,\n        Init_ByExeName = 0x2,\n        Open_ByExeName = 0x2,\n        Init_DefaultToStar = 0x4,\n        Init_DefaultToFolder = 0x8,\n        NoUserSettings = 0x10,\n        NoTruncate = 0x20,\n        Verify = 0x40,\n        RemapRunDll = 0x80,\n        NoFixUps = 0x100,\n        IgnoreBaseClass = 0x200,\n        Init_IgnoreUnknown = 0x400,\n        Init_FixedProgId = 0x800,\n        IsProtocol = 0x1000,\n        InitForFile = 0x2000,\n    }\n\n    enum AssocStr\n    {\n        Command = 1,\n        Executable,\n        FriendlyDocName,\n        FriendlyAppName,\n        NoOpen,\n        ShellNewValue,\n        DDECommand,\n        DDEIfExec,\n        DDEApplication,\n        DDETopic,\n        InfoTip,\n        QuickTip,\n        TileInfo,\n        ContentType,\n        DefaultIcon,\n        ShellExtension,\n        DropTarget,\n        DelegateExecute,\n        SupportedUriProtocols,\n        Max,\n    }\n\n\n}\n</code></pre>\n\n<p>Здесь для получения программы, ассоциированной с файлом, используется функция <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/bb773471%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396\" rel=\"nofollow noreferrer\">AssocQueryString</a>. Потом полученное значение передается в <code>ProcessStartInfo</code>. Однако этот метод не всегда работает, в этом случае вызывается стандартный метод. Например, для файлов изображений нет определенной программы, просто dll грузится в процесс проводника. В этом случае убить процесс просто так не получится.</p>\n"}