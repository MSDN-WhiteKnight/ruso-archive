{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":1,"last_activity_date":1521520814,"creation_date":1521520814,"answer_id":801807,"question_id":801587,"body":"<p>Например, используя <em>Marshal.PtrToStructure</em>:</p>\n\n<pre><code>object ByteArrayToStructure(byte[] bytearray, Type t)\n{\n    if (t.IsValueType == false) throw new ArgumentException(\"Type is not structure\");\n    IntPtr p = IntPtr.Zero;\n    object obj = null;\n\n    try\n    {\n        int len = Marshal.SizeOf(t);\n\n        p = Marshal.AllocHGlobal(len);\n        Marshal.Copy(bytearray, 0, p, len);\n        obj = Marshal.PtrToStructure(p, t);\n    }\n    finally\n    {\n        if (p != IntPtr.Zero) Marshal.FreeHGlobal(p);\n    }\n    return obj;\n}\n\n/*...*/\n\nbyte[] arr = /*Считать массив байт из потока*/;\nMyStruct s = (MyStruct)ByteArrayToStructure(arr,typeof(MyStruct));\n</code></pre>\n\n<p>Или как-то так (извращенный способ, но не требует выделения промежуточного блока памяти):</p>\n\n<pre><code>using System;\nusing System.Runtime.InteropServices;\n\n[StructLayout(LayoutKind.Sequential, Pack = 1)]\npublic struct MyStruct\n{\n    /*Список полей*/\n    short x;\n    short y;\n    sbyte a;\n    byte b;\n\n    /*Статические методы*/\n    [DllImport(\"kernel32.dll\", EntryPoint = \"CopyMemory\", SetLastError = false)]\n    private static extern void CopyMemory(\n        [In, Out] ref MyStruct dest,\n        [MarshalAs(UnmanagedType.LPArray)] byte[] src,\n        int count);\n\n    public static MyStruct ByteArrayToStructure(byte[] bytearray)\n    {\n        MyStruct obj = new MyStruct();\n        CopyMemory(ref obj, bytearray, bytearray.Length);\n        return obj;\n    }\n}\n\n/*...*/\n\nbyte[] arr = /*Считать массив байт из потока*/;\nMyStruct s = MyStruct.ByteArrayToStructure(arr);\n</code></pre>\n"}