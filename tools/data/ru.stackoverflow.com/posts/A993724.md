---
title: "Answer 993724"
se.owner.user_id: 339485
se.owner.display_name: "MrFresnel"
se.owner.link: "https://ru.stackoverflow.com/users/339485/mrfresnel"
se.answer_id: 993724
se.question_id: 969675
se.post_type: answer
se.score: 0
se.is_accepted: False
---
<p>Ответ немного припоздал, но всё-же. Важно понимать, что тип переменной и тип её значения - не одно и то же. К примеру:</p>

<pre><code>using System;
using System.Collections.Generic;

namespace CSrharpApplicationTest
{
    internal class Program
    {
        private static void Main(string[] args)
        {
            IEnumerable&lt;int&gt; x = new List&lt;int&gt;();
            Console.WriteLine(x.GetType());
        }
    }
}

</code></pre>

<p>Тип переменной - <code>IEnumerable&lt;int&gt;</code>, тип её значения - <code>List&lt;int&gt;</code>. </p>

<p>В обоих случаях в Ваших примерах тип <code>t1</code> и <code>t2</code> - <code>List&lt;int&gt;</code>, благодаря вызову метода-расширения <code>ToList()</code>, реализация которого выглядит следующим образом:</p>

<pre><code>        [__DynamicallyInvokable]
        public static List&lt;TSource&gt; ToList&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source)
        {
            if (source == null)
            {
                throw Error.ArgumentNull("source");
            }
            return new List&lt;TSource&gt;(source);
        }
</code></pre>

<p>, где конструктор <code>List&lt;TSource&gt;</code> описывается так:</p>

<pre><code>        [__DynamicallyInvokable]
        public List(IEnumerable&lt;T&gt; collection)
        {
            if (collection == null)
            {
                ThrowHelper.ThrowArgumentNullException(ExceptionArgument.collection);
            }
            ICollection&lt;T&gt; collection2 = collection as ICollection&lt;T&gt;;
            if (collection2 != null)
            {
                int count = collection2.Count;
                if (count == 0)
                {
                    _items = _emptyArray;
                }
                else
                {
                    _items = new T[count];
                    collection2.CopyTo(_items, 0);
                    _size = count;
                }
            }
            else
            {
                _size = 0;
                _items = _emptyArray;
                foreach (T item in collection)
                {
                    Add(item);
                }
            }
        }
</code></pre>

<blockquote>
  <p>Разнится в том, что при добавлении элементов во втором случае надо явно привести к типу List, так?</p>
</blockquote>

<p>Да, во втором случае Вы указываете компилятору, что тип <code>listValues2</code> - любой тип, реализующий <code>IEnumerable&lt;int&gt;</code>. В интерфейсе <code>IEnumerable&lt;out T&gt;</code>, нет методов добавления/изменения/удаления элементов, ведь он описывает минимальный функционал для возможности <strong>перечисления</strong> по коллекции, соответственно компилятор не может дать гарантий, что то, что лежит внутри <code>listValues2</code> - коллекция, с методом <code>Add</code>. Поэтому требуется явное приведение типа к <code>List&lt;int&gt;</code>.</p>
