{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":0,"last_activity_date":1564113594,"creation_date":1564113594,"answer_id":1006815,"question_id":1006349,"body":"<p>Прямая работа с Reflection.Emit обычно используется в особых случаях, когда нужно сгенерировать сложный многострочный метод. Для однострочного метода, который только вызывает другой метод, можно использовать более простое высокоуровневое средство - деревья выражений. При их использовании не нужно задумываться об отдельных инструкциях и корректности IL. Вот пример, также для более простого случая, когда метод call - статический:</p>\n\n<pre><code>using System;\nusing System.Collections;\nusing System.Linq.Expressions;\nusing System.Reflection;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        public static object call(object[] args)\n        {\n            //...\n        }\n\n        static void Main(string[] args)\n        {\n            ParameterExpression param1 = Expression.Parameter(typeof(string), \"v1\");\n            ParameterExpression param2 = Expression.Parameter(typeof(int), \"v2\");\n\n            NewArrayExpression expr_arr = Expression.NewArrayInit(\n                typeof(object),\n                Expression.Convert(param1,typeof(object)),\n                Expression.Convert(param2, typeof(object))\n                );\n\n            MethodCallExpression call_expr = Expression.Call(typeof(Program).GetMethod(\"call\"), expr_arr);\n            UnaryExpression conv_expr = Expression.Convert(call_expr, typeof(int));\n\n            var f_expr = Expression.Lambda&lt;Func&lt;string, int, int&gt;&gt;(conv_expr, param1,param2);\n            Func&lt;string, int, int&gt; f = f_expr.Compile();\n            int res = f(\"test\", 77);\n        }\n    }  \n}\n</code></pre>\n\n<p>При этом деревья выражений внутри также используют Reflection.Emit и динамические методы. Тип времени выполнения метода f.Method будет <code>System.Reflection.Emit.DynamicMethod+RTDynamicMethod</code>, он также будет создан в специальной изолированной системной сборке и может быть выгружен сборщиком мусора, когда он больше не нужен.</p>\n"}