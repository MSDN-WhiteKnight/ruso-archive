{"owner":{"reputation":9111,"user_id":220571,"user_type":"registered","accept_rate":100,"profile_image":"https://i.stack.imgur.com/QPJV4.jpg?s=128&g=1","display_name":"Vadim Ovchinnikov","link":"https://ru.stackoverflow.com/users/220571/vadim-ovchinnikov"},"is_accepted":false,"score":24,"last_activity_date":1498637708,"last_edit_date":1498637708,"creation_date":1480231896,"answer_id":596363,"question_id":420354,"body":"<p>Используйте библиотеку <a href=\"https://github.com/cefsharp/CefSharp\" rel=\"noreferrer\">CefSharp</a> для решения подобных задач.</p>\n\n<h2>Почему следует применять именно такой подход?</h2>\n\n<ul>\n<li>У вас намного упрощается процесс разработки за счёт того, что вместо\nнаписания XPath, условий и/или циклов в C# вы просто в консоли\nбраузера (желательно основанного на Chromium) просто разрабатываете\nвсё что вам нужно, затем когда уже написан небольшой костяк из класса\n(покажу его ниже), вы просто вставляете JavaScript-код, который вам\nнужен.</li>\n<li>Надёжность. Вы не пытаетесь парсить HTML и не изобретаете велосипед, что является почти всегда очень плохой идеей. Проект основан на Chromium, поэтому вам не приходится доверять какому-то новому/незнакомому продукту. Активно поддерживается для синхронизации с новой версией.</li>\n</ul>\n\n<p>Для Javascript-обращений для простоты и демонстрации используется jQuery, предполагая, что на целевом сайте он тоже есть. Но это может быть также чистый JavaScript либо другая библиотека при условии, что эта библиотека используется на сайте.</p>\n\n<p>Если вы проскроллите вниз, то заметите, что помимо написания небольшой прослойки кода и инициалиации, решение занимает одну-две строки:</p>\n\n<pre><code>string[] urls = await wrapper.GetResultAfterPageLoad(\"https://yandex.ru\",\n    async () =&gt; await wrapper.EvaluateJavascript&lt;string[]&gt;(\n    \"$('a[href]').map((index, element) =&gt; $(element).prop('href')).toArray()\"));\n</code></pre>\n\n<h2>Что это такое?</h2>\n\n<p>Это управляемая оболочка над CEF (<a href=\"https://en.wikipedia.org/wiki/Chromium_Embedded_Framework\" rel=\"noreferrer\">Chromium Embedded Framework</a>). То есть Вы получаете мощь Chromium, которой управляете программно.</p>\n\n<h2>Почему именно CEF/CefSharp?</h2>\n\n<ul>\n<li>Не стоит заморачиваться парсингом страниц (а это сложная и неблагодарная задача, которую крайне не рекомендую делать).</li>\n<li>Можно работать с уже загруженной страницей (после выполнения скриптов).</li>\n<li>Есть возможность выполнять произвольный JavaScript с последними возможностями.</li>\n<li>Даёт возможность вызывать AJAX с помощью JavaScript, а затем при успехе (success), дёргать события в C#-коде с результатом AJAX. Подробно и с примером рассмотрел <a href=\"https://ru.stackoverflow.com/a/610028/220571\">здесь</a>.</li>\n</ul>\n\n<h2>Разновидности CefSharp</h2>\n\n<ul>\n<li>CefSharp.WinForms</li>\n<li>CefSharp.Wpf</li>\n<li>CefSharp.OffScreen<br /></li>\n</ul>\n\n<p>Первые две используются если вам надо дать пользователям элемент управления \"Браузер\". Концептуально похоже на <a href=\"https://msdn.microsoft.com/en-us/library/system.windows.forms.webbrowser(v=vs.110).aspx\" rel=\"noreferrer\">WebBrowser</a> в Windows Forms, который является оболочкой для управления IE, а не Chromium, как в нашем случае.</p>\n\n<p>Поэтому мы будем использовать CefSharp.OffScreen (закадровую) разновидность.</p>\n\n<h2>Написание кода</h2>\n\n<p>Допустим у нас консольное приложение, но это уже зависит от Вас.</p>\n\n<p>Устанавливаем Nuget-пакет CefSharp.OffScreen 57-ой версии:<br />\n<code>Install-Package CefSharp.OffScreen -Version 57.0.0</code></p>\n\n<p>Дело в том, что C# всё массивы маппает к <code>List&lt;object&gt;</code>, результат JavaScript обёрнут в <code>object</code>, в котором уже содержатся <code>List&lt;object&gt;</code>, <code>string</code>, <code>bool</code>, <code>int</code> в зависимости от результата. Для того чтобы сделать результаты строго типизированными, создаём небольшой <code>ConvertHelper</code>:<br /></p>\n\n<pre><code>public static class ConvertHelper\n{\n    public static T[] GetArrayFromObjectList&lt;T&gt;(object obj)\n    {\n        return ((IEnumerable&lt;object&gt;)obj)\n            .Cast&lt;T&gt;()\n            .ToArray();\n    }\n\n    public static List&lt;T&gt; GetListFromObjectList&lt;T&gt;(object obj)\n    {\n        return ((IEnumerable&lt;object&gt;)obj)\n            .Cast&lt;T&gt;()\n            .ToList();\n    }\n\n    public static T ToTypedVariable&lt;T&gt;(object obj)\n    {\n        if (obj == null)\n        {\n            dynamic dynamicResult = null;\n            return dynamicResult;\n        }\n\n        Type type = typeof(T);\n        if (type.IsArray)\n        {\n            dynamic dynamicResult = typeof(ConvertHelper).GetMethod(nameof(GetArrayFromObjectList))\n                .MakeGenericMethod(type.GetElementType())\n                .Invoke(null, new[] { obj });\n            return dynamicResult;\n        }\n\n        if (type.IsGenericType &amp;&amp; type.GetGenericTypeDefinition() == typeof(List&lt;&gt;))\n        {\n            dynamic dynamicResult = typeof(ConvertHelper).GetMethod(nameof(GetListFromObjectList))\n                .MakeGenericMethod(type.GetGenericArguments().Single())\n                .Invoke(null, new[] { obj });\n            return dynamicResult;\n        }\n\n        return (T)obj;\n    }\n}\n</code></pre>\n\n<p>Для обработки с ошибками Javascript создаём класс <code>JavascriptException</code>.</p>\n\n<pre><code>public class JavascriptException : Exception\n{\n    public JavascriptException(string message) : base(message) { }\n}\n</code></pre>\n\n<p>У вас может быть свой способ обработки ошибок.</p>\n\n<p>Создаём класс <code>CefSharpWrapper</code>:</p>\n\n<pre><code>public sealed class CefSharpWrapper\n{\n    private ChromiumWebBrowser _browser;\n\n    public void InitializeBrowser()\n    {\n        Cef.EnableHighDPISupport();\n        // Perform dependency check to make sure all relevant resources are in our output directory.\n        Cef.Initialize(new CefSettings(), performDependencyCheck: false, browserProcessHandler: null);\n\n        _browser = new ChromiumWebBrowser();\n\n        // wait till browser initialised\n        AutoResetEvent waitHandle = new AutoResetEvent(false);\n\n        EventHandler onBrowserInitialized = null;\n\n        onBrowserInitialized = (sender, e) =&gt;\n        {\n            _browser.BrowserInitialized -= onBrowserInitialized;\n\n            waitHandle.Set();\n        };\n\n        _browser.BrowserInitialized += onBrowserInitialized;\n\n        waitHandle.WaitOne();\n    }\n\n    public void ShutdownBrowser()\n    {\n        // Clean up Chromium objects.  You need to call this in your application otherwise\n        // you will get a crash when closing.\n        Cef.Shutdown();\n    }\n\n    public Task&lt;T&gt; GetResultAfterPageLoad&lt;T&gt;(string pageUrl, Func&lt;Task&lt;T&gt;&gt; onLoadCallback)\n    {\n        TaskCompletionSource&lt;T&gt; tcs = new TaskCompletionSource&lt;T&gt;();\n\n        EventHandler&lt;LoadingStateChangedEventArgs&gt; onPageLoaded = null;\n\n        T t = default(T);\n\n        // An event that is fired when the first page is finished loading.\n        // This returns to us from another thread.\n        onPageLoaded = async (sender, e) =&gt;\n        {\n            // Check to see if loading is complete - this event is called twice, one when loading starts\n            // second time when it's finished\n            // (rather than an iframe within the main frame).\n            if (!e.IsLoading)\n            {\n                // Remove the load event handler, because we only want one snapshot of the initial page.\n                _browser.LoadingStateChanged -= onPageLoaded;\n\n                t = await onLoadCallback();\n\n                tcs.SetResult(t);\n            }\n        };\n\n        _browser.LoadingStateChanged += onPageLoaded;\n\n        _browser.Load(pageUrl);\n\n        return tcs.Task;\n    }\n\n    public async Task EvaluateJavascript(string script)\n    {\n        JavascriptResponse javascriptResponse = await _browser.GetMainFrame().EvaluateScriptAsync(script);\n\n        if (!javascriptResponse.Success)\n        {\n            throw new JavascriptException(javascriptResponse.Message);\n        }\n    }\n\n    public async Task&lt;T&gt; EvaluateJavascript&lt;T&gt;(string script)\n    {\n        JavascriptResponse javascriptResponse = await _browser.GetMainFrame().EvaluateScriptAsync(script);\n\n        if (javascriptResponse.Success)\n        {\n            object scriptResult = javascriptResponse.Result;\n            return ConvertHelper.ToTypedVariable&lt;T&gt;(scriptResult);\n        }\n\n        throw new JavascriptException(javascriptResponse.Message);\n    }\n}\n</code></pre>\n\n<p>Далее вызываем наш класс <code>CefSharpWrapper</code> из метода Main.</p>\n\n<pre><code>public class Program\n{\n    private static void Main()\n    {\n        MainAsync().Wait();\n    }\n\n    private static async Task MainAsync()\n    {\n        CefSharpWrapper wrapper = new CefSharpWrapper();\n\n        wrapper.InitializeBrowser();\n\n        string[] urls = await wrapper.GetResultAfterPageLoad(\"https://yandex.ru\", async () =&gt;\n            await wrapper.EvaluateJavascript&lt;string[]&gt;(\"$('a[href]').map((index, element) =&gt; $(element).prop('href')).toArray()\"));\n\n        wrapper.ShutdownBrowser();\n    }\n}\n</code></pre>\n\n<p>Также: в данной библиотеке есть особенность, что пустой JavaScript-массив приводится к <code>null</code>. Поэтому, возможно, есть смысл добавить в <code>ConvertHelper</code> соотвествующий код (это зависит от вашего кода и потребностей), либо в вызывающем коде писать что-то вроде</p>\n\n<pre><code>if (urls == null) urls = new string[0]\n</code></pre>\n\n<hr>\n\n<p>Также установите <code>x64</code> или <code>x86</code> в качестве платформы. Платформа <code>Any CPU</code> <a href=\"https://github.com/cefsharp/CefSharp/issues/1714\" rel=\"noreferrer\">поддерживается, но требует дополнительного кода</a>.</p>\n"}