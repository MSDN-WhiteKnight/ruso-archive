{"owner":{"reputation":16068,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":0,"last_activity_date":1525692216,"last_edit_date":1525692216,"creation_date":1525691702,"answer_id":824466,"question_id":821933,"body":"<p>Есть еще вот такой способ:</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Input;\nusing System.Windows.Interop;\nusing System.IO;\nusing System.Xml;\nusing System.Runtime.InteropServices;\nusing System.Threading.Tasks;\n\nnamespace WpfApplication1\n{\n    public partial class MainWindow : Window\n    {\n\n        public MainWindow()\n        {\n            InitializeComponent();             \n        }\n\n        /*Вспомогательные методы и константы...*/\n        public static Point ElementPointToScreenPoint(UIElement element, Point pointOnElement)\n        {\n            return element.PointToScreen(pointOnElement);\n        }\n\n        [DllImport(\"user32.dll\")]\n        static extern int GetSystemMetrics(int smIndex);\n\n        [DllImport(\"user32.dll\")]\n        static extern uint SendInput(uint nInputs,\n           [MarshalAs(UnmanagedType.LPArray), In] INPUT[] pInputs,\n           int cbSize);\n\n        [DllImport(\"user32.dll\")]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        static extern bool GetCursorPos(ref Win32Point pt);\n\n        const uint MOUSEEVENTF_ABSOLUTE = 0x8000;\n        const uint MOUSEEVENTF_MOVE = 0x0001;\n        const uint MOUSEEVENTF_LEFTDOWN = 0x0002;\n        const uint MOUSEEVENTF_LEFTUP = 0x0004;\n        const int SM_CXSCREEN = 0;\n        const int SM_CYSCREEN = 1;        \n\n        /* Эмулирует нажатие мышью на элемент управления */\n        public static async void PerformClick(Control ctrl)\n        { \n            double XSCALEFACTOR = 65535.0 / (GetSystemMetrics(SM_CXSCREEN) - 1);\n            double YSCALEFACTOR = 65535.0 / (GetSystemMetrics(SM_CYSCREEN) - 1);\n\n            //находим координаты центра элемента\n            double x = ctrl.ActualWidth / 2;\n            double y = ctrl.ActualHeight / 2;\n            Point p = ElementPointToScreenPoint(ctrl, new Point(x, y));            \n\n            //сохраняем текущие координаты мыши\n            Win32Point mouse = new Win32Point();\n            GetCursorPos(ref mouse);            \n\n            //эмулируем нажатие\n            INPUT[] arr = new INPUT[1];            \n            arr[0].Type = INPUT_TYPE.INPUT_MOUSE;\n            arr[0].Data.Mouse.ExtraInfo = IntPtr.Zero;\n            arr[0].Data.Mouse.X = (int)Math.Round(p.X * XSCALEFACTOR);\n            arr[0].Data.Mouse.Y = (int)Math.Round(p.Y * YSCALEFACTOR);\n            arr[0].Data.Mouse.Flags = MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE | MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP;\n            var res =SendInput(1, arr, Marshal.SizeOf(typeof(INPUT)));            \n\n            if(!Window.GetWindow(ctrl).IsMouseOver)\n                await Task.Delay(1); //если мышь за пределами окна, WPF понадобится некоторое время для обработки события\n\n            //возвращаем предыдущее положение мыши\n            arr[0].Type = INPUT_TYPE.INPUT_MOUSE;\n            arr[0].Data.Mouse.X = (int)Math.Round(mouse.X * XSCALEFACTOR);\n            arr[0].Data.Mouse.Y = (int)Math.Round(mouse.Y * YSCALEFACTOR);\n            arr[0].Data.Mouse.Flags = MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE ;\n            res = SendInput(1, arr, Marshal.SizeOf(typeof(INPUT)));\n        }\n\n        private async void Window_Loaded(object sender, RoutedEventArgs e)\n        {\n            //пример использования\n            await Task.Delay(1000);\n            PerformClick(button1); \n            await Task.Delay(3000);\n            PerformClick(button2);\n        }  \n\n    }\n\n    //WINAPI types...\n\n    enum INPUT_TYPE : uint\n    {\n        INPUT_MOUSE = 0,\n        INPUT_KEYBOARD = 1,\n        INPUT_HARDWARE = 2\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n     struct INPUT\n    {\n        public INPUT_TYPE Type;\n        public MOUSEKEYBDHARDWAREINPUT Data;\n    }\n\n    [StructLayout(LayoutKind.Explicit)]\n     struct MOUSEKEYBDHARDWAREINPUT\n    {\n        [FieldOffset(0)]\n        public HARDWAREINPUT Hardware;\n        [FieldOffset(0)]\n        public KEYBDINPUT Keyboard;\n        [FieldOffset(0)]\n        public MOUSEINPUT Mouse;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n     struct HARDWAREINPUT\n    {\n        public uint Msg;\n        public ushort ParamL;\n        public ushort ParamH;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n     struct KEYBDINPUT\n    {\n        public ushort Vk;\n        public ushort Scan;\n        public uint Flags;\n        public uint Time;\n        public IntPtr ExtraInfo;\n    }\n\n\n    [StructLayout(LayoutKind.Sequential)]\n     struct MOUSEINPUT\n    {\n        public int X;\n        public int Y;\n        public uint MouseData;\n        public uint Flags;\n        public uint Time;\n        public IntPtr ExtraInfo;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n     struct Win32Point\n    {\n        public Int32 X;\n        public Int32 Y;\n    };\n}\n</code></pre>\n"}