{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1521216728,"creation_date":1521216728,"answer_id":799280,"question_id":799074,"body":"<p>Для получения процессорного времени, затраченного на выполнение однопоточного метода, необходимо вычесть значения <em>ProcessThread.TotalProcessorTime</em> после и до выполнения метода. Соответственно, загрузку процессора (среднюю), создаваемую в ходе его выполнения, можно найти, разделив полученное значение на <code>Environment.ProcessorCount * ВремяВыполнения</code>. Для повышения точности расчетов произвести измерение несколько раз и найти среднее. Пример:</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Text;\nusing System.Diagnostics;\nusing System.Threading;\n\nnamespace ConsoleTest1\n{    \n    class Program\n    {\n        /* Измеряемый метод */\n        public static Int64 DoSomething(Int64 x)\n        {\n            Int64 res = 1; \n            for (Int64 i = 1; i &lt;= x; i++) res += i;\n            return res;\n        }\n\n        [System.Runtime.InteropServices.DllImport(\"kernel32.dll\")]\n        static extern uint GetCurrentThreadId();\n\n        const int N = 50; //число итераций\n\n        static void Main(string[] args)\n        {\n            Console.WriteLine(DoSomething(5000000).ToString()); //прогрев\n\n            Int64 sum=0;\n            Stopwatch sw = new Stopwatch();\n\n            var id = GetCurrentThreadId();//получаем ID текущего потока\n\n            Process pr = Process.GetCurrentProcess();\n            ProcessThread thread = null;\n\n            //находим объект ProcessThread для текущего потока\n            foreach (ProcessThread th in pr.Threads)\n            {\n                if (th.Id == (int)id) thread = th;\n            }\n            if (thread == null) { Console.WriteLine(\"ProcessThread not found\"); return; }\n\n            sw.Start();//начало измерений\n            var before = thread.TotalProcessorTime.Ticks;\n            for (int i = 0; i &lt; N; i++)\n            {\n                sum += DoSomething(50000000);//вызов измерямого метода                \n            }\n            Console.WriteLine(sum.ToString());\n            var after = thread.TotalProcessorTime.Ticks;\n            sw.Stop();//конец измерений            \n\n            double processor_time = TimeSpan.FromTicks(after - before).TotalMilliseconds / N;\n            double total_time = (sw.ElapsedMilliseconds) / (double)N;\n            double usage = (processor_time) / (Environment.ProcessorCount * total_time) * 100.0;\n\n            Console.WriteLine(\"Processor time:\" + Math.Round(processor_time,2).ToString());\n            Console.WriteLine(\"Total time:\" + total_time.ToString());\n            Console.WriteLine(\"Usage %:\" + Math.Round(usage,1).ToString());            \n\n        }\n    }\n}\n</code></pre>\n\n<p>Если <em>DoSomething</em> выполняет только голые вычисления, без обращения к вводу/выводу или ожидания событий, значение загрузки будет близко к <code>100% / Environment.ProcessorCount</code>. Если он содержит вызов <em>Thread.Sleep</em>, загрузка будет близка к нулю. Все остальное - что-то посередине.</p>\n\n<p>Если метод многопоточный, нужно либо суммировать по всем задействованным потокам, либо просто брать <em>Process.TotalProcessorTime</em> для грубого приближения (в предположении, что ничего другого в данный момент в процессе не происходит).</p>\n"}