---
title: "Answer 896647"
se.owner.user_id: 300864
se.owner.display_name: "greg zakharov"
se.owner.link: "https://ru.stackoverflow.com/users/300864/greg-zakharov"
se.answer_id: 896647
se.question_id: 896643
se.post_type: answer
se.score: 2
se.is_accepted: False
---
<p>В случае использования атрибута <em>DllImport</em> и модификатора <em>extern</em> для вызываемой функции из внешнего модуля необходимость в указанных вами проверках нулевая, если же вы собираетесь вызывать методы посредством делегатов, то лучше реализовать в своем коде класс <em>SafeLibraryHandle</em> на подобие того, как это сделано в самой платформе <em>.NET Framework</em>. В результате проверить был ли загружен модуль или нет можно будет с помощью свойства <em>IsInvalid</em>. Чтобы было понятней:</p>

<pre><code>using System;
using System.Security;
using Microsoft.Win32.SafeHandles;
using System.Runtime.InteropServices;

namespace SafeLibrary {
  [SecurityCritical]
  internal sealed class SafeLibraryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeLibraryHandle() : base(true) {}

    [SecurityCritical]
    override protected Boolean ReleaseHandle() {
      return NativeMethods.FreeLibrary(handle);
    }
  }

  internal static class NativeMethods {
    [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    internal static extern SafeLibraryHandle LoadLibrary(String lpLibFileName);

    [DllImport("kernel32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern Boolean FreeLibrary(IntPtr hLibModule);
  }

  internal sealed class Program {
    static void Main() {
      SafeLibraryHandle slh = NativeMethods.LoadLibrary("some.dll");
      if (slh.IsInvalid) {
        Console.WriteLine("IsInvalid: {0} IsClosed: {1}", slh.IsInvalid, slh.IsClosed);
        // return;
      }
      slh.Dispose();
      Console.WriteLine("IsInvalid: {0} IsClosed: {1}", slh.IsInvalid, slh.IsClosed);
    }
  }
}
</code></pre>
