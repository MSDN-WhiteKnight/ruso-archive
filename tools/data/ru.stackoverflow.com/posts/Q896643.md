---
title: "Попытка загрузка библиотеки, или проверка на загруженность"
se.owner.user_id: 206435
se.owner.display_name: "ヒミコ"
se.owner.link: "https://ru.stackoverflow.com/users/206435/%e3%83%92%e3%83%9f%e3%82%b3"
se.link: "https://ru.stackoverflow.com/questions/896643/%d0%9f%d0%be%d0%bf%d1%8b%d1%82%d0%ba%d0%b0-%d0%b7%d0%b0%d0%b3%d1%80%d1%83%d0%b7%d0%ba%d0%b0-%d0%b1%d0%b8%d0%b1%d0%bb%d0%b8%d0%be%d1%82%d0%b5%d0%ba%d0%b8-%d0%b8%d0%bb%d0%b8-%d0%bf%d1%80%d0%be%d0%b2%d0%b5%d1%80%d0%ba%d0%b0-%d0%bd%d0%b0-%d0%b7%d0%b0%d0%b3%d1%80%d1%83%d0%b6%d0%b5%d0%bd%d0%bd%d0%be%d1%81%d1%82%d1%8c"
se.question_id: 896643
se.post_type: question
se.score: 1
---
<p>Что лучше делать с самого начала, проверить загружен ли модуль в память процесса, или попытаться его загрузить, словить ошибку через <code>GetLastError</code>, проверить ее значение, и в случае если библиотека уже загружена вызвать <code>GetModuleHandle</code>, или сделать все наоборот?</p>

<p>Т.е. примерно так, но не только проверять на <code>IntPtr.Zero</code> а еще проверить <code>LastError</code> на совпадение с кодом ошибки (<em>номер кода ошибки пока не знаю поэтому там нет данной проверки</em>)?</p>

<p>Хотя если модуль был загружен то <code>LoadLibrary</code> возвращает его <code>Handle</code> а не бросает ошибку, что странно.</p>

<pre><code>internal static class WinApi
{
    internal static bool FreeLibrary(IntPtr moduleHandle)
    {
        return FreeLibraryEx(moduleHandle);
    }

    internal static TDelegateType GetProcDelegate&lt;TDelegateType&gt;(IntPtr moduleHandle, string procName)
        where TDelegateType : Delegate
    {
        return Marshal.GetDelegateForFunctionPointer&lt;TDelegateType&gt;(GetProcAddressEx(moduleHandle, procName));
    }

    internal static SafeLibrary LoadLibrary(string modulePath)
    {
        IntPtr result = LoadLibraryEx(modulePath);
        if (result == IntPtr.Zero &amp;&amp; (result = GetModuleHandleEx(Path.GetFileName(modulePath))) == IntPtr.Zero)
        {
            throw new Win32Exception(Marshal.GetLastWin32Error());
        }

        return result;
    }

    #region Private native Methods

    [DllImport(Libraries.Kernel32, SetLastError = true, EntryPoint = "LoadLibrary",
        CallingConvention = CallingConvention.Winapi)]
    private static extern IntPtr LoadLibraryEx(string modulePath);

    [DllImport(Libraries.Kernel32, CallingConvention = CallingConvention.Winapi, EntryPoint = "FreeLibrary",
        SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool FreeLibraryEx(IntPtr moduleHandle);

    [DllImport(Libraries.Kernel32, CallingConvention = CallingConvention.Winapi, EntryPoint = "GetProcAddress",
        CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern IntPtr GetProcAddressEx(IntPtr moduleHandle, string procedureName);

    [DllImport(Libraries.Kernel32, CallingConvention = CallingConvention.Winapi, SetLastError = true,
        EntryPoint = "GetModuleHandle")]
    private static extern IntPtr GetModuleHandleEx(string moduleName);

    #endregion
}
</code></pre>
