{"tags":["c#","winapi","ini"],"owner":{"reputation":455,"user_id":16686,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/727726b33379ef13ca2e9771d061f4b3?s=128&d=identicon&r=PG","display_name":"JamesBondCaesar","link":"https://ru.stackoverflow.com/users/16686/jamesbondcaesar"},"is_answered":true,"view_count":72,"answer_count":1,"score":1,"last_activity_date":1557727090,"creation_date":1557667049,"question_id":980594,"link":"https://ru.stackoverflow.com/questions/980594/win-api-%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%b0-%d1%81-%d0%ba%d0%be%d0%bd%d1%84%d0%b8%d0%b3%d1%83%d1%80%d0%b0%d1%86%d0%b8%d0%be%d0%bd%d0%bd%d1%8b%d0%bc%d0%b8-%d1%84%d0%b0%d0%b9%d0%bb%d0%b0%d0%bc%d0%b8-ini-%d0%b8%d0%b7-c","title":"Win API работа с конфигурационными файлами (.ini) из C#","body":"<p>Я создаю класс который будет работать с конфигурационными файлами из шарпа. Для чтения и записи следующую конструкуию:</p>\n\n<pre><code>#region File managers\n\nprivate const int SIZE = 1024; //Максимальный размер (для чтения значения из файла)\n    /// &lt;summary&gt;\n    /// WinAPI - Извлекает строку из указанной секции инициализационного файла\n    /// &lt;param name=\"AppName\"&gt;\n    /// Имя секции содержащей имя ключа. Если параметр null то функция копирует все именя секций в подставленный буфер\n    /// &lt;/param&gt;\n    /// &lt;param name=\"KeyName\"&gt;\n    /// Имя ключа с которым ассоциируется извлекаемая строка. Если параметр null то все ключевые имяна в секции заданной как AppName копируются в буффер ReturnedString\n    /// &lt;/param&gt;\n    /// &lt;param name=\"Default\"&gt; \n    /// Строка по умолчанию. Если имя ключа не может быть найдено в инициализационном файле то функция копирует строку по умолчанию а буффер ReturnedString\n    /// &lt;/param&gt;\n    /// &lt;param name=\"ReturnedString\"&gt;\n    /// Указатель на буффер принимающий возвращаемую строку\n    /// &lt;/param&gt;\n    /// &lt;param name=\"Size\"&gt;\n    /// Размер буффера переданного по параметру ReturnedString.\n    /// &lt;/param&gt;\n    /// &lt;param name=\"FileName\"&gt;\n    /// Имя инициализационного файла. Если параметр не содержит полного пути к файлу, \n    /// то система производит поиск файла в директории Windows\n    /// &lt;/param&gt;\n    /// &lt;returns&gt;\n    /// Количество скопированных символов не считая null-termonated символа\n    /// &lt;/returns&gt;\n    [DllImport(\"kernel32.dll\", SetLastError = true)]\n    private extern static int GetPrivateProfileString(String AppName, String KeyName, String Default, StringBuilder ReturnedString, UInt32 Size, String FileName);\n    /// &lt;summary&gt;\n    /// Удобная обертка для WinAPI функции GetPrivateProfileString\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"section\"&gt;наименование секции&lt;/param&gt;\n    /// &lt;param name=\"key\"&gt;ключ&lt;/param&gt;\n    /// &lt;returns&gt;запрашиваемый параметр или null если ключь не был найден&lt;/returns&gt;\n    private string GetParam(string section, string key)\n    {\n        //Для получения значения\n        StringBuilder buffer = new StringBuilder(SIZE);\n\n        //Получить значение в buffer\n        GetPrivateProfileString(section, key, null, buffer, SIZE, Path);\n        int er = Marshal.GetLastWin32Error();\n        if (er &gt; 0)\n            throw new Exception($\"GetPrivateProfileString error {er}. \" +\n                $\"See System Error Codes (https://docs.microsoft.com/ru-ru/windows/desktop/Debug/system-error-codes) for detales\");\n\n        //Вернуть полученное значение\n        return buffer.Length == 0 ? null : buffer.ToString();\n    }\n\n    /// &lt;summary&gt;\n    /// WinAPI - Копирует строку в определенную секцию инициализационного файла\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"AppName\"&gt;\n    /// Имя секции в которую строка будет скопированна. Если секция не существует, то она создастся. Имя секции регистро-независимо.\n    /// Строка может состоять из любых комбинаций букв верхнего и нижнего регистра  \n    /// &lt;/param&gt;\n    /// &lt;param name=\"KeyName\"&gt;\n    /// Имя ключа которое будет ассоциировано со строкой. Если ключь не содержится в секции, то он создастся. \n    /// Если данный параметр null - то вся секция включая всё в секции - удаляется\n    /// &lt;/param&gt;\n    /// &lt;param name=\"Str\"&gt;\n    /// \"null-termonated\" строка (завершается на '/0') для записи в файл. Если параметр null - Если параметр null, то параметр переданный в качестве ключа KeyName - будет удален  \n    /// &lt;/param&gt;\n    /// &lt;param name=\"FileName\"&gt;\n    /// Имя инициализационного файла. Строка будет хаписана с исспользованием Unicode, если файл был создан с исспользованием Unicode символов. \n    /// Иначе будет исспользована ANSI кодировка\n    /// &lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    [DllImport(\"kernel32.dll\", SetLastError = true)]\n    private extern static int WritePrivateProfileString(String AppName, String KeyName, String Str, String FileName);\n    /// &lt;summary&gt;\n    /// Удобная обертка для WinAPI WritePrivateProfileString\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"section\"&gt;Секция&lt;/param&gt;\n    /// &lt;param name=\"key\"&gt;Ключ&lt;/param&gt;\n    /// &lt;param name=\"value\"&gt;Значение&lt;/param&gt;\n    private void WriteParam(string section, string key, string value)\n    {\n        //Записать значение в INI-файл\n        WritePrivateProfileString(section, key, value, Path);\n        int er = Marshal.GetLastWin32Error();\n        if (er &gt; 0)\n            throw new Exception($\"WritePrivateProfileString error {er}.\" +\n                $\". See System Error Codes (https://docs.microsoft.com/ru-ru/windows/desktop/Debug/system-error-codes) for detales\");\n    }\n    #endregion\n</code></pre>\n\n<p>В конструкторе класса, если файл не существует - создаю его следующим образом:</p>\n\n<pre><code>Path = path;\n   if (!File.Exists(path))\n   {\n       var file = File.Create(path);\n       file.Close();\n   }\n</code></pre>\n\n<p>Однако по чему то при попытке прочесть или записать в файл - получаю ошибку ERROR_FILE_NOT_FOUND не смотря на то что файл присутствуют на диске. В чем может быть дело ?</p>\n\n<p>А вот если читаю файлик который был создан не моей программой (скопировал тестовый файл) - то тогда файл читается нормально.</p>\n"}