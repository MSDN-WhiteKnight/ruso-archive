{"owner":{"reputation":16068,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":2,"last_activity_date":1533384659,"creation_date":1533384659,"answer_id":864341,"question_id":860315,"body":"<p>\"Эквалайзер\" и \"Визуалайзер\" - разные вещи. Эквалайзер - это средство для регулирования тембра звука, а не визуализации.</p>\n\n<p>Простейший визуализатор звука можно написать с использованием Core Audio API. Начиная с висты, аудиопотоки смешиваются программно внутри службы аудио и API предоставляет доступ к громкости конкретных приложений (точнее, \"сессий\"). Интерфейс <a href=\"https://docs.microsoft.com/en-us/windows/desktop/api/audiopolicy/nn-audiopolicy-iaudiosessionenumerator\" rel=\"nofollow noreferrer\">IAudioSessionEnumerator</a> позволяет получить список WASAPI-сессий на аудиоустройстве. Далее, нужно найти сессии своей программы и добраться до интерфейса <a href=\"https://docs.microsoft.com/en-us/windows/desktop/api/endpointvolume/nn-endpointvolume-iaudiometerinformation\" rel=\"nofollow noreferrer\">IAudioMeterInformation</a>, позволяющего получить текущий уровень звука. Следующий пример кода демонстрирует изменение высоты эллипса в зависимости от значения пикового уровня звука.</p>\n\n<p>XAML:</p>\n\n<pre><code>&lt;Window x:Class=\"WpfApplication1.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        Title=\"Audio player\" Height=\"350\" Width=\"620.522\"&gt;\n    &lt;Grid Margin=\"0,0,3.4,63.4\"&gt;\n        &lt;MediaElement x:Name=\"media1\" HorizontalAlignment=\"Left\" Height=\"148\" Margin=\"325,29,0,0\" \n                      VerticalAlignment=\"Top\" Width=\"240\" \n                      Source=\"\" \n                      LoadedBehavior=\"Manual\"/&gt;\n        &lt;Button x:Name=\"bOpen\" Content=\"Open\" HorizontalAlignment=\"Left\" Height=\"55\" \n                Margin=\"22,190,0,0\" VerticalAlignment=\"Top\" Width=\"70\" Click=\"bOpen_Click\"/&gt;\n        &lt;Button x:Name=\"bPlay\" Content=\"Play\" HorizontalAlignment=\"Left\" Height=\"55\" \n                Margin=\"120,190,0,0\" VerticalAlignment=\"Top\" Width=\"70\" Click=\"Button_Click_1\"/&gt;\n        &lt;Button x:Name=\"bStop\" Content=\"Stop\" HorizontalAlignment=\"Left\" Height=\"55\" Margin=\"212,190,0,0\"\n                VerticalAlignment=\"Top\" Width=\"70\" Click=\"bStop_Click\"/&gt;\n        &lt;Grid HorizontalAlignment=\"Left\" Height=\"157\" Margin=\"20,20,0,0\" VerticalAlignment=\"Top\" Width=\"286\"&gt;\n            &lt;Ellipse x:Name=\"ellVisualizer\" Fill=\"#FFF4F4F5\" HorizontalAlignment=\"Center\" Height=\"50\" \n                      Stroke=\"Black\" VerticalAlignment=\"Center\" Width=\"256\"/&gt;\n        &lt;/Grid&gt;        \n\n    &lt;/Grid&gt;\n&lt;/Window&gt;\n</code></pre>\n\n<p>C#:</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Runtime.InteropServices;\nusing System.Timers;\n\nnamespace WpfApplication1\n{\n    public partial class MainWindow : Window\n    {\n        IMMDeviceEnumerator deviceEnumerator=null;\n        IMMDevice speakers = null; //текущее аудиоустройство\n        Timer timer; //таймер для обновления UI\n        uint this_pid; //идентификатор этого процесса\n\n        public MainWindow()\n        {\n            InitializeComponent();\n\n            System.Diagnostics.Process pr = System.Diagnostics.Process.GetCurrentProcess();\n            using (pr)\n            {\n                this_pid = (uint)pr.Id;\n            }\n\n            // get default audio device\n            deviceEnumerator = (IMMDeviceEnumerator)(new MMDeviceEnumerator());\n            deviceEnumerator.GetDefaultAudioEndpoint(EDataFlow.eRender, ERole.eMultimedia, out speakers);\n\n            //start UI updating timer\n            timer = new Timer(100);\n            timer.Elapsed += timer_Elapsed;\n            timer.Enabled = true;            \n        }\n\n        private void timer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            this.Dispatcher.Invoke(() =&gt;\n            {\n                this.UpdateVisualizer();\n            });\n        }\n\n        //считывает текущее значение уровней звука и обновляет UI\n        public void UpdateVisualizer()\n        {\n            if (speakers == null) return;\n\n            IAudioSessionManager2 mgr = null;\n            IAudioSessionEnumerator sessionEnumerator = null;\n            IAudioSessionControl ctl = null;\n            IAudioSessionControl2 ctl2 = null;\n            IAudioMeterInformation meter = null;\n\n            try\n            {\n\n                // activate the session manager. we need the enumerator\n                Guid IID_IAudioSessionManager2 = typeof(IAudioSessionManager2).GUID;\n                object o;\n                speakers.Activate(ref IID_IAudioSessionManager2, 0, IntPtr.Zero, out o);\n                mgr = (IAudioSessionManager2)o;\n\n                // enumerate sessions for on this device            \n                mgr.GetSessionEnumerator(out sessionEnumerator);\n                int count;\n                sessionEnumerator.GetCount(out count);\n\n                float max_val = 0.0f; //максимальное значение уровня звука для всех сессий\n                int h_min = 50, h_max = 120;//макс. и мин. значение высоты для эллипса\n\n                int hr;    \n                uint pid = 0;\n                float val = 0.0f;                \n\n                for (int i = 0; i &lt; count; i++)\n                {\n                    if (ctl != null) { Marshal.ReleaseComObject(ctl); ctl = null; }\n                    if (ctl2 != null) { Marshal.ReleaseComObject(ctl2); ctl2 = null; }\n                    if (meter != null) { Marshal.ReleaseComObject(meter); meter = null; }\n\n                    //получаем WASAPI-сессию\n                    hr = sessionEnumerator.GetSession(i, out ctl);\n                    if (hr != 0) continue;\n\n                    ctl2 = (IAudioSessionControl2)ctl;\n                    pid = 0;\n                    ctl2.GetProcessId(out pid);\n                    if (pid != this_pid) continue; //интересуют только сессии текущего процесса\n\n                    meter = (IAudioMeterInformation)ctl;\n                    hr = meter.GetPeakValue(out val);//получаем уровень звука\n                    if (hr != 0) { continue; }\n                    if (val &gt; max_val) max_val = val;                    \n\n                }\n\n                //изменяем высоту эллипса в соответствии со значением максимального уровня звука\n                ellVisualizer.Height = h_min + max_val * (h_max - h_min);\n\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.ToString(), ex.GetType().ToString());\n            }\n            finally\n            {                \n                //очистка ресурсов\n                if (sessionEnumerator != null) { Marshal.ReleaseComObject(sessionEnumerator); sessionEnumerator = null; }\n                if (mgr != null) { Marshal.ReleaseComObject(mgr); mgr = null; }\n\n                if (ctl != null) { Marshal.ReleaseComObject(ctl); ctl = null; }\n                if (ctl2 != null) { Marshal.ReleaseComObject(ctl2); ctl2 = null; }\n                if (meter != null) { Marshal.ReleaseComObject(meter); meter = null; }\n            }\n\n\n        }\n\n        private void Button_Click_1(object sender, RoutedEventArgs e)\n        {\n            media1.Play();\n        }\n\n        private void bStop_Click(object sender, RoutedEventArgs e)\n        {\n            media1.Stop();\n        }\n\n        private void bOpen_Click(object sender, RoutedEventArgs e)\n        {\n            Microsoft.Win32.OpenFileDialog ofd = new Microsoft.Win32.OpenFileDialog();\n            ofd.DefaultExt = \"mp3\";\n            ofd.Filter = \"Audio files (WAV,MP3,WMA)|*.wav;*.mp3;*.wma|All files|*.*\";\n            var res = ofd.ShowDialog(this);\n            if (res.HasValue)\n            {\n                if (res.Value != false)\n                {\n                    media1.Source = new Uri(ofd.FileName);\n                }\n            }\n        }\n    }\n\n    // *** COM Objects declarations ***\n    [ComImport]\n    [Guid(\"BCDE0395-E52F-467C-8E3D-C4579291692E\")]\n    internal class MMDeviceEnumerator\n    {\n    }\n\n    internal enum EDataFlow\n    {\n        eRender,\n        eCapture,\n        eAll,\n        EDataFlow_enum_count\n    }\n\n    internal enum ERole\n    {\n        eConsole,\n        eMultimedia,\n        eCommunications,\n        ERole_enum_count\n    }\n\n    [Guid(\"A95664D2-9614-4F35-A746-DE8DB63617E6\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n    internal interface IMMDeviceEnumerator\n    {\n        int NotImpl1();\n\n        [PreserveSig]\n        int GetDefaultAudioEndpoint(EDataFlow dataFlow, ERole role, out IMMDevice ppDevice);\n\n        // the rest is not implemented\n    }\n\n    [Guid(\"D666063F-1587-4E43-81F1-B948E807363F\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n    internal interface IMMDevice\n    {\n        [PreserveSig]\n        int Activate(ref Guid iid, int dwClsCtx, IntPtr pActivationParams, [MarshalAs(UnmanagedType.IUnknown)] out object ppInterface);\n\n        // the rest is not implemented\n    }\n\n    [Guid(\"77AA99A0-1BD6-484F-8BC7-2C654C9A9B6F\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n    internal interface IAudioSessionManager2\n    {\n        int NotImpl1();\n        int NotImpl2();\n\n        [PreserveSig]\n        int GetSessionEnumerator(out IAudioSessionEnumerator SessionEnum);\n\n        // the rest is not implemented\n    }\n\n    [Guid(\"E2F5BB11-0570-40CA-ACDD-3AA01277DEE8\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n    internal interface IAudioSessionEnumerator\n    {\n        [PreserveSig]\n        int GetCount(out int SessionCount);\n\n        [PreserveSig]\n        int GetSession(int SessionCount, out IAudioSessionControl Session);\n    }\n\n    [Guid(\"F4B1A599-7266-4319-A8CA-E70ACB11E8CD\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n    internal interface IAudioSessionControl\n    {\n        int NotImpl1();\n\n        [PreserveSig]\n        int GetDisplayName([MarshalAs(UnmanagedType.LPWStr)] out string pRetVal);\n\n        // the rest is not implemented\n    }\n\n    //Источник: https://github.com/maindefine/volumecontrol/blob/master/C%23/CoreAudioApi/Interfaces/IAudioSessionControl2.cs\n        [Guid(\"bfb7ff88-7239-4fc9-8fa2-07c950be9c6d\"),\n     InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n    interface IAudioSessionControl2\n    {\n        //IAudioSession functions\n        [PreserveSig]\n        int GetState(out object state);\n        [PreserveSig]\n        int GetDisplayName(out IntPtr name);\n        [PreserveSig]\n        int SetDisplayName(string value, Guid EventContext);\n        [PreserveSig]\n        int GetIconPath(out IntPtr Path);\n        [PreserveSig]\n        int SetIconPath(string Value, Guid EventContext);\n        [PreserveSig]\n        int GetGroupingParam(out Guid GroupingParam);\n        [PreserveSig]\n        int SetGroupingParam(Guid Override, Guid Eventcontext);\n        [PreserveSig]\n        int RegisterAudioSessionNotification(object NewNotifications);\n        [PreserveSig]\n        int UnregisterAudioSessionNotification(object NewNotifications);\n        //IAudioSession2 functions\n        [PreserveSig]\n        int GetSessionIdentifier( out IntPtr retVal);\n        [PreserveSig]\n        int GetSessionInstanceIdentifier( out IntPtr retVal);\n        [PreserveSig]\n        int GetProcessId( out UInt32 retvVal);\n        [PreserveSig]\n        int IsSystemSoundsSession();\n        [PreserveSig]\n        int SetDuckingPreference( bool optOut);\n\n\n    }\n\n    //Источник: https://github.com/maindefine/volumecontrol/blob/master/C%23/CoreAudioApi/Interfaces/IAudioMeterInformation.cs\n    [Guid(\"C02216F6-8C67-4B5B-9D00-D008E73E0064\"),\n     InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n    internal interface IAudioMeterInformation \n    {\n        [PreserveSig]\n        int GetPeakValue(out float pfPeak);\n        [PreserveSig]\n        int GetMeteringChannelCount(out int pnChannelCount);\n        [PreserveSig]\n        int GetChannelsPeakValues( int u32ChannelCount,[In]   IntPtr afPeakValues);\n        [PreserveSig]\n        int QueryHardwareSupport( out int pdwHardwareSupportMask);\n    };\n}\n</code></pre>\n\n<p>Источники:</p>\n\n<p><a href=\"https://ru.stackoverflow.com/questions/586898/c-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%BC-%D0%B7%D0%B2%D1%83%D0%BA%D0%B0-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F\">C# Управление звуком приложения</a></p>\n\n<p><a href=\"https://stackoverflow.com/a/14367829/8674428\">Peak meters for individual programs on Windows 7</a></p>\n"}