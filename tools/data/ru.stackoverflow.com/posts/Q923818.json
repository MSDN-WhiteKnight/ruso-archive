{"tags":["c#",".net","память","процесс"],"owner":{"reputation":103,"user_id":321096,"user_type":"registered","profile_image":"https://lh6.googleusercontent.com/-8vTtl0-xu3Y/AAAAAAAAAAI/AAAAAAAAAM0/NE17Bm39gbM/photo.jpg?sz=128","display_name":"Sergesama Channel","link":"https://ru.stackoverflow.com/users/321096/sergesama-channel"},"is_answered":false,"view_count":44,"answer_count":1,"score":1,"last_activity_date":1545986961,"creation_date":1545399155,"last_edit_date":1545986961,"question_id":923818,"link":"https://ru.stackoverflow.com/questions/923818/%d0%9f%d0%be%d1%87%d0%b5%d0%bc%d1%83-buffer-%d0%bf%d1%80%d0%b8-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b8-readprocessmemory-%d0%b7%d0%b0%d0%bf%d0%be%d0%bb%d0%bd%d1%8f%d0%b5%d1%82%d1%81%d1%8f-%d0%bd%d1%83%d0%bb%d1%8f%d0%bc%d0%b8","title":"Почему buffer при использовании ReadProcessMemory заполняется нулями?","body":"<p>Есть программа которая получает значение ячейки памяти занятой процессом \"notepad++\", в буфер должно заносится содержание этой ячейки, но почему-то он заполнен нулями.Почему?</p>\n\n<pre><code>class Program\n{\n\n    public enum DesiredAccessProcess : uint\n    {\n        PROCESS_TERMINATE = 0x0001,\n        PROCESS_CREATE_THREAD = 0x0002,\n        PROCESS_VM_OPERATION = 0x0008,\n        PROCESS_VM_READ = 0x0010,\n        PROCESS_VM_WRITE = 0x0020,\n        PROCESS_DUP_HANDLE = 0x0040,\n        PROCESS_CREATE_PROCESS = 0x0080,\n        PROCESS_SET_QUOTA = 0x0100,\n        PROCESS_SET_INFORMATION = 0x0200,\n        PROCESS_QUERY_INFORMATION = 0x0400,\n        SYNCHRONIZE = 0x00100000,\n        PROCESS_ALL_ACCESS = SYNCHRONIZE | 0xF0FFF\n    }\n\n    [DllImport(\"Kernel32\")]\n    public static extern IntPtr OpenProcess(DesiredAccessProcess dwDesiredAccess, bool bInheritHandle, uint dwProcessId);\n\n    [DllImport(\"Kernel32\")]\n    public static extern void ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out uint lpNumberOfBytesRead);\n\n    [DllImport(\"kernel32.dll\", SetLastError = true)]\n    public static extern int ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [In, Out] byte[] buffer, uint size, out IntPtr lpNumberOfBytesRead);\n    public byte[] ReadProcessMemory(IntPtr MemoryAddress, uint bytesToRead, out int bytesRead, IntPtr handle)\n    {\n        byte[] buffer = new byte[bytesToRead];\n        IntPtr ptrBytesRead;\n        ReadProcessMemory(handle, MemoryAddress, buffer, bytesToRead, out ptrBytesRead);\n        int result = Marshal.GetLastWin32Error();\n        bytesRead = ptrBytesRead.ToInt32();\n        return buffer;\n    }\n\n    static void Main(string[] args)\n    {\n        uint m_startAddress = 0, // Адрес, с которого начинается сканирование\n         m_scanLength = 1000000000, // Длина сканируемой области в байтах\n         m_bytesRead; // Количество прочитанных байт\n        byte[] buffer = new byte[m_scanLength];\n        int[] nums = new int[1000];\n        for (int i = 0; i &lt; 1000; i++)\n        {\n            nums[i] = 1;\n        }\n        Process m_process=new Process();\n        Process[] processes = Process.GetProcesses();\n        foreach (Process process in processes)\n            if (process.ProcessName == \"notepad++\")\n                m_process = process;\n        if (m_process != null)\n        {\n            while (1 == 1)\n            {\n                IntPtr m_intptrProcess = OpenProcess(DesiredAccessProcess.PROCESS_TERMINATE, false, (uint)m_process.Id); \n                ReadProcessMemory(m_intptrProcess, (IntPtr)m_startAddress, buffer, m_scanLength, out m_bytesRead);\n                for (int i = 0; i &lt; m_scanLength; i++)\n                {\n                    Console.Write(buffer[i]);\n                }\n                Console.ReadLine();\n            }\n        }\n\n    }\n\n}\n</code></pre>\n"}