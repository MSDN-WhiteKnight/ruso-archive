{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":1,"last_activity_date":1521653764,"last_edit_date":1521653764,"creation_date":1520278547,"answer_id":794133,"question_id":793697,"body":"<p>С данным кодом есть две проблемы.</p>\n\n<ol>\n<li><p>Флаг AUDCLNT_BUFFERFLAGS_SILENT надо не игнорировать, а писать в буфер соответствующее количество тишины (т.е. пустых байтов). Конечно, если пустоты <em>слишком</em> много, можно ее подрезать для экономии размера, но всю пустоту игнорировать неправильно.</p></li>\n<li><p>Из функции возвращается массив сырых байтов, без всякого признака формата (видимо, подразумевается PCM). Так делать не имеет особого смысла - формат в устройстве может быть любым, чаще всего это IEEE Float, но полагаться на это не стоит. Нужно сохранять и формат и данные.</p></li>\n</ol>\n\n<p>Примерный код захвата 5 секунд звука с устройства и записи в WAV-файл (протестирован в MSVC++ 2012):</p>\n\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;tchar.h&gt;\n#include \"windows.h\"\n#include \"mmdeviceapi.h\"\n#include \"uuids.h\"\n#include \"audioclient.h\"\n#pragma comment(lib, \"ole32.lib\")\n\nstruct WAVHEADER\n{    \n    char chunkId[4]; //RIFF    \n    unsigned long chunkSize;    \n    char format[4]; //WAVE      \n    char subchunk1Id[4]; //fmt        \n    unsigned long subchunk1Size; //18\n\n    unsigned short audioFormat; //wFormatTag    \n    unsigned short numChannels;    \n    unsigned long sampleRate; //Hz    \n    unsigned long byteRate;    \n    unsigned short blockAlign;    \n    unsigned short bitsPerSample;\n    unsigned short cbSize;    \n};\n\nconst UINT WAVHEADER_SIZE = 38;\n\nstruct WAV_FACT_CHUNK\n{\n    char FactChunkID[4]; //fact\n    unsigned long FactChunkSize; //4\n    unsigned long dwSampleLength;\n};\n\nstruct WAV_DATA_CHUNK\n{    \n    char subchunk2Id[4]; //data    \n    unsigned long subchunk2Size;\n    // Далее следуют данные...\n};\n\n\n// REFERENCE_TIME time units per second and per millisecond\n#define REFTIMES_PER_SEC  10000000\n#define REFTIMES_PER_MILLISEC  10000\n\n#define EXIT_ON_ERROR(hres)  \\\n              if (FAILED(hres)) { goto Exit; }\n#define SAFE_RELEASE(punk)  \\\n              if ((punk) != NULL)  \\\n                { (punk)-&gt;Release(); (punk) = NULL; }\n\nconst CLSID CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);\nconst IID IID_IMMDeviceEnumerator = __uuidof(IMMDeviceEnumerator);\nconst IID IID_IAudioClient = __uuidof(IAudioClient);\nconst IID IID_IAudioCaptureClient = __uuidof(IAudioCaptureClient);\n\n//Запись 5 секунд звука в WAV-файл\nHRESULT RecordAudioStream(TCHAR* file)\n{\n    HRESULT hr;\n    REFERENCE_TIME hnsRequestedDuration = REFTIMES_PER_SEC;\n    REFERENCE_TIME hnsActualDuration;\n    UINT32 bufferFrameCount;\n    UINT32 numFramesAvailable;\n    IMMDeviceEnumerator *pEnumerator = NULL;\n    IMMDevice *pDevice = NULL;\n    IAudioClient *pAudioClient = NULL;\n    IAudioCaptureClient *pCaptureClient = NULL;\n    WAVEFORMATEX *pwfx = NULL;\n    UINT32 packetLength = 0;\n    BOOL bDone = FALSE;\n    BYTE *pData;\n    DWORD flags;\n\n    hr = CoCreateInstance(\n           CLSID_MMDeviceEnumerator, NULL,\n           CLSCTX_ALL, IID_IMMDeviceEnumerator,\n           (void**)&amp;pEnumerator);\n    if(FAILED(hr))printf(\"CoCreateInstance failed\");\n    EXIT_ON_ERROR(hr)\n\n    hr = pEnumerator-&gt;GetDefaultAudioEndpoint(\n                        eCapture, eConsole, &amp;pDevice);\n    if(FAILED(hr))printf(\"GetDefaultAudioEndpoint failed\");\n    EXIT_ON_ERROR(hr)\n\n    hr = pDevice-&gt;Activate(\n                    IID_IAudioClient, CLSCTX_ALL,\n                    NULL, (void**)&amp;pAudioClient);\n    EXIT_ON_ERROR(hr)\n\n    //Получение формата\n    hr = pAudioClient-&gt;GetMixFormat(&amp;pwfx);\n    EXIT_ON_ERROR(hr)\n\n    WAVEFORMATEXTENSIBLE wex={0};    \n    WORD wFormatTag=0;\n\n    if(pwfx-&gt;wFormatTag == WAVE_FORMAT_EXTENSIBLE){        \n        memcpy(&amp;wex,pwfx,sizeof(WAVEFORMATEXTENSIBLE));\n        wFormatTag=wex.SubFormat.Data1;            \n    }\n    else{\n        wFormatTag=pwfx-&gt;wFormatTag;        \n    }    \n\n    //инициализация...\n    hr = pAudioClient-&gt;Initialize(\n                         AUDCLNT_SHAREMODE_SHARED,\n                         0,\n                         hnsRequestedDuration,\n                         0,\n                         pwfx,\n                         NULL);\n\n    if(FAILED(hr))printf(\"Initialize failed\");\n    EXIT_ON_ERROR(hr)\n\n    // Get the size of the allocated buffer.\n    hr = pAudioClient-&gt;GetBufferSize(&amp;bufferFrameCount);\n    EXIT_ON_ERROR(hr)\n\n    hr = pAudioClient-&gt;GetService(\n                         IID_IAudioCaptureClient,\n                         (void**)&amp;pCaptureClient);\n    EXIT_ON_ERROR(hr)\n\n    int counter = 0; //кол-во записанных семплов\n    int max_samples = 5 * pwfx-&gt;nSamplesPerSec; //максимальное кол-во семплов\n    BYTE zero = 0;\n\n    //формирование заголовков WAV-файла\n    WAVHEADER header={\n        {'R','I','F','F'},0,\n        {'W','A','V','E'},{'f','m','t',' '},18,0,0,0,0,0,0,0\n    };\n\n    WAV_FACT_CHUNK fact={{'f','a','c','t'},4,0};\n    WAV_DATA_CHUNK data={{'d','a','t','a'},0};\n\n    header.chunkSize = WAVHEADER_SIZE - 8 + sizeof(WAV_FACT_CHUNK) +sizeof(WAV_DATA_CHUNK) + max_samples * pwfx-&gt;nBlockAlign;\n    header.audioFormat = wFormatTag;\n    header.numChannels = pwfx-&gt;nChannels;\n    header.sampleRate = pwfx-&gt;nSamplesPerSec;\n    header.byteRate = pwfx-&gt;nAvgBytesPerSec;\n    header.blockAlign = pwfx-&gt;nBlockAlign;\n    header.bitsPerSample = pwfx-&gt;wBitsPerSample;    \n    fact.dwSampleLength = max_samples * pwfx-&gt;nChannels;\n    data.subchunk2Size = max_samples * pwfx-&gt;nBlockAlign;\n\n    //запись заголовков\n    FILE* fp = _wfopen(file,L\"wb\");\n    size_t res = fwrite(&amp;header,WAVHEADER_SIZE,1,fp);\n    if(res&lt;1)printf(\"header fwrite error!\\n\");\n\n    res = fwrite(&amp;fact,sizeof(fact),1,fp);\n    if(res&lt;1)printf(\"fact fwrite error!\\n\");\n\n    res = fwrite(&amp;data,sizeof(data),1,fp);\n    if(res&lt;1)printf(\"data fwrite error!\\n\");\n\n    // Calculate the actual duration of the allocated buffer.\n    hnsActualDuration = (double)REFTIMES_PER_SEC *\n                     bufferFrameCount / pwfx-&gt;nSamplesPerSec;\n\n    hr = pAudioClient-&gt;Start();  // Start recording.\n    EXIT_ON_ERROR(hr)    \n\n    // Each loop fills about half of the shared buffer.\n    while (true)\n    {\n        // Sleep for half the buffer duration.\n        Sleep(hnsActualDuration/REFTIMES_PER_MILLISEC/2);        \n\n        hr = pCaptureClient-&gt;GetNextPacketSize(&amp;packetLength);\n        EXIT_ON_ERROR(hr)\n\n        while (packetLength != 0)\n        {\n            // Get the available data in the shared buffer.\n            hr = pCaptureClient-&gt;GetBuffer(\n                                   &amp;pData,\n                                   &amp;numFramesAvailable,\n                                   &amp;flags, NULL, NULL);\n            EXIT_ON_ERROR(hr)\n\n            if (flags &amp; AUDCLNT_BUFFERFLAGS_SILENT)\n            {                \n                for(int i=0; i&lt;numFramesAvailable * pwfx-&gt;nBlockAlign;i++) // Tell CopyData to write silence.\n                {\n                    res=fwrite(&amp;zero,1,1,fp);\n                    if(res&lt;1)printf(\"Can't write silence!\\n\");\n                }\n            }\n            else\n            {\n                // Copy the available capture data to the audio sink.\n                res=fwrite(pData,pwfx-&gt;nBlockAlign,numFramesAvailable,fp);\n                if(res&lt;numFramesAvailable)printf(\"Can't write data!\\n\");\n            }     \n\n            hr = pCaptureClient-&gt;ReleaseBuffer(numFramesAvailable);\n            EXIT_ON_ERROR(hr)\n\n            hr = pCaptureClient-&gt;GetNextPacketSize(&amp;packetLength);\n            EXIT_ON_ERROR(hr)\n\n            counter += numFramesAvailable;\n\n        }\n        if(counter &gt;= max_samples) break;\n    }    \n\n    printf(\"Finished recording\\n\");\n    hr = pAudioClient-&gt;Stop();  // Stop recording.\n    EXIT_ON_ERROR(hr)\n\nExit:\n\n    CoTaskMemFree(pwfx);\n    SAFE_RELEASE(pEnumerator)\n    SAFE_RELEASE(pDevice)\n    SAFE_RELEASE(pAudioClient)\n    SAFE_RELEASE(pCaptureClient)\n\n    return hr;\n}\n\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CoInitialize(NULL);\n    RecordAudioStream(L\"c:\\\\MP3\\\\test.wav\");\n    system(\"PAUSE\");\n    return 0;\n}\n</code></pre>\n\n<p><strong>Примечания</strong></p>\n\n<ul>\n<li><em>fact chunk</em> и последнее поле в заголовке WAV нужны, поскольку некоторые проигрыватели требуют их обязательного наличия для non-PCM форматов.</li>\n<li>Значение <em>WAVHEADER_SIZE</em> отличается от <em>sizeof(WAVHEADER)</em> из-за выравнивания структур до 4-байтовой границы. sizeof его учитывает, а при записи в файл оно не нужно. </li>\n<li>В данном примере используется формат, возвращенный <em>GetMixFormat</em>, так как он гарантированно может быть использован для работы с устройством в не-эксклюзивном режиме. Если есть необходимость, можно выбрать другой формат, поддерживаемый устройством.</li>\n</ul>\n"}