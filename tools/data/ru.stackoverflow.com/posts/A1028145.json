{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":3,"last_activity_date":1569475094,"creation_date":1569475094,"answer_id":1028145,"question_id":1027755,"body":"<p>Потому что вы не написали правильный код для блокировки этих сочетаний клавиш. Начать с того, что VK для нажатия клавиши ALT в хуке - на самом деле не <code>Keys.Alt</code>, а <code>Keys.LMenu</code> или <code>Keys.RMenu</code>. Но даже если поменять VK на правильный, все равно условие <code>if (objKeyInfo.key == Keys.Alt || objKeyInfo.key == Keys.Tab)</code> никак не может соответствовать \"блокировать сочетание клавиш Alt+Tab\" - вы блокируете вместо этого <strong>любые</strong> нажатия клавиш Alt и Tab!</p>\n\n<p>Правильно это делается так: </p>\n\n<pre><code>using System;\nusing System.Runtime.InteropServices;\nusing System.ComponentModel;\nusing System.Windows.Forms;\n\nnamespace KeyboardHookSample\n{\n    class Program\n    {\n        static KeyHooker k;\n\n        static void Main(string[] args)\n        {\n            k = new KeyHooker();\n            k.Start();\n\n            Console.CancelKeyPress += Console_CancelKeyPress;\n            Console.WriteLine(\"Hook installed...\");\n            Application.Run();\n        }\n\n        private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n        {\n            k.Stop();\n            Application.Exit();\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public class KBDLLHOOKSTRUCT\n    {\n        public uint vkCode;\n        public uint scanCode;\n        public uint flags;\n        public uint time;\n        public UIntPtr dwExtraInfo;\n    }    \n\n    sealed class KeyHooker : IDisposable \n    {\n        //объявления типов, констант и функций Windows API\n        delegate IntPtr KeyboardProc(int nCode, IntPtr wParam, IntPtr lParam);\n        const int WH_KEYBOARD_LL = 13;\n        const int HC_ACTION = 0;\n        const int WM_KEYDOWN = 0x0100;\n        const int WM_SYSKEYDOWN = 0x0104;        \n        const uint LLKHF_ALTDOWN = 0x20;\n\n        [DllImport(\"user32.dll\", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]\n        static extern IntPtr SetWindowsHookEx(int idHook, KeyboardProc lpfn, IntPtr hInstance, int threadId);\n\n        [DllImport(\"user32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n        private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, IntPtr wParam, IntPtr lParam);\n\n        [DllImport(\"user32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        private static extern bool UnhookWindowsHookEx(IntPtr hhk);\n\n        [DllImport(\"kernel32.dll\")]\n        private static extern IntPtr LoadLibrary(string dllToLoad);\n\n        IntPtr _hookID = IntPtr.Zero;\n\n        //начинает отслеживание событий клавиатуры\n        public void Start()\n        {\n            if (disposed) throw new ObjectDisposedException(\"KeyLogger\");\n            if (_hookID != IntPtr.Zero) return;\n\n            _hookID = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardHookCallback, IntPtr.Zero, 0);\n\n            if (_hookID == IntPtr.Zero)\n            {\n                int error = Marshal.GetLastWin32Error();\n                throw new Win32Exception(error, \"Failed to install hook! Error: \" + error.ToString());\n            }\n        }\n\n        //останавливает отслеживание событий клавиатуры\n        public void Stop()\n        {\n            if (disposed) return;\n            if (_hookID == IntPtr.Zero) return;\n\n            UnhookWindowsHookEx(_hookID);\n            _hookID = IntPtr.Zero;\n        }\n\n        //вызывается Windows при нажатии клавиши\n        IntPtr KeyboardHookCallback(int nCode, IntPtr wParam, IntPtr lParam)\n        {\n            if (nCode &gt;= 0 &amp;&amp; (wParam == (IntPtr)WM_KEYDOWN || wParam == (IntPtr)WM_SYSKEYDOWN))\n            {    \n                KBDLLHOOKSTRUCT khs = (KBDLLHOOKSTRUCT)Marshal.PtrToStructure(lParam, typeof(KBDLLHOOKSTRUCT));\n                uint vkCode = khs.vkCode;                                \n\n                if ((khs.flags &amp; LLKHF_ALTDOWN) != 0 &amp;&amp; vkCode == (uint)Keys.Tab)\n                {                    \n                    return (IntPtr)1; //Cancel Alt+Tab\n                }\n            }\n            return CallNextHookEx(_hookID, nCode, wParam, lParam);\n        }\n\n        bool disposed = false;\n\n        public void Dispose()\n        {\n            if (disposed) return;\n\n            Stop();\n            disposed = true;\n            GC.SuppressFinalize(this);\n        }\n\n        ~KeyHooker()\n        {\n            Dispose();\n        }\n    }\n}\n</code></pre>\n\n<p>Также следует помнить, что блокировку системных сочетаний клавиш нужно применять с осторожностью. Если полноэкранное приложение блокирует сочетания клавиш Alt+Tab и Ctrl+Alt+Delete, то в случае его зависания система становится полностью неработоспособной - ничего не остается, кроме как перезагружать системник кнопкой Reset. </p>\n"}