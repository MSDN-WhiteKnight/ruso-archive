{"owner":{"reputation":187498,"user_id":10105,"user_type":"registered","accept_rate":73,"profile_image":"https://i.stack.imgur.com/d8Z7F.png?s=128&g=1","display_name":"VladD","link":"https://ru.stackoverflow.com/users/10105/vladd"},"is_accepted":false,"score":2,"last_activity_date":1521556357,"last_edit_date":1521556357,"creation_date":1521476385,"answer_id":801624,"question_id":801587,"body":"<p>Ну например, для структур, состоящих только из примитивных полей, подойдёт такой хелпер:</p>\n\n<pre><code>static void FillFromStream&lt;T&gt;(ref T t, Stream stream) where T : struct\n{\n    object boxed = t;\n    using (var br = new BinaryReader(stream, Encoding.ASCII, leaveOpen: true))\n    {\n        var fields = typeof(T).GetFields().OrderBy(f =&gt; f.MetadataToken);\n        foreach (var field in fields)\n        {\n            if (!field.FieldType.IsPrimitive)\n                throw new NotImplementedException(\"nested compound types\");\n            // for primitive types:\n            if (!primitiveExtractors.TryGetValue(field.FieldType, out var extractor))\n                throw new NotImplementedException(\"unsupported primitive type\");\n            var value = extractor(br);\n            field.SetValue(boxed, value);\n        }\n    }\n    t = (T)boxed;\n}\n</code></pre>\n\n<p>Вспомогательная таблица:</p>\n\n<pre><code>static Dictionary&lt;Type, Func&lt;BinaryReader, object&gt;&gt; primitiveExtractors =\n    new Dictionary&lt;Type, Func&lt;BinaryReader, object&gt;&gt;()\n    {\n        [typeof(sbyte)]  = br =&gt; br.ReadSByte(),\n        [typeof(byte)]   = br =&gt; br.ReadByte(),\n        [typeof(short)]  = br =&gt; br.ReadInt16(),\n        [typeof(ushort)] = br =&gt; br.ReadUInt16(),\n        [typeof(int)]    = br =&gt; br.ReadInt32(),\n        [typeof(uint)]   = br =&gt; br.ReadUInt32(),\n        [typeof(long)]   = br =&gt; br.ReadInt64(),\n        [typeof(ulong)]  = br =&gt; br.ReadUInt64(),\n        [typeof(float)]  = br =&gt; br.ReadSingle(),\n        [typeof(double)] = br =&gt; br.ReadDouble()\n    };\n</code></pre>\n\n<p>Как вы видите, без <code>unsafe</code> и прочих небезопасных методов можно обойтись.</p>\n\n<p>Не забудьте открыть доступ у полям.</p>\n\n<hr>\n\n<p><code>.OrderBy(f =&gt; f.MetadataToken)</code> нужно для того, чтобы порядок полей <a href=\"https://stackoverflow.com/a/11403362/276994\">соответствовал текстуальному порядку</a>.</p>\n"}