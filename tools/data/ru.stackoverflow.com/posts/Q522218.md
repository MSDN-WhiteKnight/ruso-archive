---
title: "Структура системных DLL библиотек"
se.owner.user_id: 8453
se.owner.display_name: "SuperDimon007"
se.owner.link: "https://ru.stackoverflow.com/users/8453/superdimon007"
se.link: "https://ru.stackoverflow.com/questions/522218/%d0%a1%d1%82%d1%80%d1%83%d0%ba%d1%82%d1%83%d1%80%d0%b0-%d1%81%d0%b8%d1%81%d1%82%d0%b5%d0%bc%d0%bd%d1%8b%d1%85-dll-%d0%b1%d0%b8%d0%b1%d0%bb%d0%b8%d0%be%d1%82%d0%b5%d0%ba"
se.question_id: 522218
se.post_type: question
se.score: 2
---
<p>Пускай в процессе A.exe есть функция</p>

<pre><code>int _stdcall func(int a);
</code></pre>

<p>по адресу <code>0x1234</code>. Нам надо вызвать её из другого процесса. Делается это так</p>

<pre><code>CreateRemoteThread(hProcess, 0, 0, (LPTHREAD_START_ROUTINE)0x1234, (void*)100, 0, 0);
</code></pre>

<p>В адресном пространстве A.exe начинает выполняться функция <code>func(100)</code> в отдельном потоке.
Теперь я хочу вызвать системную функцию. Например, узнать виртуальный адрес программы, вызвав <code>GetModuleHandleA(NULL)</code>:</p>

<pre><code>HMODULE hModule = GetModuleHandleA("kernel32.dll");
void *func = GetProcAddress(hModule, "GetModuleHandleA");
HANDLE ThreadID = CreateRemoteThread(hProcess, 0, 0, (LPTHREAD_START_ROUTINE)func, 0, 0, 0);
WaitForSingleObject(ThreadID, INFINITE);
void *baseAddr;
GetExitCodeThread(ThreadID, (LPDWORD)&amp;baseAddr);
</code></pre>

<p>Как получается, что функция <code>GetModuleHandleA</code> имеет одинаковый адрес в разных процессах? Всегда ли такой код будет работать корректно?<br>
Проверил, что во всех процессах адрес библиотеки kernel32 имеет одинаковый адрес. Скомпилировал программу, у которой базовый адрес совпадает с адресом библиотеки. Приложение не запускалось с кодом 0xc0000018 - конфликт указанного диапазона адресов и адресного пространства.</p>
