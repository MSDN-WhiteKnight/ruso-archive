---
title: "Зависает программа. C#"
se.owner.user_id: 313350
se.owner.display_name: "Владимир Кремлев"
se.owner.link: "https://ru.stackoverflow.com/users/313350/%d0%92%d0%bb%d0%b0%d0%b4%d0%b8%d0%bc%d0%b8%d1%80-%d0%9a%d1%80%d0%b5%d0%bc%d0%bb%d0%b5%d0%b2"
se.link: "https://ru.stackoverflow.com/questions/897028/%d0%97%d0%b0%d0%b2%d0%b8%d1%81%d0%b0%d0%b5%d1%82-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b0-c"
se.question_id: 897028
se.post_type: question
se.score: 1
---
<p>Имеется программа. Периодически зависает, не помогает ничего, т.е. только перезапуск. Место зависание в функции отправки запроса.</p>

<pre><code>public async Task&lt;string&gt; PostRequestAsync(string url, string PostData, string Referer, CancellationToken ct)
{
    string Answer;
    ct.ThrowIfCancellationRequested();
    HttpWebRequest Request = (HttpWebRequest)WebRequest.Create(url);
    if (Proxy != null)
    {
        Request.Proxy = Proxy;
    }
    else
    {
        Request.Proxy = null;
    }
    Request.Method = "POST";
    Request.KeepAlive = true;
    Request.Timeout = 10000;
    Request.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;
    Request.Host = BaseUrl.Substring(8);
    Request.KeepAlive = true;
    byte[] bytes = Encoding.UTF8.GetBytes(PostData);
    Request.ContentLength = bytes.Length;
    Request.Accept = "text/html, */*; q=0.01";
    Request.Headers.Add($"Origin: {BaseUrl}");
    Request.Headers.Add("X-Requested-With: XMLHttpRequest");
    Request.UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.168 Safari/537.36 OPR/51.0.2830.40";
    Request.ContentType = "application/x-www-form-urlencoded; charset=UTF-8";
    Request.Referer = Referer;
    Request.Headers.Add("Accept-Encoding: gzip, deflate, br");
    Request.Headers.Add("Accept-Language: ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7");
    Request.CookieContainer = LoginData;
    try
    {
        ct.ThrowIfCancellationRequested();
        using (Stream stream = await Request.GetRequestStreamAsync())
        {
            stream.Write(bytes, 0, bytes.Length);
        }
        WebResponse Response = await Request.GetResponseAsync();
        ct.ThrowIfCancellationRequested();
        using (StreamReader streamReader = new StreamReader(Response.GetResponseStream()))
        {
            Answer = await streamReader.ReadToEndAsync();
        }
        if (Answer.Contains("\\/site\\/logIn"))
        {
            Answer = "1";
            string html = await GetClearRequestAsync(BaseUrl, ct);
            var parser = new HtmlParser();
            var document = parser.Parse(html);
            string name = document.GetElementById("authentification").Children[1].GetAttribute("name").ToLower();
            string value = document.GetElementById("authentification").Children[1].GetAttribute("value").ToLower();
            string PostData1 = $"{name}={value}&amp;login={login}&amp;password={password}&amp;redirection=&amp;isBoxStyle=";
            await LoginRequestAsync(PostData1, ct);
        }
        Request.Abort();
        Response.Close();
    }
    catch
    {
        Request.Abort();
        Answer = "0";
    }
    return Answer;
}
</code></pre>

<p>Пытался разбираться в сути проблемы. Было выявлено, что наиболее часто происходит такая проблема в двух случаях:
а) Плохое соединение с интернетом
б) Слабый ПК (ещё не совсем потверждено)
Случай "а" пытался исправить путем добавление цикла do while с проверкой на положительный ответ от сервера. Не вышло. Была мысль, что это связано с бесконечными попытками открытия соединения и добавил проверку такого рода </p>

<pre><code>if(System.Net.NetworkInformation.NetworkInterface.GetIsNetworkAvailable())
</code></pre>

<p>Тоже мимо. Теперь встал в тупик как же выявлять и присекать подобные случаи. Можно заметить что в функцию передается Cancellationtoken, отменить работу программы с его помощью не удаётся.</p>

<p>P.S. Работа возможно только с HttpWebRequest, остальные средства либо не подходят по удобству реализации, либо некорректно работают с сервером, стабильности добился только при таком подходе.</p>
