{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":2,"last_activity_date":1521696646,"last_edit_date":1521696646,"creation_date":1521696144,"answer_id":802885,"question_id":801076,"body":"<p>Система отправляет события клавиатуры для консольных приложений не в процесс консольного приложения, а в системный процесс, владеющий окном консоли (csrss или conhost в зависимости от ОС), создавать цикл обработки сообщений бесполезно. Чтобы обрабатывать такие события, нужно использовать специальные функции работы с консольным вводом:</p>\n\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;locale.h&gt;  \n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n#include &lt;tchar.h&gt;\n\nVOID ErrorExit(LPSTR);\nVOID KeyEventProc(KEY_EVENT_RECORD); \nVOID MouseEventProc(MOUSE_EVENT_RECORD);\n\n#define  STR_SIZE 256\n#define BUFSIZE 65535\n#define SHIFTED 0x8000\n\nHANDLE hStdin; \nHANDLE hOut;\nDWORD fdwSaveOldMode;\n\nDWORD scan=0; //скан-код последней клавиши\nwchar_t code=0; //код символа последней клавиши\nbool alt,ctrl,shift; //состояние управляющих клавиш\n\nvoid PrintData(){\n\n    DWORD size = STR_SIZE;\n    TCHAR result[STR_SIZE];         \n\n    POINT p; // структура для координат\n    COORD cord; // структура COORD, которая указывает позицию курсора\n\n    cord.X = 0; // координата X структуры COORD\n    cord.Y = 0; // координата Y структуры COORD\n\n    SetConsoleCursorPosition(hOut, cord);\n    wsprintf(result, L\"Позиция курсора: \");\n    WriteConsole(hOut, result, wcslen(result), nullptr, nullptr);\n    GetCursorPos(&amp;p);\n    wsprintf(result, L\"x = %4ld, y = %4ld\\r\\n\", p.x, p.y);\n    WriteConsole(hOut, result, wcslen(result), nullptr, nullptr);\n\n        if(scan!=0){\n        wsprintf(result, L\"Последняя нажатая клавиша\\nScan code: %4u, Character code: %4u\\r\\n\", (UINT)scan,(UINT)code);\n        WriteConsole(hOut, result, wcslen(result), nullptr, nullptr);\n\n        if(ctrl) wsprintf(result,L\"CTRL:(+) \"); else  wsprintf(result,L\"CTRL:(-) \");\n        WriteConsole(hOut, result, wcslen(result), nullptr, nullptr);\n\n        if(shift) wsprintf(result,L\"SHIFT:(+) \"); else  wsprintf(result,L\"SHIFT:(-) \");\n        WriteConsole(hOut, result, wcslen(result), nullptr, nullptr);\n\n        if(alt) wsprintf(result,L\"ALT:(+) \"); else  wsprintf(result,L\"ALT:(-) \");\n        WriteConsole(hOut, result, wcslen(result), nullptr, nullptr);\n        }     \n\n}\n\n\nint main() \n{ \n    setlocale(LC_ALL, \"Russian\");\n    DWORD cNumRead, fdwMode, i; \n    INPUT_RECORD irInBuf[128];         \n\n    // Get the standard input handle. \n\n    hStdin = GetStdHandle(STD_INPUT_HANDLE); \n    hOut = GetStdHandle(STD_OUTPUT_HANDLE);\n\n    // Save the current input mode, to be restored on exit. \n\n    if (! GetConsoleMode(hStdin, &amp;fdwSaveOldMode) ) \n        ErrorExit(\"GetConsoleMode\"); \n\n    // Enable the window and mouse input events. \n\n    fdwMode = ENABLE_WINDOW_INPUT | ENABLE_MOUSE_INPUT; \n    if (! SetConsoleMode(hStdin, fdwMode) ) \n        ErrorExit(\"SetConsoleMode\"); \n\n    // Loop to read and handle input events. \n\n    while (1) \n    { \n        // Wait for the events. \n\n        if (! ReadConsoleInput( \n                hStdin,      // input buffer handle \n                irInBuf,     // buffer to read into \n                128,         // size of read buffer \n                &amp;cNumRead) ) // number of records read \n            ErrorExit(\"ReadConsoleInput\"); \n\n        // Dispatch the events to the appropriate handler. \n\n        for (i = 0; i &lt; cNumRead; i++) \n        {\n            switch(irInBuf[i].EventType) \n            { \n                case KEY_EVENT: // keyboard input \n                    KeyEventProc(irInBuf[i].Event.KeyEvent); \n                    break; \n\n                case MOUSE_EVENT: // mouse input \n                    MouseEventProc(irInBuf[i].Event.MouseEvent); \n                    break; \n\n                case WINDOW_BUFFER_SIZE_EVENT: \n                case FOCUS_EVENT: \n                case MENU_EVENT:   \n                    break;                 \n            } \n        }\n    } \n\n    // Restore input mode on exit.\n\n    SetConsoleMode(hStdin, fdwSaveOldMode);\n\n    return 0; \n}\n\n\nVOID KeyEventProc(KEY_EVENT_RECORD ker)\n{   \n\n    if(ker.bKeyDown){\n        scan=ker.wVirtualScanCode;\n        code=ker.uChar.UnicodeChar;\n\n        if((ker.dwControlKeyState &amp; SHIFT_PRESSED) &gt; 0) shift=true; else shift=false;\n\n        if((ker.dwControlKeyState &amp; LEFT_ALT_PRESSED) &gt; 0 || \n            (ker.dwControlKeyState &amp; RIGHT_ALT_PRESSED) &gt; 0) alt=true; \n        else alt=false;\n\n        if((ker.dwControlKeyState &amp; LEFT_CTRL_PRESSED) &gt; 0 || \n            (ker.dwControlKeyState &amp; RIGHT_CTRL_PRESSED) &gt; 0) ctrl=true; \n        else ctrl=false;\n\n        PrintData();\n    }\n\n}\n\nVOID MouseEventProc(MOUSE_EVENT_RECORD mer)\n{\n    if(mer.dwEventFlags == MOUSE_MOVED){\n        PrintData();\n    }    \n}\n\nVOID ErrorExit (LPSTR lpszMessage) \n{ \n    fprintf(stderr, \"%s\\n\", lpszMessage); \n\n    // Restore input mode on exit.\n    SetConsoleMode(hStdin, fdwSaveOldMode);\n\n    ExitProcess(0); \n}\n</code></pre>\n\n<p><a href=\"https://docs.microsoft.com/en-us/windows/console/reading-input-buffer-events\" rel=\"nofollow noreferrer\">Reading Input Buffer Events - Microsoft Docs</a></p>\n"}