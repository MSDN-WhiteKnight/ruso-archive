{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":2,"last_activity_date":1519988561,"last_edit_date":1519988561,"creation_date":1506594016,"answer_id":724245,"question_id":696725,"body":"<p>Попробуйте сделать это через Multimedia API. У меня нормально выводит FriendlyName больше 40 символов.</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Runtime.InteropServices;\nusing System.IO;\nusing System.Runtime.CompilerServices;\n\nnamespace com_test\n{\n    /*Объявления COM-интерфейсов*/\n    class Native    {\n\n        public static PROPERTYKEY PKEY_Device_FriendlyName = new PROPERTYKEY(0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 14);\n\n        public static PROPERTYKEY PKEY_AudioEndpoint_FormFactor = \n            new PROPERTYKEY(0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 0);\n\n    }\n\n    //http://www.java2s.com/Code/CSharp/Windows/SoundUtils.htm\n    [Guid(\"0BD7A1BE-7A1A-44DB-8397-CC5392387B5E\"),\n        InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n    public interface IMMDeviceCollection\n    {\n\n        //HRESULT GetCount([out, annotation(\"__out\")] UINT* pcDevices);\n\n        int GetCount(ref uint pcDevices);\n\n        //HRESULT Item([in, annotation(\"__in\")]UINT nDevice, [out, annotation(\"__out\")] IMMDevice** ppDevice);\n\n        int Item(uint nDevice, [Out, MarshalAs(UnmanagedType.Interface)] out object ppDevice);\n\n    }\n\n    [Guid(\"D666063F-1587-4E43-81F1-B948E807363F\"),\n    InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n    public interface IMMDevice\n    {\n\n        //HRESULT Activate([in, annotation(\"__in\")] REFIID iid, [in, annotation(\"__in\")] DWORD dwClsCtx, [in,unique, annotation(\"__in_opt\")] PROPVARIANT* pActivationParams, [out,iid_is(iid), annotation(\"__out\")] void** ppInterface);\n\n        int Activate(ref Guid iid, uint dwClsCtx, IntPtr pActivationParams, [Out, MarshalAs(UnmanagedType.Interface)] out object ppInterface);\n\n        //HRESULT OpenPropertyStore([in, annotation(\"__in\")] DWORD stgmAccess, [out, annotation(\"__out\")] IPropertyStore** ppProperties);\n\n        int OpenPropertyStore(int stgmAccess, [Out, MarshalAs(UnmanagedType.Interface)] out object ppProperties);\n\n        //HRESULT GetId([out,annotation(\"__deref_out\")] LPWSTR* ppstrId);\n\n        int GetId(ref StringBuilder ppstrId);\n\n        //HRESULT GetState([out, annotation(\"__out\")] DWORD* pdwState);\n\n        int GetState(ref int pdwState);\n\n    }\n\n    [ComImport, Guid(\"BCDE0395-E52F-467C-8E3D-C4579291692E\")]\n    class MMDeviceEnumerator\n    {\n    }\n\n    [Guid(\"A95664D2-9614-4F35-A746-DE8DB63617E6\"),\n    //[Guid(\"BCDE0395-E52F-467C-8E3D-C4579291692E\"),\n    InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n    public interface IMMDeviceEnumerator\n    {\n\n        //HRESULT EnumAudioEndpoints([in, annotation(\"__in\")] EDataFlow dataFlow, [in, annotation(\"__in\")] DWORD dwStateMask, [out, annotation(\"__out\")] IMMDeviceCollection** ppDevices);\n\n         int EnumAudioEndpoints(EDataFlow dataFlow, int dwStateMask, [Out, MarshalAs(UnmanagedType.Interface)] out object ppDevices);\n\n        //HRESULT GetDefaultAudioEndpoint([in, annotation(\"__in\")] EDataFlow dataFlow, [in, annotation(\"__in\")] ERole role, [out, annotation(\"__out\")] IMMDevice** ppEndpoint);\n\n         int GetDefaultAudioEndpoint(EDataFlow dataFlow, ERole role, [Out, MarshalAs(UnmanagedType.Interface)] out object ppEndpoint);\n\n        //HRESULT GetDevice([, annotation(\"__in\")]LPCWSTR pwstrId, [out, annotation(\"__out\")] IMMDevice** ppDevice);\n\n         int  GetDevice(string pwstrId, ref IntPtr ppDevice);\n\n        //HRESULT RegisterEndpointNotificationCallback([in, annotation(\"__in\")] IMMNotificationClient* pClient);\n\n         int  RegisterEndpointNotificationCallback(IntPtr pClient);\n\n        //HRESULT UnregisterEndpointNotificationCallback([in, annotation(\"__in\")] IMMNotificationClient* pClient);\n\n         int  UnregisterEndpointNotificationCallback(IntPtr pClient);\n\n    }\n\n    public enum EDataFlow\n    {\n        eRender,\n        eCapture,\n        eAll,\n        EDataFlow_enum_count\n\n    }\n\n    public enum ERole\n    {\n        eConsole,\n        eMultimedia,\n        eCommunications,\n        ERole_enum_count\n    }\n\n    //*********** Property store *****************************\n\n    [ComImport, Guid(\"886D8EEB-8CF2-4446-8D02-CDBA1DBDCF99\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n    interface IPropertyStore\n    {\n        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n        void GetCount([Out] out uint cProps);\n\n        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n        void GetAt([In] uint iProp, out PROPERTYKEY pkey);\n\n        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n        int GetValue([In] ref PROPERTYKEY key, out PropVariant pv);\n\n        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n        void SetValue([In] ref PROPERTYKEY key, [In] ref object pv);\n\n        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n        void Commit();\n    }\n\n    [StructLayout(LayoutKind.Sequential, Pack = 4)]\n    struct PROPERTYKEY\n    {\n        public Guid fmtid;\n        public uint pid;\n\n        public PROPERTYKEY(Guid guid, int propertyId)\n    {\n        this.fmtid = guid;\n        this.pid = (uint)propertyId;\n    }\n    public PROPERTYKEY(string formatId, int propertyId)\n        : this(new Guid(formatId), propertyId)\n    {\n    }\n    public PROPERTYKEY(uint a, uint b, uint c, uint d, uint e, uint f, uint g, uint h, uint i, uint j, uint k, int propertyId)\n        : this(new Guid((uint)a, (ushort)b, (ushort)c, (byte)d, (byte)e, (byte)f, (byte)g, (byte)h, (byte)i, (byte)j, (byte)k), propertyId)\n    {\n    }\n    }\n\n    //https://blogs.msdn.microsoft.com/adamroot/2008/04/11/interop-with-propvariants-in-net/\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct PropVariant\n    {\n        ushort vt;\n        ushort wReserved1;\n        ushort wReserved2;\n        ushort wReserved3;\n        IntPtr p;\n        int p2;\n\n        private byte[] GetDataBytes()\n        {\n            byte[] ret = new byte[IntPtr.Size + sizeof(int)];\n            if (IntPtr.Size == 4)\n                BitConverter.GetBytes(p.ToInt32()).CopyTo(ret, 0);\n            else if (IntPtr.Size == 8)\n                BitConverter.GetBytes(p.ToInt64()).CopyTo(ret, 0);\n            BitConverter.GetBytes(p2).CopyTo(ret, IntPtr.Size);\n            return ret;\n        }\n\n        sbyte cVal // CHAR cVal;\n        {\n            get { return (sbyte)GetDataBytes()[0]; }\n        }\n\n        short iVal // SHORT iVal;\n        {\n            get { return BitConverter.ToInt16(GetDataBytes(), 0); }\n        }\n\n        int lVal // LONG lVal;\n        {\n            get { return BitConverter.ToInt32(GetDataBytes(), 0); }\n        }\n\n        long hVal // LARGE_INTEGER hVal;\n        {\n            get { return BitConverter.ToInt64(GetDataBytes(), 0); }\n        }\n\n        float fltVal // FLOAT fltVal;\n        {\n            get { return BitConverter.ToSingle(GetDataBytes(), 0); }\n        }\n\n        public object Value\n        {\n            get\n            {\n                switch ((VarEnum)vt)\n                {\n                    case VarEnum.VT_I1:\n                        return cVal;\n                    //case VarEnum.VT_UI1:return bVal;\n                    case VarEnum.VT_I2:\n                        return iVal;\n                    //case VarEnum.VT_UI2:  return uiVal;\n                    case VarEnum.VT_I4:\n                    case VarEnum.VT_INT:\n                        return lVal;\n                    case VarEnum.VT_UI4:\n                    //case VarEnum.VT_UINT: return ulVal;\n                    case VarEnum.VT_I8:\n                        return hVal;\n                    // case VarEnum.VT_UI8:  return uhVal;\n                    case VarEnum.VT_R4:\n                        return fltVal;\n                    /*case VarEnum.VT_R8:   return dblVal;\n                    case VarEnum.VT_BOOL: return boolVal;\n                    case VarEnum.VT_ERROR:  return scode;\n                    case VarEnum.VT_CY: return cyVal;\n                    case VarEnum.VT_DATE: return date;*/\n                    case VarEnum.VT_FILETIME: return DateTime.FromFileTime(hVal);\n                    case VarEnum.VT_BSTR:\n                        return Marshal.PtrToStringBSTR(p);\n                    case VarEnum.VT_BLOB:\n                        byte[] blobData = new byte[lVal];\n                        IntPtr pBlobData;\n                        if (IntPtr.Size == 4)\n                        {\n                            pBlobData = new IntPtr(p2);\n                        }\n                        else if (IntPtr.Size == 8)\n                        {\n                            // In this case, we need to derive a pointer at offset 12,\n                            // because the size of the blob is represented as a 4-byte int\n                            // but the pointer is immediately after that.\n                            pBlobData = new IntPtr(BitConverter.ToInt64(GetDataBytes(), sizeof(int)));\n                        }\n                        else\n                            throw new NotSupportedException();\n                        Marshal.Copy(pBlobData, blobData, 0, lVal);\n                        return blobData;\n                    case VarEnum.VT_LPSTR:\n                        return Marshal.PtrToStringAnsi(p);\n                    case VarEnum.VT_LPWSTR:\n                        return Marshal.PtrToStringUni(p);\n                    case VarEnum.VT_UNKNOWN:\n                        return Marshal.GetObjectForIUnknown(p);\n                    case VarEnum.VT_DISPATCH:\n                        return p;\n                    default:\n                        throw new NotSupportedException(\"The type of this variable is not support ('\" + vt.ToString() + \"')\");\n                }\n            }\n        }\n\n    }\n    //*****************************************************\n\n\n}\n</code></pre>\n\n<hr>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Text;\nusing System.Windows.Forms;\nusing System.Runtime.InteropServices;\nusing System.ComponentModel;\n\nnamespace com_test\n{\n    public partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();\n\n            MMDeviceEnumerator devenum = new MMDeviceEnumerator();//Create CoClass\n            IMMDeviceEnumerator deviceEnumerator = (IMMDeviceEnumerator)devenum;\n            IMMDeviceCollection deviceCollection = null;\n            IMMDevice dev = null;\n            IPropertyStore propertyStore=null;\n\n            try\n            {                  \n                object o = null;\n                int hr;   \n\n                hr = deviceEnumerator.EnumAudioEndpoints(EDataFlow.eCapture, 0x0000000F /*DEVICE_STATEMASK_ALL*/, out o);               \n                deviceCollection = o as IMMDeviceCollection;\n\n                uint deviceCount = 0;\n                hr = deviceCollection.GetCount(ref deviceCount);\n\n                textBox1.Text = \"\";\n                for (uint i = 0; i &lt; deviceCount; i++)//print all devices\n                {\n                    hr = deviceCollection.Item(i, out o);\n\n                    dev = o as IMMDevice;\n\n                    //get device name\n                    hr = dev.OpenPropertyStore(0/*STGM_READ*/, out o);                    \n                    propertyStore = o as IPropertyStore;\n\n                    PropVariant friendlyName=new PropVariant();\n                    hr = propertyStore.GetValue(Native.PKEY_Device_FriendlyName, out friendlyName);                     \n\n                    //output data\n                    textBox1.Text += \"#\" + (i + 1).ToString() + \": \" + friendlyName.Value.ToString();\n                    textBox1.Text += Environment.NewLine;\n\n\n                    //clean up resources\n                    if (dev != null) { Marshal.ReleaseComObject(dev); dev = null; }\n                    if (propertyStore != null) { Marshal.ReleaseComObject(propertyStore); propertyStore = null; }\n\n\n                }\n                textBox1.Select(0, 0);\n\n            }\n            finally\n            {\n                //clean up resources\n                if (devenum != null) Marshal.ReleaseComObject(devenum);\n                if (deviceEnumerator != null) Marshal.ReleaseComObject(deviceEnumerator);\n                if (deviceCollection != null) Marshal.ReleaseComObject(deviceCollection);\n                if (dev != null) Marshal.ReleaseComObject(dev);\n                if (propertyStore != null) Marshal.ReleaseComObject(propertyStore);\n\n            }            \n\n        }\n    }\n}\n</code></pre>\n\n<hr>\n\n<p><strong>Дополнение</strong></p>\n\n<p>Для получения WaveInID устройства, нужно получить Endpoint ID всех WaveIn-устройств и сравнить его с результатом <code>device.GetID</code>:</p>\n\n<pre><code>class DShow\n{\n        [DllImport(\"winmm.dll\")]\n        public static extern uint waveInGetNumDevs();\n\n        public const uint DRV_RESERVED = 0x0800;\n        public const uint DRV_QUERYFUNCTIONINSTANCEID   =   (DRV_RESERVED + 17);\n        public const uint  DRV_QUERYFUNCTIONINSTANCEIDSIZE = (DRV_RESERVED + 18);\n        public const uint DRV_QUERYDEVICEINTERFACE = (DRV_RESERVED + 12);\n        public const uint DRV_QUERYDEVICEINTERFACESIZE = (DRV_RESERVED + 13);\n\n        [DllImport(\"winmm.dll\", SetLastError = true, CharSet = CharSet.Auto, EntryPoint = \"waveInMessage\")]\n        public static extern int waveInMessage1(uint hWaveIn, uint msg, \n            ref uint dw1, uint dw2);\n\n        [DllImport(\"winmm.dll\", SetLastError = true, CharSet = CharSet.Auto, EntryPoint = \"waveInMessage\")]\n        public static extern int waveInMessage2(uint hWaveIn, uint msg, \n            [MarshalAs(UnmanagedType.LPWStr)] StringBuilder dw1, uint dw2);\n\n        public static uint GetWaveInID(string endpid)\n        {\n            uint num = DShow.waveInGetNumDevs();\n            StringBuilder sb;\n            uint size = 0;\n            for (uint i = 0; i &lt; num; i++)\n            {\n                size = 0;\n                DShow.waveInMessage1(i, DShow.DRV_QUERYFUNCTIONINSTANCEIDSIZE, ref size, 0);\n\n                sb = new StringBuilder((int)size + 10);\n                DShow.waveInMessage2(i, DShow.DRV_QUERYFUNCTIONINSTANCEID, sb, size);                \n                if (sb.ToString() == endpid) return i;\n            }\n            throw new EntryPointNotFoundException(endpid+\" device was not found!\");\n        }\n}\n</code></pre>\n\n<hr>\n\n<p><strong>Дополнение 2</strong></p>\n\n<p>Ну и объяснение первоначальной проблемы: обрезка Friendly name в DirectShow вызвана ограничением в Wave Audio API, который он внутренне использует в Windows 7. В структуре <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/dd743839(v=vs.85).aspx\" rel=\"nofollow noreferrer\">WAVEINCAPS</a> поле под имя устройства имеет фиксированный размер в 32 байта. В Windows 10 видимо принцип работы изменили, так что эта структура не задействована. Также следует отметить, что Wave Audio API начиная с висты объявлен устаревшим, и новые приложения должны вместо него использовать соответствующие функции из Multimedia Device API, WASAPI, Windows Media Foundation или DirectShow.</p>\n\n<p>Ссылки по теме:</p>\n\n<p><a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/dd316556(v=vs.85).aspx\" rel=\"nofollow noreferrer\">Windows Multimedia Device API</a></p>\n\n<p><a href=\"https://msdn.microsoft.com/ru-ru/library/windows/desktop/dd370837(v=vs.85).aspx\" rel=\"nofollow noreferrer\">Описание понятия Endpoint ID</a></p>\n\n<p><a href=\"https://msdn.microsoft.com/ru-ru/library/windows/desktop/dd370819(v=vs.85).aspx\" rel=\"nofollow noreferrer\">Взаимодействие с Wave Audio API</a></p>\n"}