{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":6,"last_activity_date":1571122066,"last_edit_date":1571122066,"creation_date":1571121387,"answer_id":1034725,"question_id":1030195,"body":"<p>Скорее всего, Chrome использует способ с DWM API, описанный здесь: <a href=\"https://docs.microsoft.com/en-us/windows/win32/dwm/customframe\" rel=\"noreferrer\">Custom Window Frame Using DWM</a>. Суть в том, чтобы расширить клиентскую область окна на ее рамку через DwmExtendFrameIntoClientArea и допилить обработку сообщений так, чтобы стандартные кнопки свернуть-закрыть при этом продолжали работать. В WinForms это можно применить как-то так:</p>\n\n<pre><code>using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Drawing;\nusing System.Windows.Forms;\nusing System.Runtime.InteropServices;\n\nnamespace WindowsFormsApp1\n{\n    public partial class Form1 : Form\n    {      \n        //размеры отступов клиентской области\n        const int TOPEXTENDWIDTH = 1;\n        const int BOTTOMEXTENDWIDTH = 30;\n        const int LEFTEXTENDWIDTH = 1;\n        const int RIGHTEXTENDWIDTH = 1;\n\n        //WinAPI\n        [StructLayout(LayoutKind.Sequential)]\n        public struct MARGINS\n        {\n            public int cxLeftWidth;\n            public int cxRightWidth;\n            public int cyBottomHeight;\n            public int cyTopHeight;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct RECT\n        {\n            public int left, top, right, bottom;\n        }\n\n        [DllImport(\"dwmapi.dll\")]\n        static extern int DwmExtendFrameIntoClientArea(IntPtr hwnd, ref MARGINS margins);\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        static extern bool GetWindowRect(IntPtr hwnd, out RECT lpRect);\n\n        [DllImport(\"user32.dll\")]\n        static extern bool AdjustWindowRectEx(ref RECT lpRect, uint dwStyle,\n        bool bMenu, uint dwExStyle);\n\n        [DllImport(\"dwmapi.dll\")]\n        static extern bool DwmDefWindowProc(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam, ref IntPtr plResult);\n\n        static int GET_X_LPARAM(IntPtr lp)\n        {\n            short loword = (short)((ulong)lp &amp; 0xffff);\n            return loword;\n        }\n\n        static int GET_Y_LPARAM(IntPtr lp)\n        {\n            short hiword = (short)((((ulong)lp)&gt;&gt;16) &amp; 0xffff);\n            return hiword;\n        }\n\n        const uint WM_NCCALCSIZE = 0x0083;\n        const uint WM_NCHITTEST = 0x0084;\n\n        const uint WS_OVERLAPPED = 0x00000000;\n        const uint WS_CAPTION = 0x00C00000;\n        const uint WS_SYSMENU = 0x00080000;\n        const uint WS_THICKFRAME = 0x00040000;\n        const uint WS_MINIMIZEBOX = 0x00020000;\n        const uint WS_MAXIMIZEBOX = 0x00010000;\n        const uint WS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU |\n              WS_THICKFRAME |  WS_MINIMIZEBOX | WS_MAXIMIZEBOX;\n\n        const uint HTTOPLEFT = 13;\n        const uint HTTOPRIGHT = 14;\n        const uint HTTOP = 12;\n        const uint HTCAPTION = 2;\n        const uint HTLEFT = 10;\n        const uint HTNOWHERE = 0;\n        const uint HTRIGHT = 11;\n        const uint HTBOTTOM = 15;\n        const uint HTBOTTOMLEFT = 16;\n        const uint HTBOTTOMRIGHT = 17;\n\n        //обработка координат мыши для неклиентской области\n        static IntPtr HitTestNCA(IntPtr hWnd, IntPtr wParam, IntPtr lParam)\n        {\n            // Get the point coordinates for the hit test.\n            var ptMouse = new Point(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));\n\n            // Get the window rectangle.\n            RECT rcWindow;\n            GetWindowRect(hWnd, out rcWindow);\n\n            // Get the frame rectangle, adjusted for the style without a caption.\n            RECT rcFrame = new RECT();\n            AdjustWindowRectEx(ref rcFrame, WS_OVERLAPPEDWINDOW &amp; ~WS_CAPTION, false, 0);\n\n            // Determine if the hit test is for resizing. Default middle (1,1).\n            ushort uRow = 1;\n            ushort uCol = 1;\n            bool fOnResizeBorder = false;\n\n            // Determine if the point is at the top or bottom of the window.\n            if (ptMouse.Y &gt;= rcWindow.top &amp;&amp; ptMouse.Y &lt; rcWindow.top + BOTTOMEXTENDWIDTH)\n            {\n                fOnResizeBorder = (ptMouse.Y &lt; (rcWindow.top - rcFrame.top));\n                uRow = 0;\n            }\n            else if (ptMouse.Y &lt; rcWindow.bottom &amp;&amp; ptMouse.Y &gt;= rcWindow.bottom - TOPEXTENDWIDTH)\n            {\n                uRow = 2;\n            }\n\n            // Determine if the point is at the left or right of the window.\n            if (ptMouse.X &gt;= rcWindow.left &amp;&amp; ptMouse.X &lt; rcWindow.left + LEFTEXTENDWIDTH)\n            {\n                uCol = 0; // left side\n            }\n            else if (ptMouse.X &lt; rcWindow.right &amp;&amp; ptMouse.X &gt;= rcWindow.right - RIGHTEXTENDWIDTH)\n            {\n                uCol = 2; // right side\n            }\n\n            // Hit test (HTTOPLEFT, ... HTBOTTOMRIGHT)\n            IntPtr[,] hitTests = new IntPtr[,]\n            {\n                { (IntPtr)HTTOPLEFT, fOnResizeBorder? (IntPtr)HTTOP : (IntPtr)HTCAPTION, (IntPtr)HTTOPRIGHT },\n                { (IntPtr)HTLEFT,  (IntPtr)HTNOWHERE, (IntPtr)HTRIGHT},\n                { (IntPtr)HTBOTTOMLEFT, (IntPtr)HTBOTTOM, (IntPtr)HTBOTTOMRIGHT },\n            };\n\n            return hitTests[uRow, uCol];\n        }\n\n        public Form1()\n        {\n            InitializeComponent();\n\n            foreach (ToolStripMenuItem item in menuStrip1.Items)\n            {\n                item.Paint += Item_Paint;\n            }\n        }\n\n        private void Item_Paint(object sender, PaintEventArgs e)\n        {\n            var item = sender as ToolStripMenuItem;\n            if (item == null) return;\n\n            //для элементов, которые лежат на бывшей рамке окна, нужна нестандартная отрисовка\n            e.Graphics.FillRectangle(SystemBrushes.Control, 2, 2, item.Width - 4,item.Height - 4);\n            e.Graphics.DrawString(item.Text, SystemFonts.DefaultFont, SystemBrushes.ControlText, 2, 2);\n        }\n\n        //при первой активации окна расширим клиентскую область на рамку окна\n        bool dwminit = false;\n        private void Form1_Activated(object sender, EventArgs e)\n        {\n            if (dwminit == false)\n            {\n                // Extend the frame into the client area.\n                MARGINS margins = new MARGINS();\n\n                margins.cxLeftWidth = LEFTEXTENDWIDTH;\n                margins.cxRightWidth = RIGHTEXTENDWIDTH;\n                margins.cyBottomHeight = BOTTOMEXTENDWIDTH;\n                margins.cyTopHeight = TOPEXTENDWIDTH;\n\n                int hr = DwmExtendFrameIntoClientArea(this.Handle, ref margins);\n                dwminit = true;\n\n                if (hr != 0)\n                {\n                    throw Marshal.GetExceptionForHR(hr);\n                }\n            }\n        }\n\n        protected override void WndProc(ref Message m)\n        {\n            bool fCallDWP = true;\n            IntPtr lRet = IntPtr.Zero;\n            fCallDWP = !DwmDefWindowProc(m.HWnd, m.Msg, m.WParam, m.LParam, ref lRet);\n\n            if (m.Msg == WM_NCCALCSIZE)\n            {\n                if (m.WParam != (IntPtr)0)\n                {\n                    //убираем страндартную рамку\n                    lRet = IntPtr.Zero;                    \n                    fCallDWP = false;\n                }\n            }\n\n            if (m.Msg == WM_NCHITTEST &amp;&amp; lRet==IntPtr.Zero)\n            {\n                //обработка нажатий мыши\n                lRet = HitTestNCA(m.HWnd, m.WParam, m.LParam);\n\n                if (lRet != (IntPtr)HTNOWHERE)\n                {\n                    fCallDWP = false;\n                }\n            }\n\n            m.Result = lRet;\n\n            //если сообщение не обработано, передаем в базовый класс\n            if (fCallDWP) base.WndProc(ref m);\n        }             \n\n        private void Form1_Paint(object sender, PaintEventArgs e)\n        {\n            //это нужно, чтобы были видны рамка и кнопки свернуть-закрыть в Windows 10, \n            //так как рамку система принудительно заливает белым\n\n            e.Graphics.FillRectangle(Brushes.Black, 0, 0, this.Width, BOTTOMEXTENDWIDTH);\n            e.Graphics.FillRectangle(Brushes.Black, this.Width - RIGHTEXTENDWIDTH, 0, RIGHTEXTENDWIDTH, this.Height);\n            e.Graphics.FillRectangle(Brushes.Black, 0, 0, LEFTEXTENDWIDTH, this.Height);\n            e.Graphics.FillRectangle(Brushes.Black, 0, this.Height- TOPEXTENDWIDTH, this.Width, TOPEXTENDWIDTH);\n        }\n\n        private void Form1_Resize(object sender, EventArgs e)\n        {\n            //необходимо для корректной перерисовки рамки при изменении размера\n            this.Invalidate();\n        }\n\n        //другие обработчики событий...        \n    }\n}\n</code></pre>\n\n<p>Вид в Form Designer:</p>\n\n<p><a href=\"https://i.stack.imgur.com/hRoC0.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/hRoC0.png\" alt=\"designer\"></a></p>\n\n<p>Вид при запуске:</p>\n\n<p><a href=\"https://i.stack.imgur.com/g6Ac9.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/g6Ac9.png\" alt=\"runtime\"></a></p>\n\n<p>Естественно, это довольно грубый пример, заточенный под стандартную тему Windows 10 - чтобы это нормально работало независимо от темы, желательно не задавать константные отступы, а получать параметры окна через <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getsystemmetrics\" rel=\"noreferrer\">GetSystemMetrics</a>. Но я думаю, идея понятна. </p>\n\n<p>На практике этот способ для WinForms, я думаю, не очень удобен, из-за необходимости рисовать вручную все элементы, которые попадают в бывшую неклиентскую область. </p>\n\n<p><strong>Внимание:</strong> На Vista/7 этот способ будет работать только с включенным DWM Composition. На предыдущих версиях - вообще не будет.</p>\n"}