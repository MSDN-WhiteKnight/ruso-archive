{"owner":{"reputation":16137,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1543573418,"creation_date":1543573418,"answer_id":913597,"question_id":913505,"body":"<p>Батники не делают никакой магии, которая недоступна из C#. Можно сделать так:</p>\n\n<pre><code>System.Diagnostics.Process.Start(\"runas.exe\",\"параметры\");\n</code></pre>\n\n<p>Если же вас интересует, как обойтись вообще без runas, то смотрите в сторону функции <a href=\"https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-createprocesswithlogonw\" rel=\"nofollow noreferrer\">CreateProcessWithLogon</a>, она ее использует.</p>\n\n<ul>\n<li><strong>Внимание!</strong> Вызов Runas с параметром /savecred создает угрозу безопасности, так как пароль сохраняется глобально и после этого можно запустить любую программу с этим сохраненным паролем, повторно вызвав Runas с тем же именем пользователя.</li>\n</ul>\n\n<blockquote>\n  <p>запуск psExec с паролем это плохая идея. Пароль легко перехватить</p>\n</blockquote>\n\n<p>Запуск psExec с явно переданным паролем абсолютно эквивалентен запуску psExec через Runas. И в том и другом случае для подключения к удаленному компьютеру выполняется аутентификация NTLM/Kerberos, которая передает по сети не сам пароль, а некоторую функцию от него. Если у вас пароли хранятся в текстовом файле, что мешает программой считывать их из нее и подавать на вход чего угодно (хоть runas, хоть psExec)?</p>\n"}