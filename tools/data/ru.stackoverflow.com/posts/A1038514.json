{"owner":{"reputation":17975,"user_id":184217,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/87aed06c947625b429242fbcdf11f5e0?s=128&d=identicon&r=PG&f=1","display_name":"Alexander Petrov","link":"https://ru.stackoverflow.com/users/184217/alexander-petrov"},"is_accepted":false,"score":3,"last_activity_date":1572091166,"last_edit_date":1572091166,"creation_date":1571995111,"answer_id":1038514,"question_id":1037304,"body":"<p><sub>Пожалуйста, не плюсуйте это сообщение, т. к. оно не является точным ответом на вопрос. Минусовать можно.</sub></p>\n\n<p>Рассмотрим ваш код по шагам.<br>\nСчитали файл как массив байтов:</p>\n\n<pre><code>byte[] bf = File.ReadAllBytes(path);\n</code></pre>\n\n<p>Конвертировали массив байтов в base64:</p>\n\n<pre><code>string s = Convert.ToBase64String(bf);\n</code></pre>\n\n<p>Внутри метода <code>Base64Decode</code> тут же конвертировали эту base64-строку обратно в байты:</p>\n\n<pre><code>var base64EncodedBytes = System.Convert.FromBase64String(base64EncodedData);\n</code></pre>\n\n<p>То есть содержимое массивов <code>base64EncodedBytes</code> и <code>bf</code> одинаково. Можно смело выкидывать эти действия.</p>\n\n<p>Далее массив байтов преобразуется в строку:</p>\n\n<pre><code>return System.Text.Encoding.UTF8.GetString(base64EncodedBytes);\n</code></pre>\n\n<p>Я не спец в PDF, однако быстрый поиск <a href=\"https://stackoverflow.com/a/10656899/5045688\">показывает</a>, что внутри PDF могут быть разные кодировки. И не факт, что у вашего файла UTF-8. Поэтому вы могли получить кракозябры вместо текста.</p>\n\n<p>После замены вы перегоняете строку в байты кодировки UTF-8.<br>\nДалее вы опять совершаете ненужные действия: массив байтов конвертируется в base64 и тут же обратно из base64 в массив байтов.</p>\n\n<p>Как я понимаю, эти ненужные конвертации ничего не должны портить. Но они просто лишние и создают нагрузку на процессор и память.</p>\n\n<hr>\n\n<p>Вообще, незачем читать сперва байты, а потом перекодировать их в текст в нужной кодировке. Можно это сделать сразу, вызовом одного метода:</p>\n\n<pre><code>var text = File.ReadAllText(path, Encoding.UTF8);\n</code></pre>\n\n<p>Тут делаем замену: <code>text = text.Replace</code>.<br>\nЗаписываем аналогично:</p>\n\n<pre><code>File.WriteAllText(path, text, Encoding.UTF8);\n</code></pre>\n\n<p>Естественно, кодировки должны совпадать при чтении и записи.</p>\n\n<p>Можно попробовать брутфорс: перебрать все кодировки.</p>\n\n<pre><code>foreach (var encoding in Encoding.GetEncodings())\n</code></pre>\n\n<p>Их довольно много. У меня показывает 140 штук.</p>\n\n<hr>\n\n<p>Никто больше не отвечает, так что буду отдуваться.</p>\n\n<p>Почему простая строковая замена не работает? Повторю, что я не спец в PDF. Но там вполне может быть структура данных с полями определённых размеров. И когда вы делаете замену:</p>\n\n<pre><code>decodeStr.Replace(@\"/Producer (HiQPdf 11.1)\", \"/Producer (MyMy)\");\n</code></pre>\n\n<p>то очевидно, что длины строк не совпадают. Из-за этого весь текст сдвигается. Но это же не просто текст - это структура данных со множеством полей, где хранится разметка страниц, шрифты, изображения и многое другое. В результате сдвига эти данные сломались. В итоге вы получаете пустые листы.</p>\n\n<p>Самый лучший способ решения проблемы - взять библиотеку для работы с PDF, о чём уже писали в комментариях.</p>\n"}