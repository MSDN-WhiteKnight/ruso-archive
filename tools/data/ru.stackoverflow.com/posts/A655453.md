---
title: "Answer 655453"
se.owner.user_id: 10105
se.owner.display_name: "VladD"
se.owner.link: "https://ru.stackoverflow.com/users/10105/vladd"
se.answer_id: 655453
se.question_id: 654754
se.post_type: answer
se.score: 8
se.is_accepted: False
---
<p>Ну вот вам пример реализации. Сразу предупреждаю, кода будет много.</p>

<p>Возьмём в качестве основы вот такую ненадёжную функцию:</p>

<pre><code>class EvilComputation
{
    static Random random = new Random();

    public static async Task&lt;double&gt; Compute(
                int numberOfSeconds, double x, CancellationToken ct)
    {
        bool wellBehaved = random.Next(2) == 0;
        var y = x * x;
        var delay = TimeSpan.FromSeconds(numberOfSeconds);
        await Task.Delay(delay, wellBehaved ? ct : CancellationToken.None);
        return y;
    }
}
</code></pre>

<p>Вы видим, что функция плохая: она может в зависимости от случайных условий не реагировать на отмену.</p>

<p>Что делать в этом случае? Вынесем функцию в отдельный процесс. Этот процесс можно будет убить без особого вреда для исходного процесса.</p>

<p>Для того, чтобы вызвать функцию в другом процессе, нужно передать данные о вызове функции туда. Для связи используем, например, анонимные пайпы (можно использовать по сути что угодно). Я основываю код на этом примере: <a href="https://msdn.microsoft.com/en-us/library/bb546102(v=vs.110).aspx" rel="noreferrer">How to: Use Anonymous Pipes for Local Interprocess Communication</a>.</p>

<p>Для передачи данных будем использовать стандартное бинарное форматирование, раз уж мы не пошли через WCF. Нам нужны DTO-объекты, которые будут перебрасываться между процессами. Их нужно использовать в двух процессах — главном и вспомогательном (назовём его <em>плагином</em>), поэтому для DTO-типов понадобится отдельная сборка.</p>

<p>Заводим сборку <code>OutProcCommonData</code>, кладём в неё следующие классы:</p>

<pre><code>namespace OutProcCommonData
{
    [Serializable]
    public class Command // общий класс-предок для посылаемой команды
    {
    }

    [Serializable]
    public class Evaluate : Command // команда на вычисление
    {
        public int NumberOfSecondsToProcess;
        public double X;
    }

    [Serializable]
    public class Cancel : Command // команда на отмену
    {
    }
}
</code></pre>

<p>Далее, возвращаемый результат:</p>

<pre><code>namespace OutProcCommonData
{
    [Serializable]
    public class Response // общий класс-предок для возвращаемого результата
    {
    }

    [Serializable]
    public class Result : Response // готовый результат вычислений
    {
        public double Y;
    }

    [Serializable]
    public class Error : Response // ошибка с текстом
    {
        public string Text;
    }

    [Serializable]
    public class Cancelled : Response // подтверждение отмены
    {
    }
}
</code></pre>

<hr>

<p>Далее, наш плагин. Это отдельное консольное приложение (хотя, если мы не хотим видеть консоль и отладочный вывод, можно сделать его неконсольным).</p>

<p>Протокол общения таков. Главная программа посылает <code>Evaluate</code>, а после него, возможно, <code>Cancel</code>. Плагин возвращает <code>Result</code> в случае успешного вычисления, <code>Cancelled</code> в случае полученного сигнала отмены и успешно отменённого вычисления, и <code>Error</code> в случае ошибки (например, нарушения протокола коммуникации).</p>

<p>Вот обвязочный код:</p>

<pre><code>class Plugin
{
    static int Main(string[] args)
    {
        // нам должны быть переданы два аргумента: хендл входящего и исходящего пайпов
        if (args.Length != 2)
        {
            Console.Error.WriteLine("Shouldn't be started directly");
            return 1;
        }

        return new Plugin().Run(args[0], args[1]).Result;
    }

    BinaryFormatter serializer = new BinaryFormatter(); // для сериализации

    async Task&lt;int&gt; Run(string hIn, string hOut)
    {
        Console.WriteLine("[Plugin] Running");
        // открывем переданные пайпы
        using (var inStream = new AnonymousPipeClientStream(PipeDirection.In, hIn))
        using (var outStream = new AnonymousPipeClientStream(PipeDirection.Out, hOut))
        {
            try
            {
                var cts = new CancellationTokenSource(); // токен для отмены
                Console.WriteLine("[Plugin] Reading args");
                // пытаемся десериализовать аргументы
                var args = SafeGet&lt;OutProcCommonData.Evaluate&gt;(inStream);
                if (args == null)
                {
                    Console.WriteLine("[Plugin] Didn't get args");
                    // отправляем ошибку, если не удалось
                    serializer.Serialize(
                        outStream,
                        new OutProcCommonData.Error() { Text = "Unrecognized input" });
                    // и выходим
                    return 3;
                }
                Console.WriteLine("[Plugin] Got args, start compute and waiting cancel");
                // запускаем вычисление
                var computeTask =
                        EvilComputation.Compute(
                            args.NumberOfSecondsToProcess,
                            args.X,
                            cts.Token);
                // параллельно запускаем чтение возможной отмены
                var waitForCancelTask = Task.Run(() =&gt;
                        (OutProcCommonData.Cancel)serializer.Deserialize(inStream));
                // дожидаемся одного из двух
                var winner = await Task.WhenAny(computeTask, waitForCancelTask);
                // если первой пришла отмена...
                if (winner == waitForCancelTask)
                {
                    Console.WriteLine("[Plugin] Got cancel, cancelling computation");
                    // просим вычисление завершиться
                    cts.Cancel();
                }
                // окончания вычисления всё равно нужно дождаться
                Console.WriteLine("[Plugin] Awaiting computation");
                // если вычисление отменится, здесь будет исключение
                var result = await computeTask;
                Console.WriteLine("[Plugin] Sending back result");
                // отсылаем результат в пайп
                serializer.Serialize(
                    outStream,
                    new OutProcCommonData.Result() { Y = result });
                // нормальный выход
                return 0;
            }
            catch (OperationCanceledException)
            {
                // мы успешно отменили задание, рапортуем
                Console.WriteLine("[Plugin] Sending cancellation");
                serializer.Serialize(
                    outStream,
                    new OutProcCommonData.Cancelled());
                return 2;
            }
            catch (Exception ex)
            {
                // возникла непредвиденная ошибка, рапортуем
                Console.WriteLine($"[Plugin] Sending error {ex.Message}");
                serializer.Serialize(
                    outStream,
                    new OutProcCommonData.Error() { Text = ex.Message });
                return 3;
            }
        }
    }

    // ну и вспомогательная функция, которая пытается читать данные из пайпа
    T SafeGet&lt;T&gt;(Stream s) where T : class
    {
        try
        {
            return (T)serializer.Deserialize(s);
        }
        catch
        {
            return null;
        }
    }
}
</code></pre>

<p>Я не отлавливаю ошибки при записи в пайп, добавьте сами по вкусу.</p>

<hr>

<p>Теперь, главная программа. Она будет у нас отдельно от плагина (то есть, у нас получаются <em>три</em> сборки).</p>

<pre><code>class Program
{
    static void Main(string[] args) =&gt; new Program().Run().Wait();

    async Task Run()
    {
        var cts = new CancellationTokenSource();
        try
        {
            var y = await ComputeOutProc(2, cts.Token);
            Console.WriteLine($"[Main] Result: {y}");
        }
        catch (TimeoutException)
        {
            Console.WriteLine("[Main] Timed out");
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine("[Main] Cancelled");
        }
    }

    const int SecondsToSend = 3;
    const int TimeoutSeconds = 5;
    const int CancelSeconds = 2;

    BinaryFormatter serializer = new BinaryFormatter();
    async Task&lt;double&gt; ComputeOutProc(double x, CancellationToken ct)
    {
        Process plugin = null;
        bool pluginStarted = false;
        try
        {
            // создаём исходящий и входящий пайпы
            using (var commandStream = new AnonymousPipeServerStream(
                            PipeDirection.Out, HandleInheritability.Inheritable))
            using (var responseStream = new AnonymousPipeServerStream(
                            PipeDirection.In, HandleInheritability.Inheritable))
            {
                Console.WriteLine("[Main] Starting plugin");
                plugin = new Process()
                {
                    StartInfo =
                    {
                        FileName = "OutProcPlugin.exe",
                        Arguments = commandStream.GetClientHandleAsString() + " " +
                                    responseStream.GetClientHandleAsString(),
                        UseShellExecute = false
                    }
                };
                // запускаем плагин с параметрами
                plugin.Start();
                pluginStarted = true;
                Console.WriteLine("[Main] Started plugin");

                commandStream.DisposeLocalCopyOfClientHandle();
                responseStream.DisposeLocalCopyOfClientHandle();

                void Send(Command c)
                {
                    serializer.Serialize(commandStream, c);
                    commandStream.Flush();
                }

                try
                {
                    // отсылаем плагину команду на вычисление
                    Console.WriteLine("[Main] Sending evaluate request");
                    Send(new OutProcCommonData.Evaluate()
                    {
                        NumberOfSecondsToProcess = SecondsToSend,
                        X = x
                    });

                    Task&lt;Response&gt; responseTask;
                    bool readyInTime;
                    bool cancellationSent = false;
                    // внутри этого блока при отмене будем отсылать команду плагину
                    using (ct.Register(() =&gt;
                        {
                            Send(new OutProcCommonData.Cancel());
                            Console.WriteLine("[Main] Requested cancellation");
                            cancellationSent = true;
                        }))
                    {
                        Console.WriteLine("[Main] Starting getting response");
                        // ожидаем получение ответа
                        responseTask = Task.Run(() =&gt;
                                (Response)serializer.Deserialize(responseStream));
                        // или таймаута
                        var timeoutTask = Task.Delay(TimeSpan.FromSeconds(TimeoutSeconds));
                        var winner = await Task.WhenAny(responseTask, timeoutTask);
                        readyInTime = winner == responseTask;
                    }

                    // если наступил таймаут, просим процесс вежливо завершить вычисления
                    if (!readyInTime)
                    {
                        if (!cancellationSent)
                        {
                            Console.WriteLine("[Main] Not ready in time, sending cancel");
                            Send(new OutProcCommonData.Cancel());
                        }
                        else
                        {
                            Console.WriteLine("[Main] Not ready in time, cancel sent");
                        }
                        // и ждём ещё немного, ну или прихода ответа
                        var timeoutTask = Task.Delay(TimeSpan.FromSeconds(CancelSeconds));
                        await Task.WhenAny(responseTask, timeoutTask);
                    }

                    // если до сих пор ничего не пришло, плагин завис, убиваем его
                    if (!responseTask.IsCompleted)
                    {
                        Console.WriteLine("[Main] No response, killing plugin");
                        plugin.Kill(); // это завершит ожидание с исключением, по идее
                                       // в ранних версиях .NET нужно было бы поймать
                                       // это исключение
                                       // и уходим с исключением-таймаутом
                        ct.ThrowIfCancellationRequested();
                        throw new TimeoutException();
                    }

                    // здесь мы уверены, что ожидание завершилось
                    Console.WriteLine("[Main] Obtaining response");
                    var response = await responseTask; // тут может быть брошено исключение

                    // если была затребована отмена, выходим
                    ct.ThrowIfCancellationRequested();
                    // проверяем тип результата:
                    switch (response)
                    {
                    case Result r:
                        // нормальный результат, возвращаем его
                        Console.WriteLine("[Main] Got result, returning");
                        return r.Y;
                    case Cancelled _:
                        // отмена не по ct = таймаут
                        Console.WriteLine("[Main] Got cancellation");
                        throw new TimeoutException();
                    case Error err:
                        // пришла ошибка, бросаем исключение
                        // лучше, конечно, определить собственный тип здесь
                        Console.WriteLine("[Main] Got error");
                        throw new Exception(err.Text);
                    default:
                        // сюда мы вообще не должны попасть, если плагин работает нормально
                        Console.WriteLine("[Main] Unexpected error");
                        throw new Exception("Unexpected response type");
                    }
                }
                catch (IOException e)
                {
                    Console.WriteLine("[Main] IO error occured");
                    throw new Exception("IO Error", e);
                }
            }
        }
        finally
        {
            if (pluginStarted)
            {
                plugin.WaitForExit();
                plugin.Close();
            }
        }
    }
}
</code></pre>

<p>Результат пробега:</p>

<pre class="lang-none prettyprint-override"><code>[Main] Starting plugin
[Main] Started plugin
[Main] Sending evaluate request
[Main] Starting getting response
[Plugin] Running
[Plugin] Reading args
[Plugin] Got args, start compute and waiting cancel
[Plugin] Awaiting computation
[Plugin] Sending back result
[Main] Obtaining response
[Main] Got result, returning
[Main] Result: 4
</code></pre>

<p>Если поменять константу <code>SecondsToSend</code> на 10, чтобы был таймаут, получаем такой результат двух пробегов:</p>

<p>Для штатного завершения:</p>

<pre class="lang-none prettyprint-override"><code>[Main] Starting plugin
[Main] Started plugin
[Main] Sending evaluate request
[Main] Starting getting response
[Plugin] Running
[Plugin] Reading args
[Plugin] Got args, start compute and waiting cancel
[Main] Not ready in time, sending cancel
[Plugin] Got cancel, cancelling computation
[Plugin] Awaiting computation
[Plugin] Sending cancellation
[Main] Obtaining response
[Main] Got cancellation
[Main] Timed out
</code></pre>

<p>Для принудительного завершения:</p>

<pre class="lang-none prettyprint-override"><code>[Main] Starting plugin
[Main] Started plugin
[Main] Sending evaluate request
[Main] Starting getting response
[Plugin] Running
[Plugin] Reading args
[Plugin] Got args, start compute and waiting cancel
[Main] Not ready in time, sending cancel
[Plugin] Got cancel, cancelling computation
[Plugin] Awaiting computation
[Main] No response, killing plugin
[Main] Timed out
</code></pre>

<p>Если добавить перед </p>

<pre><code>var y = await ComputeOutProc(2, cts.Token);
</code></pre>

<p>преждевременную отмену:</p>

<pre><code>cts.CancelAfter(TimeSpan.FromSeconds(1));
</code></pre>

<p>получим такой результат: для штатного завершения</p>

<pre class="lang-none prettyprint-override"><code>[Main] Starting plugin
[Main] Started plugin
[Main] Sending evaluate request
[Main] Starting getting response
[Plugin] Running
[Plugin] Reading args
[Plugin] Got args, start compute and waiting cancel
[Main] Requested cancellation
[Plugin] Got cancel, cancelling computation
[Plugin] Awaiting computation
[Plugin] Sending cancellation
[Main] Obtaining response
[Main] Cancelled
</code></pre>

<p>и для принудительного завершения</p>

<pre class="lang-none prettyprint-override"><code>[Main] Starting plugin
[Main] Started plugin
[Main] Sending evaluate request
[Main] Starting getting response
[Plugin] Running
[Plugin] Reading args
[Plugin] Got args, start compute and waiting cancel
[Main] Requested cancellation
[Plugin] Got cancel, cancelling computation
[Plugin] Awaiting computation
[Main] Not ready in time, cancel sent
[Main] No response, killing plugin
[Main] Cancelled
</code></pre>

<p>Наверняка кое-где недостаточно контролируются ошибки, так что проверяйте, не нужно ли ловить какие-то ещё исключения.</p>

<hr>

<p>На эту заготовку можно добавлять сверху свою логику. Например, можно аналогично пулу потоков завести пул плагинов, и доставлять задания свободному в данный момент плагину.</p>
