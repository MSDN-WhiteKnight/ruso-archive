{"owner":{"reputation":16068,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":3,"last_activity_date":1528832334,"last_edit_date":1528832334,"creation_date":1528527408,"answer_id":839741,"question_id":835083,"body":"<p>К сожалению, используя библиотеку libusb под Windows нельзя вытянуть всю эту информацию без установки специального драйвера WinUSB. Можно только получить VID и PID (шестнадцатеричные значения типа 8086 - 1E31 в вашем примере), и по ним найти производителя и устройство в таблице известных идентификаторов, например <a href=\"http://www.linux-usb.org/usb.ids\" rel=\"nofollow noreferrer\">здесь</a>.</p>\n\n<p>Производителя и серийный номер можно получить, используя Setup API и <em>IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION</em>. Букву диска тоже можно получить только средствами Setup API, это несколько сложнее. Для этого нужно вначале построить таблицу номеров дисков для всех используемых букв дисков с помощью <em>IOCTL_STORAGE_GET_DEVICE_NUMBER</em>; затем открыть интересующее устройство (запоминающее устройство, которое является дочерним для USB-устройства), найти его номер тем же IOCTL, сравнить его со значениями из таблицы и таким образом определить букву. Как-то так: </p>\n\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;tchar.h&gt;\n#include &lt;locale.h&gt;\n\n#include &lt;windows.h&gt;\n#include &lt;Setupapi.h&gt;\n#include &lt;winusb.h&gt;\n#undef LowSpeed\n#include &lt;Usbioctl.h&gt;\n#include &lt;Devpkey.h&gt;\n\n#pragma comment(lib,\"Setupapi.lib\")\n\nvoid ErrorMes(LPCTSTR lpszFunction) \n{ \n    // Retrieve the system error message for the last-error code\n\n    LPVOID lpMsgBuf;\n    LPVOID lpDisplayBuf;\n    DWORD dw = GetLastError(); \n\n    FormatMessage(\n        FORMAT_MESSAGE_ALLOCATE_BUFFER | \n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,\n        dw,\n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n        (LPTSTR) &amp;lpMsgBuf,\n        0, NULL );\n\n    // Display the error message \n\n    lpDisplayBuf = (LPVOID)LocalAlloc(LMEM_ZEROINIT, \n        (lstrlen((LPCTSTR)lpMsgBuf) + lstrlen(lpszFunction) + 40) * sizeof(TCHAR)); \n    wprintf(L\"%s failed with error %d: %s\", \n        lpszFunction, dw, lpMsgBuf);     \n\n    LocalFree(lpMsgBuf);\n    LocalFree(lpDisplayBuf);\n}\n\n//Поиск номера диска для USB-устройства\nBOOL FindDiskNumber(LPCWSTR match, STORAGE_DEVICE_NUMBER* lpret){\n\n    BOOL retval = FALSE;\n    DEVPROPTYPE dpt=0;\n    wchar_t buffer[1024]=L\"\";\n    TCHAR id_upper[1024]=L\"\";\n    DWORD RequiredSize = 0;\n    SP_DEVINFO_DATA devinfo = { 0 };\n    SP_DEVICE_INTERFACE_DATA deviceInterface = { 0 };\n    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceInterfaceDetail = NULL;\n    BOOL res;  \n\n    HDEVINFO deviceInfoHandle = SetupDiGetClassDevs(&amp;GUID_DEVINTERFACE_DISK, 0, 0, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);\n\n    if (deviceInfoHandle != INVALID_HANDLE_VALUE)\n    {\n        int deviceIndex = 0;\n        while (true)\n        {\n            ZeroMemory(&amp;deviceInterface,sizeof(deviceInterface));\n            deviceInterface.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);\n\n            //получение всех дисков\n            if (SetupDiEnumDeviceInterfaces(deviceInfoHandle, 0, &amp;GUID_DEVINTERFACE_DISK, deviceIndex, &amp;deviceInterface))\n            {\n                DWORD cbRequired = 0;\n\n                SetupDiGetDeviceInterfaceDetail(deviceInfoHandle, &amp;deviceInterface, 0, 0, &amp;cbRequired, 0);\n                if (ERROR_INSUFFICIENT_BUFFER == GetLastError())\n                {\n                    deviceInterfaceDetail =  (PSP_DEVICE_INTERFACE_DETAIL_DATA)(new char[cbRequired]);\n                    memset(deviceInterfaceDetail, 0, cbRequired);\n                    deviceInterfaceDetail-&gt;cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);\n\n                    if (!SetupDiGetDeviceInterfaceDetail(deviceInfoHandle, &amp;deviceInterface, \n                        deviceInterfaceDetail, cbRequired, &amp;cbRequired, 0))\n                    {\n                        goto Next;\n                    }\n\n                    // Initialize the structure before using it.\n                    memset(deviceInterfaceDetail, 0, cbRequired);\n                    deviceInterfaceDetail-&gt;cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);\n\n                    // Call the API a second time to retrieve the actual\n                    // device path string.\n                    BOOL status = SetupDiGetDeviceInterfaceDetail(\n                        deviceInfoHandle,  // Handle to device information set\n                        &amp;deviceInterface,     // Pointer to current node in devinfo set\n                        deviceInterfaceDetail,   // Pointer to buffer to receive device path\n                        cbRequired,   // Length of user-allocated buffer\n                        &amp;cbRequired,  // Pointer to arg to receive required buffer length\n                        NULL);        // Not interested in additional data\n\n\n                    //получение информации о устройстве \n                    ZeroMemory(&amp;devinfo,sizeof(devinfo));\n                    devinfo.cbSize = sizeof(SP_DEVINFO_DATA);\n                    BOOL success = SetupDiEnumDeviceInfo(deviceInfoHandle, deviceIndex, &amp;devinfo);\n                    if(success==FALSE){ErrorMes(L\"SetupDiEnumDeviceInfo\"); goto Next;}\n\n                    res=SetupDiGetDeviceProperty(deviceInfoHandle,&amp;devinfo,\n                     &amp;DEVPKEY_Device_Parent,&amp;dpt,(PBYTE)buffer,1000,NULL,0);\n                    if(res==FALSE){ErrorMes(L\"SetupDiGetDeviceProperty\");goto Next;}\n\n                    int len = wcslen(buffer);\n                    for(int i=0;i&lt;len;i++){\n                        id_upper[i]=toupper(buffer[i]);//преобразование в заглавные буквы\n                    }                   \n\n                    if(wcsstr(id_upper,match)!=NULL){ //если ID родительского устройства содержит нужную строку\n\n                        /*Открываем устройство для отправки IOCTL*/                 \n                        HANDLE handle = CreateFile(deviceInterfaceDetail-&gt;DevicePath, 0, \n                        FILE_SHARE_READ | FILE_SHARE_WRITE, \n                        0, OPEN_EXISTING, 0, 0);\n\n                        if(handle==INVALID_HANDLE_VALUE) {  \n                            ErrorMes(L\"CreateFile\");goto Next;\n                        }\n\n                        STORAGE_DEVICE_NUMBER sdn = {0};\n                        DWORD nbytes = 0;\n\n                        //получение номера диска\n                        res = DeviceIoControl(handle,                // handle to device\n                            IOCTL_STORAGE_GET_DEVICE_NUMBER, // dwIoControlCode\n                            NULL,                            // lpInBuffer\n                            0,                               // nInBufferSize\n                            (LPVOID) &amp;sdn,           // output buffer\n                            (DWORD) sizeof(sdn),         // size of output buffer\n                            (LPDWORD) &amp;nbytes,       // number of bytes returned\n                            NULL      // OVERLAPPED structure\n                        );\n                        CloseHandle(handle);\n\n                        if(res != FALSE){\n                            //устройство найдено\n                            memcpy(lpret,&amp;sdn,sizeof(sdn));\n                            retval = TRUE;\n                        }\n                        else ErrorMes(L\"DeviceIoControl\");\n\n                   }\n                }\n            }\n            else\n            {\n                break;\n            }\n\n            Next:\n            if(deviceInterfaceDetail != NULL){\n                delete[] deviceInterfaceDetail;\n                deviceInterfaceDetail = NULL;\n            }\n\n            if(retval != FALSE) break; //устройство уже найдено\n\n            deviceIndex++; //следующее устройство\n        }       \n\n        SetupDiDestroyDeviceInfoList(deviceInfoHandle);\n    }\n    else ErrorMes(L\"SetupDiGetClassDevs\");\n\n    return retval;\n}\n\n//таблица номеров для всех дисков\nbool disk_IsUsed[30]={0};\nSTORAGE_DEVICE_NUMBER disk_number[30]={0};\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    setlocale(LC_ALL,\"Russian\");\n\n    HANDLE hVol;    \n    DWORD nbytes;\n    WCHAR letter;\n    WCHAR volume[100]={0};\n    int i;\n    STORAGE_DEVICE_NUMBER sdn={0};\n\n    //заполняем таблицу номеров для дисков\n    for(i=0;i&lt;30;i++){      \n        letter = 'A' + i;\n        wsprintf(volume,L\"\\\\\\\\.\\\\%c:\",letter);              \n\n        disk_IsUsed[i] = FALSE;\n        hVol = CreateFile( volume,  0, \n               FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,\n               OPEN_EXISTING, 0, NULL);\n        if(hVol == NULL || hVol == INVALID_HANDLE_VALUE){continue;} \n\n        BOOL ret = DeviceIoControl(hVol,                // handle to device\n            IOCTL_STORAGE_GET_DEVICE_NUMBER, // dwIoControlCode\n            NULL,                            // lpInBuffer\n            0,                               // nInBufferSize\n            (LPVOID) &amp;(disk_number[i]),           // output buffer\n            (DWORD) sizeof(STORAGE_DEVICE_NUMBER),         // size of output buffer\n            (LPDWORD) &amp;nbytes,       // number of bytes returned\n            NULL      // OVERLAPPED structure\n        );\n        CloseHandle(hVol);\n\n        if(ret == FALSE){continue;}                 \n\n        disk_IsUsed[i] = TRUE;      \n    }       \n\n    WCHAR match[1024]={0};\n\n    GUID guid = { 0xF18A0E88, 0xC30C, 0x11D0, { 0x88, 0x15, 0x00, 0xA0, 0xC9, 0x06, 0xBE, 0xD8 } };    \n    /*USB HUB Interface class GUID*/    \n\n    HDEVINFO deviceInfoHandle = SetupDiGetClassDevs(&amp;guid, 0, 0, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);\n\n    if (deviceInfoHandle != INVALID_HANDLE_VALUE)\n    {\n        int deviceIndex = 0;\n        while (true)\n        {\n            SP_DEVICE_INTERFACE_DATA deviceInterface = { 0 };\n            deviceInterface.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);\n\n            //получение всех USB-концентраторов\n            if (SetupDiEnumDeviceInterfaces(deviceInfoHandle, 0, &amp;guid, deviceIndex, &amp;deviceInterface))\n            {\n                DWORD cbRequired = 0;\n\n                SetupDiGetDeviceInterfaceDetail(deviceInfoHandle, &amp;deviceInterface, 0, 0, &amp;cbRequired, 0);\n                if (ERROR_INSUFFICIENT_BUFFER == GetLastError())\n                {\n                    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceInterfaceDetail = \n                        (PSP_DEVICE_INTERFACE_DETAIL_DATA)(new char[cbRequired]);\n                    memset(deviceInterfaceDetail, 0, cbRequired);\n                    deviceInterfaceDetail-&gt;cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);\n\n                    if (!SetupDiGetDeviceInterfaceDetail(deviceInfoHandle, &amp;deviceInterface, \n                        deviceInterfaceDetail, cbRequired, &amp;cbRequired, 0))\n                    {\n                        delete[] deviceInterfaceDetail;\n                        deviceIndex++;\n                        continue;\n                    }\n\n                    // Initialize the structure before using it.\n                    memset(deviceInterfaceDetail, 0, cbRequired);\n                    deviceInterfaceDetail-&gt;cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);\n\n                    // Call the API a second time to retrieve the actual\n                    // device path string.\n                    BOOL status = SetupDiGetDeviceInterfaceDetail(\n                        deviceInfoHandle,  // Handle to device information set\n                        &amp;deviceInterface,     // Pointer to current node in devinfo set\n                        deviceInterfaceDetail,   // Pointer to buffer to receive device path\n                        cbRequired,   // Length of user-allocated buffer\n                        &amp;cbRequired,  // Pointer to arg to receive required buffer length\n                        NULL);        // Not interested in additional data\n\n                    BOOL res;                   \n\n                    /*Открываем устройство для отправки IOCTL*/\n                    HANDLE handle = CreateFile(deviceInterfaceDetail-&gt;DevicePath, GENERIC_WRITE, FILE_SHARE_WRITE, \n                        0, OPEN_EXISTING, 0, 0);\n\n                    if(handle!=INVALID_HANDLE_VALUE) {\n\n                         DWORD bytes_read=0;\n                         UINT ports = 0;\n                         USB_NODE_INFORMATION nodeinfo;\n                         USB_NODE_CONNECTION_INFORMATION_EX coninfo={0};\n                         const UINT BUFSIZE = 1000;\n                         char buffer[BUFSIZE]={0};\n                         USB_DESCRIPTOR_REQUEST* req = (USB_DESCRIPTOR_REQUEST*)&amp;buffer;\n                         USB_STRING_DESCRIPTOR* desc;\n\n                         ZeroMemory(&amp;nodeinfo,sizeof(nodeinfo));\n                         nodeinfo.NodeType = UsbHub;                         \n\n                        //получаем число портов на концентраторе                         \n                        res=DeviceIoControl(handle,IOCTL_USB_GET_NODE_INFORMATION  ,\n                            &amp;nodeinfo,sizeof(nodeinfo),&amp;nodeinfo,sizeof(nodeinfo),&amp;bytes_read,0);\n\n                        if(res==FALSE)ErrorMes(L\"DeviceIoControl\"); \n                        else ports = (UINT)nodeinfo.u.HubInformation.HubDescriptor.bNumberOfPorts;\n\n                        for(int j=1;j&lt;=ports;j++){\n                            ZeroMemory(&amp;coninfo,sizeof(coninfo));\n                            coninfo.ConnectionIndex=j;\n\n                            //получаем инфу о порте\n                            res=DeviceIoControl(handle,IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX ,\n                            &amp;coninfo,sizeof(coninfo),&amp;coninfo,sizeof(coninfo),&amp;bytes_read,0);\n                            if(res==FALSE){ErrorMes(L\"DeviceIoControl\");continue;}\n\n                            if(coninfo.ConnectionStatus==0) continue; //нет устройства\n\n                            printf(\"\\n- Hub %2d, Port %2d: USB v%x device\\n\",deviceIndex,\n                                    j,(int)coninfo.DeviceDescriptor.bcdUSB);\n                            printf(\"VID: %04X PID: %04X\\n\",(int)coninfo.DeviceDescriptor.idVendor\n                                    ,(int)coninfo.DeviceDescriptor.idProduct); \n\n                            //формируем строку для поиска устройства\n                            wsprintf(match,L\"VID_%04X&amp;PID_%04X\",(UINT)coninfo.DeviceDescriptor.idVendor\n                                    ,(UINT)coninfo.DeviceDescriptor.idProduct);\n\n                            /*Serial number*/\n                            ZeroMemory(buffer,BUFSIZE);                         \n                            req-&gt;ConnectionIndex=j;\n                            req-&gt;SetupPacket.wValue = (USB_STRING_DESCRIPTOR_TYPE &lt;&lt; 8) + coninfo.DeviceDescriptor.iSerialNumber;\n                            req-&gt;SetupPacket.wLength = BUFSIZE - sizeof(USB_DESCRIPTOR_REQUEST);\n                            req-&gt;SetupPacket.wIndex = 0x409; //US English\n                            res=DeviceIoControl(handle,IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION ,\n                                &amp;buffer,sizeof(buffer),&amp;buffer,sizeof(buffer),&amp;bytes_read,0);\n                            if(res==FALSE){ErrorMes(L\"DeviceIoControl\");continue;}\n                            desc = (USB_STRING_DESCRIPTOR*)(&amp;req-&gt;Data[0]);\n                            wprintf(L\"Serial: %s\\n\",desc-&gt;bString);\n\n                            /*Vendor*/\n                            ZeroMemory(buffer,BUFSIZE);                         \n                            req-&gt;ConnectionIndex=j;\n                            req-&gt;SetupPacket.wValue = (USB_STRING_DESCRIPTOR_TYPE &lt;&lt; 8) + coninfo.DeviceDescriptor.iManufacturer;\n                            req-&gt;SetupPacket.wLength = BUFSIZE - sizeof(USB_DESCRIPTOR_REQUEST);\n                            req-&gt;SetupPacket.wIndex = 0x409; //US English\n                            res=DeviceIoControl(handle,IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION ,\n                                &amp;buffer,sizeof(buffer),&amp;buffer,sizeof(buffer),&amp;bytes_read,0);\n                            if(res==FALSE){ErrorMes(L\"DeviceIoControl\");continue;}\n                            desc = (USB_STRING_DESCRIPTOR*)(&amp;req-&gt;Data[0]);\n                            wprintf(L\"Vendor: %s\\n\",desc-&gt;bString);\n\n                            /*Product*/\n                            ZeroMemory(buffer,BUFSIZE);                         \n                            req-&gt;ConnectionIndex=j;\n                            req-&gt;SetupPacket.wValue = (USB_STRING_DESCRIPTOR_TYPE &lt;&lt; 8) + coninfo.DeviceDescriptor.iProduct;\n                            req-&gt;SetupPacket.wLength = BUFSIZE - sizeof(USB_DESCRIPTOR_REQUEST);\n                            req-&gt;SetupPacket.wIndex = 0x409; //US English\n                            res=DeviceIoControl(handle,IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION ,\n                                &amp;buffer,sizeof(buffer),&amp;buffer,sizeof(buffer),&amp;bytes_read,0);\n                            if(res==FALSE){ErrorMes(L\"DeviceIoControl\");continue;}\n                            desc = (USB_STRING_DESCRIPTOR*)(&amp;req-&gt;Data[0]);\n                            wprintf(L\"Product: %s\\n\",desc-&gt;bString);       \n\n                            /*Disk letter*/\n                            res = FindDiskNumber(match,&amp;sdn);\n                            if(res != FALSE) {\n                                for(i=0;i&lt;30;i++)   \n                                if( disk_IsUsed[i] !=FALSE \n                                    &amp;&amp; disk_number[i].DeviceNumber == sdn.DeviceNumber\n                                    &amp;&amp; disk_number[i].DeviceType == sdn.DeviceType)\n                                {\n                                    letter = 'A' + i;\n                                    printf(\"Disk letter: %c\\n\",letter);\n                                }\n                            }\n                            else printf(\"Disk letter not found\\n\");\n\n                        }\n\n                        CloseHandle(handle);\n                    }else{\n                        ErrorMes(L\"CreateFile\");//failed to open device\n                    }//endif\n\n\n                    delete[] deviceInterfaceDetail;\n                }\n            }\n            else\n            {\n                break;\n            }\n\n            ++deviceIndex;\n        }\n\n\n        SetupDiDestroyDeviceInfoList(deviceInfoHandle);\n    }\n    else ErrorMes(L\"SetupDiGetClassDevs\");\n\n    system(\"PAUSE\");\n    return 0;\n}\n</code></pre>\n\n<p>Должно вывести подобный результат:</p>\n\n<blockquote>\n  <p>&dash; Hub  3, Port  1: USB v200 device<br>\n  VID: 8564 PID: 1000<br>\n  Serial: 5B94314A<br>\n  Vendor: JetFlash<br>\n  Product: Mass Storage Device<br>\n  Disk letter: G  </p>\n  \n  <p>&dash; Hub  3, Port  4: USB v110 device<br>\n  VID: 09DA PID: 000A<br>\n  Serial: ?<br>\n  Vendor: A4Tech<br>\n  Product: USB Mouse<br>\n  Disk letter not found  </p>\n  \n  <p>&dash; Hub  3, Port  6: USB v110 device<br>\n  VID: 046E PID: 5505<br>\n  Serial: ?<br>\n  Vendor: BTC<br>\n  Product: USB Multimedia Keyboard<br>\n  Disk letter not found  </p>\n  \n  <p>&dash; Hub  3, Port 10: USB v200 device<br>\n  VID: 04E8 PID: 689E<br>\n  Serial: 1234567890ABCDEF<br>\n  Vendor: SAMSUNG Electronics Co., Ltd.<br>\n  Product: Samsung Android USB Device<br>\n  Disk letter: H  </p>\n</blockquote>\n"}