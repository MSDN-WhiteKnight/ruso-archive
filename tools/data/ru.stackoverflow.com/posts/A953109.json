{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":0,"last_activity_date":1551872046,"creation_date":1551872046,"answer_id":953109,"question_id":949643,"body":"<p><strong>Решение для .NET 4.5+ / .NET Core</strong></p>\n\n<pre><code>using System.Runtime.CompilerServices;\n\npublic static class MyName\n{\n     public static string Get([CallerMemberName] string s = \"\") { return s; }\n}\n\npublic class Class1\n{     \n     public static string name1 = \"name1\";            \n     public static string name2 = MyName.Get();            \n}\n</code></pre>\n\n<p>Примечание. Тот факт, что при использовании в инициализаторе поля CallerMemberName возвращает имя этого поля (а не имя конструктора, который на самом деле является caller'ом), не документирован. Но это работает.</p>\n\n<p><strong>Решение для более старых версий .NET</strong></p>\n\n<pre><code>using System;\nusing System.Diagnostics;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\npublic static class MyName\n{\n    static OpCode FindOpCode(short val)\n    {\n        OpCode ret = OpCodes.Nop;\n        FieldInfo[] mas = typeof(OpCodes).GetFields();\n        for (int i = 0; i &lt; mas.Length; i++)\n        {\n            if (mas[i].FieldType == typeof(OpCode))\n            {\n                OpCode opcode = (OpCode)mas[i].GetValue(null);\n                if (opcode.Value == val)\n                {\n                    ret = opcode;\n                    break;\n                }\n            }\n        }\n        return ret;\n    }\n\n    static string GetFieldNameFromOffset(MethodBase mi, int offset)\n    {\n        MethodBody mb = null;\n        string result = \"\";\n\n        //получаем тело метода                \n        mb = mi.GetMethodBody();\n        if (mb == null) throw new ApplicationException(\"Fatal error: GetMethodBody failed!\");\n\n        //получаем IL-код\n        var msil = mb.GetILAsByteArray();\n\n        //получаем модуль, в котором расположен метод\n        var module = mi.Module;\n\n        short op;\n        int n = offset;\n\n        //парсим IL-код...\n        while (true)\n        {\n            if (n &gt;= msil.Length) break;\n\n            //получаем код операции\n            if (msil[n] == 0xfe)\n                op = (short)(msil[n + 1] | 0xfe00);\n            else\n                op = (short)(msil[n]);\n\n            //найдем имя операции\n            OpCode opcode = FindOpCode(op);\n            string str = opcode.Name;\n\n            int size = 0;\n\n            //найдем размер операции\n            switch (opcode.OperandType)\n            {\n                case OperandType.InlineBrTarget: size = 4; break;\n                case OperandType.InlineField: size = 4; break;\n                case OperandType.InlineMethod: size = 4; break;\n                case OperandType.InlineSig: size = 4; break;\n                case OperandType.InlineTok: size = 4; break;\n                case OperandType.InlineType: size = 4; break;\n                case OperandType.InlineI: size = 4; break;\n                case OperandType.InlineI8: size = 8; break;\n                case OperandType.InlineNone: size = 0; break;\n                case OperandType.InlineR: size = 8; break;\n                case OperandType.InlineString: size = 4; break;\n                case OperandType.InlineSwitch: size = 4; break;\n                case OperandType.InlineVar: size = 2; break;\n                case OperandType.ShortInlineBrTarget: size = 1; break;\n                case OperandType.ShortInlineI: size = 1; break;\n                case OperandType.ShortInlineR: size = 4; break;\n                case OperandType.ShortInlineVar: size = 1; break;\n                default:\n                    throw new Exception(\"Unknown operand type.\");\n            }\n            size += opcode.Size;\n\n            int token = 0;\n            if (n &gt; offset &amp;&amp; (str == \"stsfld\" || str == \"stfld\"))\n            {\n                //найдем токен метаданных поля\n                token = (((msil[n + 1] | (msil[n + 2] &lt;&lt; 8)) |\n                    (msil[n + 3] &lt;&lt; 0x10)) | (msil[n + 4] &lt;&lt; 0x18));\n\n                //найдем поле в модуле по токену\n                var fi = module.ResolveField(token);\n                result = fi.Name;\n                return result;\n            }\n\n            n += size; //пропускаем нужное число байтов\n        }\n\n        return result;\n    }\n\n    [MethodImpl(MethodImplOptions.NoInlining)]\n    public static string Get()\n    {               \n        //найдем вызывающий метод\n        var stack = new StackTrace(true);                \n        var frame = stack.GetFrame(1);  \n        var method = frame.GetMethod();\n\n        //найдем имя поля по смещению в IL\n        var name = GetFieldNameFromOffset(method, frame.GetILOffset());\n        return name;\n    }\n}\n\npublic class Class1\n{     \n    public static string name1 = \"name1\";            \n    public static string name2 = MyName.Get();            \n}\n</code></pre>\n\n<p>Для инициализатора поля name2 в коде конструктора компилятор генерирует последовательность IL-инструкций call и stsfld. Метод StackFrame.GetILOffset позволяет нам получить смещение инструкции call в байтах относительно начала кода конструктора, а MethodInfo.GetMethodBody позволяет получить сам IL-код конструктора. Чтобы получить FieldInfo, достаточно найти инструкцию, следующую за call, вытащить токен метаданных поля и передать его в метод Module.ResolveField. Из FieldInfo уже легко получить имя поля.</p>\n"}