---
title: "Answer 513775"
se.owner.user_id: 195342
se.owner.display_name: "Harry"
se.owner.link: "https://ru.stackoverflow.com/users/195342/harry"
se.answer_id: 513775
se.question_id: 513736
se.post_type: answer
se.score: 10
se.is_accepted: True
---
<p>Официально в стандарте языка записано, если я не путаю, что переполнение знаковых целочисленных типов зависит от реализации (может генерироваться исключение, может игнорироваться), а беззнаковых игнорируется - значение приводится в представимый диапазон.</p>

<p>Т.е. получается примерно так - сам C/C++ <strong>встроенных</strong> <strong>переносимых</strong> средств обнаружения переполнения не имеет.</p>

<p>Но всегда можно использовать дополнительные методы, которые позволят по данным операндам выяснить, будет ли переполнение при выполнении операции. Масса таких вещей описана в книге Г. Уоррена <em>Алгоритмические трюки для программистов</em>.</p>

<p>Ну и как иллюстрация, насколько легко пропустить это переполнение - у Страуструпа в <em>Программирование. Принципы и практика...</em> есть одна программка, в которой вычислялся ряд для e<sup>x</sup>, что ли - и она у него в разнос шла. Он честно написал, что раньше, мол, я думал, что это связано с потерей точности в <code>double</code>, и вроде даже так и написал в первом издании книги, а потом ко второму изданию дошло, что на самом деле это переполнение целочисленных значений при вычислении факториала. Если уж даже Страуструп... :)</p>
