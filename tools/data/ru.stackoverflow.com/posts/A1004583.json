{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1563532093,"last_edit_date":1563532093,"creation_date":1563525849,"answer_id":1004583,"question_id":880130,"body":"<blockquote>\n  <p>Создание указателя на класс - невозможно (ошибка CS0208)</p>\n</blockquote>\n\n<p>Создание указателя на класс невозможно напрямую, так как он управляется сборщиком мусора и может быть перемещен в памяти. Однако, класс можно закрепить с помощью Pinned GCHandle и получить указатель на закрепленный объект - но для этого класс должен состоять только из простых типов и иметь атрибут <code>[StructLayout(LayoutKind.Sequential)]</code> (несмотря на название, его можно применить и к классу).</p>\n\n<blockquote>\n  <p>А Marshal.PtrToStructure также рассчитан только на структуры</p>\n</blockquote>\n\n<p>Строго говоря, это не так. Marshal.PtrToStructure работает и c классами, если они удовлетворяют тем же условиям: состоят только из простых типов и имеют атрибут <code>[StructLayout(LayoutKind.Sequential)]</code>.</p>\n\n<p>Вот пример использования указателей на класс:</p>\n\n<pre><code>    [StructLayout(LayoutKind.Sequential)]\n    class MyClass\n    {\n        public int A;            \n\n        public override string ToString()\n        {\n            return A.ToString();\n        }\n    }\n\n    static void Main(string[] args)\n    {\n        MyClass my0 = new MyClass { A = 2 };\n        MyClass my1 = new MyClass { A = 3 };                       \n\n        //закрепим объекты в памяти\n        GCHandle h0 = GCHandle.Alloc(my0, GCHandleType.Pinned);\n        GCHandle h1 = GCHandle.Alloc(my1, GCHandleType.Pinned);\n\n        try\n        {\n            //получим адреса объектов\n            IntPtr ptr0 = h0.AddrOfPinnedObject();\n            IntPtr ptr1 = h1.AddrOfPinnedObject();\n\n            //убедимся, что адреса реальные и по ним можно считать данные (первое поле класса)\n            Console.WriteLine(\"Значение по ptr0: \" + Marshal.ReadInt32(ptr0));\n            Console.WriteLine(\"Значение по ptr1: \" + Marshal.ReadInt32(ptr1));\n\n            IntPtr tmp = ptr0;\n            ptr0 = ptr1;\n            ptr1 = tmp;\n\n            my0 = Marshal.PtrToStructure&lt;MyClass&gt;(ptr0);\n            my1 = Marshal.PtrToStructure&lt;MyClass&gt;(ptr1);\n\n            Console.WriteLine(\"my0.A=\" + my0);\n            Console.WriteLine(\"my1.A=\" + my1);\n        }\n        finally\n        {\n            //вернем объекты в управление GC\n            h0.Free();\n            h1.Free();\n        }           \n\n        Console.ReadLine();\n    }\n</code></pre>\n\n<p>В отличие от принятого ответа, здесь используется указатель на сами данные класса, а не на заголовок объекта. Также при вызове Marshal.PtrToStructure создается новая копия объекта, вместо разыменования указателя на существующий объект. </p>\n"}