{"tags":["c++","winapi","gdi"],"owner":{"reputation":413,"user_id":219041,"user_type":"registered","accept_rate":83,"profile_image":"https://www.gravatar.com/avatar/66205112115dc0601e889774b7a6fbbd?s=128&d=identicon&r=PG&f=1","display_name":"rudolfninja","link":"https://ru.stackoverflow.com/users/219041/rudolfninja"},"is_answered":true,"view_count":144,"answer_count":1,"score":1,"last_activity_date":1540015829,"creation_date":1539854260,"last_edit_date":1540015829,"question_id":894736,"link":"https://ru.stackoverflow.com/questions/894736/%d0%9a%d0%b0%d0%ba-%d0%bd%d0%b0%d1%80%d0%b8%d1%81%d0%be%d0%b2%d0%b0%d1%82%d1%8c-%d1%80%d0%b0%d0%bc%d0%ba%d1%83-%d0%bf%d0%be%d0%b2%d0%b5%d1%80%d1%85-%d0%be%d0%ba%d0%bd%d0%b0-%d0%bf%d1%80%d0%b8%d0%bb%d0%be%d0%b6%d0%b5%d0%bd%d0%b8%d1%8f","title":"Как нарисовать рамку поверх окна приложения?","body":"<p>Нужно нарисовать рамку, поверх окна приложения из списка запущенных приложений. То есть, пользователь выбирает приложение из списка запущенных, его окно становится активным и поверх его рисуется рамка. Я пробовал поулчить <code>hdc</code> этого приложения и нарисовать рамку на этом <code>hdc</code>, но выяснилось, что такой способ работать не будет. </p>\n\n<p>В <a href=\"https://stackoverflow.com/questions/52858141/c-winapi-draw-border-on-top-of-application-window\">аналогичной теме на английской версии сайта</a> мне предложили использовать Layered Windows, но, прочитав про технологию я не понял, как это можно использовать в моём случае. Хотелось бы пример.</p>\n\n<p>Может кто сталкивался с подобным и может подсказать как можно решить мою проблему с использованием Layered Windows или без них? </p>\n\n<p>Попробовал создать Layered окно, поместить его поверх нужного окна и нарисовать на layered окне рамку, но не вышло:</p>\n\n<pre><code>const COLORREF MY_COLOR_KEY = RGB(255, 128, 0);\nHWND cmdHanlde = NULL;\nconstexpr unsigned int timerIdWindowUpdate = 1;\nconstexpr unsigned int timerIdFrameColor = 2;\nbool tick = false;\n\nint APIENTRY wWinMain(_In_ HINSTANCE hInstance,\n             _In_opt_ HINSTANCE hPrevInstance,\n             _In_ LPWSTR    lpCmdLine,\n             _In_ int       nCmdShow)\n{\nWNDCLASSEX wc = {};\nwc.cbSize = sizeof(WNDCLASSEX);\nwc.style = CS_HREDRAW | CS_VREDRAW;\nwc.lpszClassName = L\"MyTransparentFrame\";\nwc.hCursor = ::LoadCursor(NULL, IDC_ARROW);\nwc.hbrBackground = NULL;\n\nwc.lpfnWndProc = [](HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) -&gt; LRESULT\n{\nswitch (msg)\n{\ncase WM_PAINT:\n{\n    PAINTSTRUCT ps{};\n    HDC hdc = BeginPaint(hwnd, &amp;ps);\n\n    RECT rc{}; GetClientRect(hwnd, &amp;rc);\n    HPEN hPen = CreatePen(PS_SOLID, 5, tick ? RGB(255, 128, 1) : RGB(255, 201, 14));\n    HBRUSH hBrush = CreateSolidBrush(MY_COLOR_KEY);\n    HGDIOBJ hOldPen = SelectObject(hdc, hPen);\n    HGDIOBJ hOldBrush = SelectObject(hdc, hBrush);\n\n    Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);\n\n    if (hOldPen)\n        SelectObject(hdc, hOldPen);\n    if (hOldBrush)\n    SelectObject(hdc, hOldBrush);\n    if (hPen)\n        DeleteObject(hPen);\n    if (hBrush)\n        DeleteObject(hBrush);\n\n    EndPaint(hwnd, &amp;ps);\n}\nbreak;\ncase WM_TIMER:\n{\n    if (wp == timerIdWindowUpdate)\n    {\n        WINDOWPLACEMENT windowPlacement = { sizeof(WINDOWPLACEMENT), };\n        if (::GetWindowPlacement(cmdHanlde, &amp;windowPlacement))\n        {\n            if (windowPlacement.showCmd == SW_SHOWMINIMIZED\n                || !IsWindowVisible(cmdHanlde))\n            {\n                ::SetWindowPos(hwnd, cmdHanlde, 0, 0, 0, 0, SWP_HIDEWINDOW);\n\n            }\n            else\n            {\n                RECT rect = {};\n                ::GetWindowRect(cmdHanlde, &amp;rect);\n                MONITORINFO monInfo;\n                monInfo.cbSize = sizeof(MONITORINFO);\n                GetMonitorInfoW(MonitorFromWindow(cmdHanlde, MONITOR_DEFAULTTONEAREST), &amp;monInfo);\n                if (cmdHanlde != NULL &amp;&amp; ::IsZoomed(cmdHanlde))\n                {\n                    rect.left = monInfo.rcWork.left;\n                    rect.top = monInfo.rcWork.top;\n                    rect.bottom = monInfo.rcWork.bottom &gt; rect.bottom ? rect.bottom : monInfo.rcWork.bottom;\n                    rect.right = monInfo.rcWork.right &gt; rect.right ? rect.right : monInfo.rcWork.right;\n                }\n                ::SetWindowPos(hwnd, 0, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,\n                    SWP_SHOWWINDOW);\n            }\n        }\n    }\n    else if (wp == timerIdFrameColor)\n    {\n        tick = !tick;\n        ::RedrawWindow(hwnd, NULL, NULL, RDW_INVALIDATE);\n    }\n    break;\n}\ncase WM_DESTROY:\n    PostQuitMessage(0);\n    break;\n\ndefault:\n    return DefWindowProcW(hwnd, msg, wp, lp);\n}\n\nreturn 0;\n};\n\nRegisterClassEx(&amp;wc);\n\nHWND hwnd = CreateWindowExW(WS_EX_TOOLWINDOW | WS_EX_NOACTIVATE | WS_EX_LAYERED | WS_EX_TRANSPARENT, wc.lpszClassName, L\"\", WS_POPUP | WS_VISIBLE | WS_DISABLED,\n0, 0, 0, 0, nullptr, nullptr, nullptr, nullptr);\n::SetTimer(hwnd, timerIdWindowUpdate, 50, NULL);\n::SetTimer(hwnd, timerIdFrameColor, 500, NULL);\nSetLayeredWindowAttributes(hwnd, MY_COLOR_KEY, 255, LWA_COLORKEY);\nShowWindow(hwnd, SW_SHOW);\ncmdHanlde = FindWindow(L\"ConsoleWindowClass\", L\"C:\\\\WINDOWS\\\\system32\\\\cmd.exe\");\n\nMSG msg;\nwhile (GetMessage(&amp;msg, nullptr, 0, 0))\n{\nTranslateMessage(&amp;msg);\nDispatchMessage(&amp;msg);\n}\n\nreturn (int)msg.wParam;\n}\n</code></pre>\n"}