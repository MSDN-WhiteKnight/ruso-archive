{"tags":["c++","listview"],"owner":{"reputation":1415,"user_id":238013,"user_type":"registered","accept_rate":64,"profile_image":"https://www.gravatar.com/avatar/d4dab84aa4c67525aecd5da391a8e68a?s=128&d=identicon&r=PG&f=1","display_name":"D .Stark","link":"https://ru.stackoverflow.com/users/238013/d-stark"},"is_answered":true,"view_count":258,"accepted_answer_id":773005,"answer_count":1,"score":6,"last_activity_date":1516378205,"creation_date":1515507179,"last_edit_date":1516043750,"question_id":768442,"link":"https://ru.stackoverflow.com/questions/768442/%d0%9f%d0%be%d0%bb%d1%83%d1%87%d0%b5%d0%bd%d0%b8%d0%b5-%d1%81%d0%be%d0%b4%d0%b5%d1%80%d0%b6%d0%b8%d0%bc%d0%be%d0%b3%d0%be-listview-%d0%b4%d1%80%d1%83%d0%b3%d0%be%d0%b3%d0%be-%d0%be%d0%ba%d0%bd%d0%b0","title":"Получение содержимого ListView другого окна","body":"<p>Задача состоит в получении содержимого элемента ListView другого окна. Однако, данный код приводит к критическому завершению работы процесса - владельца окна. Как исправить это?</p>\n\n<pre><code>#include \"stdafx.h\"\n#include \"windows.h\"\n#include \"Commctrl.h\"\n\nint main() {\n\n    HWND hWnd = FindWindow(NULL, L\"&lt;My window name&gt;\");\n    HWND hSysListView32 = FindWindowEx(hWnd, NULL, L\"SysListView32\", NULL);\n\n    unsigned long pid;\n    GetWindowThreadProcessId(hSysListView32, &amp;pid);\n    HANDLE hProc = OpenProcess(\n        PROCESS_VM_OPERATION | PROCESS_VM_READ |\n        PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION,\n        FALSE,\n        pid);\n\n    LVITEM* lvi = new LVITEM;\n    lvi-&gt;iSubItem = 0;\n    lvi-&gt;cchTextMax = 256;\n\n    LVITEM* lviAddr = (LVITEM*)VirtualAllocEx(hProc, NULL, sizeof LVITEM, MEM_COMMIT, PAGE_READWRITE);\n    WriteProcessMemory(hProc, lviAddr, lvi, sizeof LVITEM, NULL);\n\n    if (SendMessage(hSysListView32, LVM_GETITEMTEXT, 0, (LPARAM)lviAddr) &gt; 0)\n        printf(\"%s\\n\", lvi-&gt;pszText);\n    else\n        printf(\"%d\\n\", GetLastError());\n\n    system(\"pause\");\n    return 0;\n}\n</code></pre>\n\n<hr>\n\n<p>Представляю рабочий код:</p>\n\n<pre><code>HWND hSysListView32 = FindWindowEx(hWnd, NULL, L\"SysListView32\", NULL);\nHWND hSysHeader32 = FindWindowEx(hSysListView32, NULL, L\"SysHeader32\", NULL);\n\nint itemsCount = SendMessage(hSysListView32, LVM_GETITEMCOUNT, 0, 0);\nint colCount = SendMessage(hSysHeader32, HDM_GETITEMCOUNT, 0, 0);\n\nDWORD dwProcessId;\nGetWindowThreadProcessId(hSysListView32, &amp;dwProcessId);\nHANDLE hProcess = OpenProcess(\n    PROCESS_VM_READ | PROCESS_VM_WRITE |\n    PROCESS_VM_OPERATION,\n    FALSE,\n    dwProcessId);\n\nif (!hProcess) return -1;\n\nLVITEM* lviAddress = (LVITEM*)VirtualAllocEx(hProcess, NULL, sizeof LVITEM, MEM_COMMIT, PAGE_READWRITE);\nLPTSTR pItemText = (LPTSTR)VirtualAllocEx(hProcess, NULL, sizeof TCHAR * 512, MEM_COMMIT, PAGE_READWRITE);\n\nfor (int i = 0; i &lt; itemsCount; i++)\n{\n    TCHAR itemText[512] = { 0 };\n\n    LVITEM lvItem = { 0 };\n    lvItem.mask = LVIF_TEXT;\n    lvItem.iSubItem = 0;\n    lvItem.iItem = i;\n    lvItem.pszText = pItemText;\n    lvItem.cchTextMax = 512;\n\n    WriteProcessMemory(hProcess, lviAddress, &amp;lvItem, sizeof(LVITEM), NULL);\n\n    int nSymbolsCount = SendMessage(hSysListView32, LVM_GETITEMTEXT, i, (LPARAM)lviAddress);\n    if (nSymbolsCount &gt; 0)\n        ReadProcessMemory(hProcess, pItemText, itemText, sizeof TCHAR * nSymbolsCount, NULL);\n\n    wcout &lt;&lt; itemText &lt;&lt; endl;\n}\n\nVirtualFreeEx(hProcess, pItemText, 0, MEM_RELEASE);\nVirtualFreeEx(hProcess, lviAddress, 0, MEM_RELEASE);\nCloseHandle(hProcess);\n</code></pre>\n\n<p>Однако, на этот раз проблема заключается в том, что не удаётся получить текст каждого элемента каждого столбца. В SysListView32 программы, с которой я работаю, 10 столбцов, но получить информацию о содержимом их элементов получается только для 0-2 столбцов. Дальше - неполная...</p>\n\n<p>Как это исправить? Хотя если делать перебор не в цикле, а в ручную (ну самому i задавать), любой item любого column выдаёт. Странно...</p>\n\n<hr>\n\n<p>Никто не запрещал использовать hotkeys. Это вариант решения показался мне жизнеспособным:</p>\n\n<pre><code>HWND hWnd = FindWindow(NULL, L\"&lt;ListViewWindowName&gt;\");\n\nDWORD idAttach = GetWindowThreadProcessId(GetForegroundWindow(), 0);\nDWORD idAttachTo = GetWindowThreadProcessId(hWnd, 0);\nAttachThreadInput(idAttach, idAttachTo, TRUE);\nSetFocus(hWnd);\n\nINPUT input = { 0 };\ninput.type = INPUT_KEYBOARD;\ninput.ki.wScan = 0;\ninput.ki.time = 0;\ninput.ki.dwExtraInfo = 0;\n\n// CONTROL key down.\ninput.ki.wVk = VK_CONTROL;\ninput.ki.dwFlags = 0;\nSendInput(1, &amp;input, sizeof INPUT);\n\n// \"A\" key down.\ninput.ki.wVk = 'A';\ninput.ki.dwFlags = 0;\nSendInput(1, &amp;input, sizeof INPUT);\n\n// \"A\" key up.\ninput.ki.wVk = 'A';\ninput.ki.dwFlags = KEYEVENTF_KEYUP;\nSendInput(1, &amp;input, sizeof INPUT);\n\n// CONTROL key up.\ninput.ki.wVk = VK_CONTROL;\ninput.ki.dwFlags = KEYEVENTF_KEYUP;\nSendInput(1, &amp;input, sizeof INPUT);\n\n// CONTROL key down.\ninput.ki.wVk = VK_CONTROL;\ninput.ki.dwFlags = 0;\nSendInput(1, &amp;input, sizeof INPUT);\n\n// \"C\" key down.\ninput.ki.wVk = 'C';\ninput.ki.dwFlags = 0;\nSendInput(1, &amp;input, sizeof INPUT);\n\n// \"C\" key up.\ninput.ki.wVk = 'C';\ninput.ki.dwFlags = KEYEVENTF_KEYUP;\nSendInput(1, &amp;input, sizeof INPUT);\n\n// CONTROL key up.\ninput.ki.wVk = VK_CONTROL;\ninput.ki.dwFlags = KEYEVENTF_KEYUP;\nSendInput(1, &amp;input, sizeof INPUT);\n\nAttachThreadInput(idAttach, idAttachTo, FALSE);\nSetFocus(NULL);\n</code></pre>\n\n<p>Но куда без очередных проблем... Проект на шарпе. Возникли трудности с переводом (не работает - пустой буфер обмена):</p>\n\n<pre><code>        const ushort VK_CONTROL = 0x11;\n        const uint KEYEVENTF_KEYUP = 0x0002;\n\n        enum INPUT_TYPE : uint {\n            INPUT_MOUSE = 0,\n            INPUT_KEYBOARD = 1,\n            INPUT_HARDWARE = 2\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        struct KEYBDINPUT {\n            public ushort wVk;\n            public ushort wScan;\n            public uint dwFlags;\n            public uint time;\n            public IntPtr dwExtraInfo;\n        }\n\n        [StructLayout(LayoutKind.Explicit, Size = 28)]\n        struct INPUT {\n            [FieldOffset(0)] public INPUT_TYPE type;\n            [FieldOffset(4)] public KEYBDINPUT ki;\n        }\n\n        [DllImport(\"user32.dll\", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto)]\n        static extern IntPtr FindWindow(\n            [In, Optional, MarshalAs(UnmanagedType.LPTStr)] string lpszClass,\n            [In, Optional, MarshalAs(UnmanagedType.LPTStr)] string lpszWindow);\n\n        [DllImport(\"user32.dll\", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto)]\n        static extern IntPtr GetMessageExtraInfo();\n\n        [DllImport(\"user32.dll\", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto)]\n        static extern uint SendInput(\n            [In] uint nInputs,\n            [In, MarshalAs(UnmanagedType.LPArray)] INPUT[] pInputs,\n            [In] int cbSize);\n\n        [DllImport(\"user32.dll\", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        static extern bool AttachThreadInput(\n            [In] uint idAttach,\n            [In] uint idAttachTo,\n            [In] bool fAttach);\n\n        [DllImport(\"user32.dll\", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        static extern bool SetFocus([In, Optional] IntPtr hWnd);\n\n        static INPUT FormateKbdInputStruct(ushort vkCode, bool down) {\n            return new INPUT() {\n                type = INPUT_TYPE.INPUT_KEYBOARD,\n                ki = new KEYBDINPUT() {\n                    wScan = 0,\n                    time = 0,\n                    dwExtraInfo = GetMessageExtraInfo(),\n                    wVk = vkCode,\n                    dwFlags = down ? 0 : KEYEVENTF_KEYUP\n                }\n            };\n        }\n\n        public MainForm() {\n\n            InitializeComponent();\n\n            Shown += delegate {\n                IntPtr hWnd = FindWindow(null, \"&lt;ListViewWindowName&gt;\");\n\n                uint idAttach = GetWindowThreadProcessId(GetForegroundWindow(), 0);\n                uint idAttachTo = GetWindowThreadProcessId(hWnd, 0);\n                if (!AttachThreadInput(idAttach, idAttachTo, true)) return;\n\n                INPUT[] inputs = new INPUT[] { FormateKbdInputStruct(VK_CONTROL, true) };\n                SendInput(1, inputs, Marshal.SizeOf(typeof(INPUT)));\n                inputs[0] = FormateKbdInputStruct('A', true);\n                SendInput(1, inputs, Marshal.SizeOf(typeof(INPUT)));\n                inputs[0] = FormateKbdInputStruct('A', false);\n                SendInput(1, inputs, Marshal.SizeOf(typeof(INPUT)));\n                inputs[0] = FormateKbdInputStruct('C', true);\n                SendInput(1, inputs, Marshal.SizeOf(typeof(INPUT)));\n                inputs[0] = FormateKbdInputStruct('C', false);\n                SendInput(1, inputs, Marshal.SizeOf(typeof(INPUT)));\n                inputs[0] = FormateKbdInputStruct(VK_CONTROL, false);\n                SendInput(1, inputs, Marshal.SizeOf(typeof(INPUT)));\n\n                SetFocus(hWnd);\n                SetFocus(IntPtr.Zero);\n                AttachThreadInput(idAttach, idAttachTo, false);\n\n                Debug.WriteLine(Clipboard.GetData(DataFormats.UnicodeText)); // Пусто!\n           };\n        }\n</code></pre>\n"}