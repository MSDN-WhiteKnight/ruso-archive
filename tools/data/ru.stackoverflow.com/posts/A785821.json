{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":0,"last_activity_date":1518768591,"last_edit_date":1518768591,"creation_date":1518753681,"answer_id":785821,"question_id":785708,"body":"<p>Перегрузка операторов тут не нужна. Нужен, вероятно, <code>pin_ptr</code>, в сочетании с Pinned <code>GCHandle</code> (который позволяет предотвратить перемещение объекта сборщиком мусора). Для этого придется немного модифицировать класс:</p>\n\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\ntypedef void* LPVOID ;\n\nusing namespace System;\nusing namespace System::Runtime::InteropServices;\n\nLPVOID get_native_ptr(){\n    return (LPVOID)&amp; (L\"Hello, C++/CLI world!\\n\");\n}\n\n[StructLayout(LayoutKind::Sequential)]\npublic ref class SomePtr\n{\nprivate:\n    LPVOID m_hide_ptr_;\n    GCHandle m_handle;\n\npublic:   \n    SomePtr(): m_hide_ptr_(nullptr)\n    {\n        m_hide_ptr_ = get_native_ptr(); \n        m_handle = GCHandle::Alloc(this,GCHandleType::Pinned);//закрепляем объект в памяти\n    }\n\n    IntPtr GetPtr() //получаем адрес m_hide_ptr_\n    {\n        pin_ptr&lt;LPVOID&gt; p = &amp;m_hide_ptr_;\n        return (IntPtr)p;\n    }       \n\n    //(добавить деструктор, освобождающий m_handle)\n};\n\n\nint main(array&lt;System::String ^&gt; ^args)\n{\n    SomePtr ^ foo = gcnew SomePtr();\n    LPVOID* bar= (LPVOID*)(LPVOID)foo-&gt;GetPtr();//указатель на m_hide_ptr_\n\n    wprintf(L\"%s\",*(bar));//тестируем чтение\n    *bar = (LPVOID)&amp; (L\"Thanks, bye!\\n\");//тестируем запись\n    wprintf(L\"%s\",*bar);\n    system(\"PAUSE\");\n\n    return 0;\n}\n</code></pre>\n\n<p>Не знаю, имеет ли какой-то смысл данный код, но он работает.</p>\n"}