---
title: "Answer 880147"
se.owner.user_id: 9784
se.owner.display_name: "Zergatul"
se.owner.link: "https://ru.stackoverflow.com/users/9784/zergatul"
se.answer_id: 880147
se.question_id: 880130
se.post_type: answer
se.score: 4
se.is_accepted: True
---
<p>Есть несколько причин, почему это невозможно.</p>

<p><code>Marshal.PtrToStructure&lt;Point&gt;</code> создает копию структуры. Например,
   если вы присвоите результат в локальную переменную, копия
   структуры переместится в стек. После вызова этого метода, вы можете
   изменять память, откуда была скопирована структура, и с вашей копией
   ничего не случиться. Как видно, сама операция безопасна с точки зрения целостности программы.</p>

<p>Под <code>Marshal.PtrToClass&lt;MyClass&gt;</code> вы скорее всего подразумеваете разыменование указателя (по аналогии с С++). Сборщик мусора может остановить выполнение целой программы в любом месте, и переместить объекты в памяти. Может случиться что-то такое:</p>

<pre><code>IntPtr ptr = получить_указатель_на_экземпляр_класса();
// здесь сборщик мусора остановил потоки, и переместил класс в новое место
MyClass instance = Marshal.PtrToClass&lt;MyClass&gt;(ptr); // ptr указывает непонятно куда
</code></pre>

<p><code>Marshal.PtrToStructure</code> был придуман для взаимодействия с нативным кодом. <code>.NET</code>-классы не могут в обычном понимании существовать в нативном коде, поэтому <code>PtrToClass</code> не существует.</p>

<p>Так же есть простой способ при помощи <code>GCHandle</code>, который запрещает перемещение объектов в памяти.</p>

<p>Но на C# можно и такое сделать:</p>

<pre><code>private static unsafe T PtrToClass&lt;T&gt;(IntPtr ptr)
{
    T temp = default(T);
    TypedReference tr = __makeref(temp);
    Marshal.WriteIntPtr(*(IntPtr*)(&amp;tr), ptr);

    T instance = __refvalue(tr, T);
    return instance;
}
</code></pre>

<p>Пример использования:</p>

<pre><code>class MyClass
{
    public int Value;
}
static unsafe void Main(string[] args)
{
    var instance1 = new MyClass { Value = 123 };
    var instance2 = new MyClass { Value = 321 };

    // запрещаем перемещение объектов в памяти
    var gh1 = GCHandle.Alloc(instance1, GCHandleType.Pinned);
    var gh2 = GCHandle.Alloc(instance2, GCHandleType.Pinned);

    TypedReference tr1 = __makeref(instance1);
    TypedReference tr2 = __makeref(instance2);

    IntPtr ptr1 = **(IntPtr**)(&amp;tr1);
    IntPtr ptr2 = **(IntPtr**)(&amp;tr2);

    var instance3 = PtrToClass&lt;MyClass&gt;(ptr1);
    var instance4 = PtrToClass&lt;MyClass&gt;(ptr2);
    Console.WriteLine(instance3.Value);
    Console.WriteLine(instance4.Value);

    // разрешаем GC перемещать объекты
    gh1.Free();
    gh2.Free();
}
</code></pre>
