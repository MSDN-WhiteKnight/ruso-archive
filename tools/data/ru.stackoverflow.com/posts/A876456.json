{"owner":{"reputation":187548,"user_id":10105,"user_type":"registered","accept_rate":73,"profile_image":"https://i.stack.imgur.com/d8Z7F.png?s=128&g=1","display_name":"VladD","link":"https://ru.stackoverflow.com/users/10105/vladd"},"is_accepted":true,"score":16,"last_activity_date":1538941412,"last_edit_date":1538941412,"creation_date":1535896278,"answer_id":876456,"question_id":875165,"body":"<p>Здесь упоминалось решение с Roslyn API, его тоже несложно сделать.</p>\n\n<p>Для начала, создадим анализатор, как показано в <a href=\"https://ru.stackoverflow.com/a/756891/10105\">этом ответе</a>. Мы не можем придумать разумный code fix, поэтому у нас будет лишь анализ и подсвечивание красной волнистой линией.</p>\n\n<p>Код нашего анализатора такой:</p>\n\n<pre><code>using System.Collections.Immutable;\nusing System.Linq;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Diagnostics;\n\nnamespace OverloadAnalyzer\n{\n    [DiagnosticAnalyzer(LanguageNames.CSharp)]\n    public class OverloadAnalyzerAnalyzer : DiagnosticAnalyzer\n    {\n        public const string DiagnosticId = \"OverloadAnalyzer\";\n\n        private static readonly string Title = \"MessageBox.Show only with owner\";\n        private static readonly string MessageFormat = \"Use overload with owner\";\n        private static readonly string Description =\n            \"You must always specify an owner for MessageBox.Show\";\n        private const string Category = \"Framework usage\";\n\n        // соберём описание нашего правила\n        private static DiagnosticDescriptor Rule = new DiagnosticDescriptor(\n            DiagnosticId, Title, MessageFormat, Category,\n            DiagnosticSeverity.Error, // укажен, что это ошибка, а не предупреждение\n            isEnabledByDefault: true, description: Description);\n\n        // список диагностик, которые мы выдаём\n        public override ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics =&gt;\n            ImmutableArray.Create(Rule);\n\n        // при инициализации подпишемся на анализ всех команд вызова функции\n        public override void Initialize(AnalysisContext context)\n        {\n            context.RegisterSyntaxNodeAction(AnalyzeSymbol,\n                                             SyntaxKind.InvocationExpression);\n        }\n\n        // сам анализатор\n        private static void AnalyzeSymbol(SyntaxNodeAnalysisContext context)\n        {\n            // получаем синтаксический узел, приводим его к типу «вызов функции»\n            var invocationNode = (InvocationExpressionSyntax)context.Node;\n\n            // мелкая эвристика для ускорения: если среди имён в выражении нет Show,\n            // дальнейший дорогой семантический анализ не имеет смысла\n            if (!invocationNode.DescendantNodes()\n                               .OfType&lt;IdentifierNameSyntax&gt;()\n                               .Any(n =&gt; n.Identifier.ValueText == \"Show\"))\n                return;\n\n            // получаем символ у семантической модели\n            var symInfo = context.SemanticModel.GetSymbolInfo(invocationNode);\n            var methodSymbol = (IMethodSymbol)symInfo.Symbol;\n            // если его нет (например, у нас некомпилирующийся код), отваливаем\n            if (methodSymbol == null)\n                return;\n\n            // проверяем, что это действительно вызов MessageBox.Show\n            if (methodSymbol.ContainingAssembly.Name != \"System.Windows.Forms\")\n                return;\n            if (methodSymbol.ContainingType.ToDisplayString() !=\n                    \"System.Windows.Forms.MessageBox\")\n                return;\n\n            // если в списке параметров есть параметр с типом IWin32Window, всё хорошо\n            if (methodSymbol.Parameters.Any(p =&gt; p.Type.Name == \"IWin32Window\"))\n                return;\n\n            // иначе говорим юзеру «атата!»\n            var diagnostic = Diagnostic.Create(Rule, invocationNode.GetLocation());\n            context.ReportDiagnostic(diagnostic);\n        }\n    }\n}\n</code></pre>\n\n<p>Получаем вот такое поведение:</p>\n\n<p><a href=\"https://i.stack.imgur.com/LtMNL.gif\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/LtMNL.gif\" alt=\"а я Roslyn ещё больше ку!\"></a></p>\n\n<p>Если вы хотите ещё и проверять код во время построения (а то вдруг программист отключит анализатор или не использует Visual Studio?), вам нужно будет написать ещё и анализатор командной строки, аналогично тому, как описано <a href=\"https://ru.stackoverflow.com/a/810044/10105\">здесь</a>, и запускать его при построении на build-сервере (или в post-build step).</p>\n\n<p>У меня получился вот такой анализатор командной строки:</p>\n\n<pre><code>using System;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nusing Microsoft.Build.Locator;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.MSBuild;\n\nnamespace CommandLineOverloadAnalyzer\n{\n    class Program\n    {\n        static void Usage()\n        {\n            Console.WriteLine(\"Usage: CommandLineOverloadAnalyzer.exe SolutionPath\" +\n                              \" MSBuildPath [\\\"batch\\\"]\");\n            Console.WriteLine(\"if batch specified, no extra output is done\");\n            Console.WriteLine(\"if no batch specified, MSBuildPath may be omitted\" +\n                              \" and will be asked for if needed\");\n        }\n\n        static async Task&lt;int&gt; Main(string[] args)\n        {\n            if ((args.Length &lt; 1 || args.Length &gt; 3) ||\n                (args.Length == 3 &amp;&amp; args[2] != \"batch\"))\n            {\n                Usage();\n                return 1;\n            }\n            var solutionPath = args[0];\n            var msBuildPath = (args.Length &gt; 1) ? args[1] : null;\n            bool batchMode = args.Length == 3;\n\n            // найдём версию MSBuild\n            var visualStudioInstances =\n                MSBuildLocator.QueryVisualStudioInstances().ToArray();\n            var instance =\n                // указан путь, выбираем его\n                (msBuildPath != null) ? visualStudioInstances.SingleOrDefault(\n                                                   i =&gt; i.MSBuildPath == msBuildPath) :\n                // только одна студия, выбираем её\n                visualStudioInstances.Length == 1 ? visualStudioInstances[0] :\n                // в пакетном режиме? падаем\n                batchMode ? null :\n                // спрашиваем у юзера\n                SelectVisualStudioInstance(visualStudioInstances);\n            if (instance == null)\n            {\n                Console.WriteLine(\"Cannot determine MSBuild path\");\n                return 1;\n            }\n\n            void Out(string s)\n            {\n                if (!batchMode)\n                    Console.WriteLine(s);\n            }\n\n            Out($\"Using MSBuild at '{instance.MSBuildPath}' to load projects.\");\n\n            // Экземпляр MSBuildLocator должен быть зарегистрирован\n            // перед MSBuildWorkspace.Create(), иначе MEF-композиция не сработает\n            MSBuildLocator.RegisterInstance(instance);\n\n            bool hadProblems = false;\n            using (var workspace = MSBuildWorkspace.Create())\n            {\n                // Напечатаем сообщение при приходе WorkspaceFailed, чтобы\n                // помочь с диагностикой проблем загрузки проектов\n                workspace.WorkspaceFailed += (o, e) =&gt; Out(e.Diagnostic.Message);\n\n                Out($\"Loading solution '{solutionPath}'\");\n\n                // печатаем прогресс при интерактивной загрузке\n                var solution = await workspace.OpenSolutionAsync(solutionPath,\n                    batchMode ? null : new ConsoleProgressReporter());\n                Out($\"Finished loading solution '{solutionPath}'\");\n\n                foreach (var project in solution.Projects)\n                {\n                    Out($\"Processing project {project.Name}\");\n                    var compilation = await project.GetCompilationAsync();\n\n                    // для каждого файла в проекте отдельное синтаксическое дерево\n                    foreach (var syntaxTree in compilation.SyntaxTrees)\n                    {\n                        var root = await syntaxTree.GetRootAsync();\n                        // создаём семантический анализатор\n                        var model = compilation.GetSemanticModel(syntaxTree);\n                        // получаем все типы переменных\n                        foreach (var invocationNode in root.DescendantNodes()\n                                             .OfType&lt;InvocationExpressionSyntax&gt;())\n                        {\n                            if (!invocationNode.DescendantNodes()\n                                               .OfType&lt;IdentifierNameSyntax&gt;()\n                                               .Any(n =&gt; n.Identifier.ValueText == \"Show\"))\n                                continue;\n\n                            var symInfo = model.GetSymbolInfo(invocationNode);\n                            var methodSymbol = (IMethodSymbol)symInfo.Symbol;\n                            if (methodSymbol == null)\n                                continue;\n                            if (methodSymbol.ContainingAssembly.Name !=\n                                    \"System.Windows.Forms\")\n                                continue;\n                            if (methodSymbol.ContainingType.ToDisplayString() !=\n                                    \"System.Windows.Forms.MessageBox\")\n                                continue;\n\n                            if (methodSymbol.Parameters.Any(p =&gt; p.Type.Name ==\n                                    \"IWin32Window\"))\n                                continue;\n\n                            var location = invocationNode.GetLocation().GetLineSpan();\n                            Console.WriteLine(\n                                $\"MessageBox.Show usage is wrong, location = {location}\");\n                            hadProblems = true;\n                        }\n                    }\n                }\n            }\n\n            return hadProblems ? 1 : 0;\n        }\n\n        private static VisualStudioInstance SelectVisualStudioInstance(\n            VisualStudioInstance[] visualStudioInstances)\n        {\n            Console.WriteLine(\"Multiple installs of MSBuild detected, please select one:\");\n            for (int i = 0; i &lt; visualStudioInstances.Length; i++)\n            {\n                Console.WriteLine($\"Instance {i + 1}\");\n                Console.WriteLine($\"    Name: {visualStudioInstances[i].Name}\");\n                Console.WriteLine($\"    Version: {visualStudioInstances[i].Version}\");\n                Console.WriteLine(\n                    $\"    MSBuild Path: {visualStudioInstances[i].MSBuildPath}\");\n            }\n\n            while (true)\n            {\n                var userResponse = Console.ReadLine();\n                if (int.TryParse(userResponse, out int instanceNumber) &amp;&amp;\n                    instanceNumber &gt; 0 &amp;&amp;\n                    instanceNumber &lt;= visualStudioInstances.Length)\n                {\n                    return visualStudioInstances[instanceNumber - 1];\n                }\n                Console.WriteLine(\"Input not accepted, try again.\");\n            }\n        }\n\n        private class ConsoleProgressReporter : IProgress&lt;ProjectLoadProgress&gt;\n        {\n            public void Report(ProjectLoadProgress loadProgress)\n            {\n                var projectDisplay = Path.GetFileName(loadProgress.FilePath);\n                if (loadProgress.TargetFramework != null)\n                {\n                    projectDisplay += $\" ({loadProgress.TargetFramework})\";\n                }\n\n                Console.WriteLine(\n                    $\"{loadProgress.Operation,-15}\" +\n                    $\" {loadProgress.ElapsedTime,-15:m\\\\:ss\\\\.fffffff}\" +\n                    $\" {projectDisplay}\");\n            }\n        }\n\n        private class SilentProgressReporter : IProgress&lt;ProjectLoadProgress&gt;\n        {\n            public void Report(ProjectLoadProgress loadProgress) { }\n        }\n    }\n}\n</code></pre>\n\n<p>В Post-Build step укажите просто</p>\n\n<pre><code>\"&lt;путь к анализатору&gt;\\CommandLineOverloadAnalyzer.exe\" \"$(SolutionPath)\" \"$(MSBuildBinPath)\" batch\n</code></pre>\n\n<p>У меня при пробном пробеге вывело:</p>\n\n<blockquote>\n  <p>MessageBox.Show usage is wrong, location = &lt;полный путь>\\RoslynTest\\SampleApp\\Program.cs: (13,12)-(13,46)</p>\n</blockquote>\n"}