{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":4,"last_activity_date":1538218220,"last_edit_date":1538218220,"creation_date":1538131175,"answer_id":886630,"question_id":883318,"body":"<p>GDI+ не поддерживает работу с SVG. Также в Windows нет другого стандартного средства для работы с SVG, доступного во всех поддерживаемых версиях ОС. Можно предложить несколько обходных путей.</p>\n\n<h1>Вариант 1 - Парсинг XML</h1>\n\n<p>Если вам нужен только небольшой набор элементов из SVG, можно написать свой парсер, вытянуть из SVG данные и отрисовать объекты вручную. Поскольку SVG основан на XML, можно использовать любую библиотеку для работы с XML, например <a href=\"https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms763742(v%3dvs.85)\" rel=\"nofollow noreferrer\">MSXML</a>. Пример чтения данных есть <a href=\"https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms767594%28v%3dvs.85%29\" rel=\"nofollow noreferrer\">здесь</a>.</p>\n\n<h1>Вариант 2 - Использование метафайлов</h1>\n\n<p>GDI+ поддерживает <a href=\"https://docs.microsoft.com/ru-ru/dotnet/framework/winforms/advanced/metafiles-in-gdi\" rel=\"nofollow noreferrer\">метафайлы</a> (EMF/WMF), стандартный для Windows формат векторной графики. Он поддерживает далеко не все, что есть в SVG, но с базовыми фигурами справляется. Можно преобразовать SVG в метафайл с помощью сторонней программы или онлайн-сервиса, и использовать в программе уже его.</p>\n\n<p>Например, создадим такой простейший SVG:</p>\n\n<pre><code>&lt;svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.0\"&gt;\n&lt;circle cx=\"200\" cy=\"200\" r=\"150\" stroke=\"red\" fill=\"green\" stroke-width=\"10\"/&gt;\n&lt;/svg&gt;\n</code></pre>\n\n<p>Перегоним его в WMF с помощью <a href=\"https://cloudconvert.com/svg-to-emf\" rel=\"nofollow noreferrer\">онлайн-сервиса</a>, получим такой <a href=\"https://yadi.sk/d/-p1JyS-5kzYhvw\" rel=\"nofollow noreferrer\">файл</a> (он по какой-то причине некорректно отображается в Paint, но он не поврежден; при отрисовке с помощью кода ниже он нормально отображается).</p>\n\n<p>Напишем код для отрисовки метафайла:</p>\n\n<pre><code>#include &lt;Windows.h&gt;\n#include &lt;gdiplus.h&gt;\n#pragma comment(lib, \"gdiplus.lib\")\n\nconst int W_IMAGE = 6000; //для метафайлов почему-то приходится задавать очень большую ширину и высоту, иначе они не попадают в область отображения.\nconst int H_IMAGE = 6000;\n\nGdiplus::Metafile * wmf = NULL;\n\n//...\n\nLRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    switch (message)\n    {\n    case WM_CREATE:\n        {\n        //загрузка изображения\n        wmf = new Gdiplus::Metafile(L\"D:\\\\images\\\\circle.wmf\");\n        }\n        break;\n    case WM_PAINT:\n        {\n            //отрисовка изображения\n            PAINTSTRUCT ps;\n            HDC hdc = BeginPaint(hWnd, &amp;ps);\n\n            Gdiplus::Graphics g(hdc);            \n\n            if(wmf != NULL){\n                g.DrawImage(wmf,0, 0, 0, 0, W_IMAGE, H_IMAGE, Gdiplus::Unit::UnitPixel);\n            }\n\n            EndPaint(hWnd, &amp;ps);\n        }\n        break;\n    case WM_DESTROY:\n        PostQuitMessage(0);\n        break;\n    default:\n        return DefWindowProc(hWnd, message, wParam, lParam);\n    }\n    return 0;\n}\n</code></pre>\n\n<p>Результат:</p>\n\n<p><img src=\"https://i.stack.imgur.com/a6fnR.png\" alt=\"screenshot\"></p>\n\n<h1>Вариант 3 - Преобразование в растровое изображение</h1>\n\n<p>Можно преобразовать SVG в Bitmap (в отличие от предыдущего способа, это легко сделать на лету, программно) и нарисовать его. Например так, с помощью MSHTML и OLE (требует наличия IE 11):</p>\n\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n#include &lt;Windows.h&gt;\n#include &lt;oleidl.h&gt;\n#include &lt;Mshtml.h&gt;\n#include &lt;gdiplus.h&gt;\n#pragma comment(lib, \"gdiplus.lib\")\n\nconst int W_IMAGE = 600;\nconst int H_IMAGE = 600;\n\n//Глобальные переменные\nHINSTANCE hInst;                               // текущий экземпляр\nWCHAR szTitle[100] = L\"Window\";                  // текст строки заголовка\nWCHAR szWindowClass[100] = L\"MyClass\";           // имя класса главного окна\nGdiplus::Bitmap* svgbitmap = NULL;             // объект изображения\n\n//объявления функций, включенных в этот модуль кода:\nATOM                MyRegisterClass(HINSTANCE hInstance);\nBOOL                InitInstance(HINSTANCE, int);\nLRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);\n\nvoid DocumentWrite(IHTMLDocument2* pdoc, const WCHAR* content) {\n\n    HRESULT hr = 0;\n    VARIANT *param;\n    BSTR bstr = SysAllocString(content);\n\n    // Creates a new one-dimensional array\n    SAFEARRAY *psaStrings = SafeArrayCreateVector(VT_VARIANT, 0, 1);\n    if (psaStrings == NULL) {\n        goto cleanup;\n    }\n\n    hr = SafeArrayAccessData(psaStrings, (LPVOID*)&amp;param);\n    param-&gt;vt = VT_BSTR;\n    param-&gt;bstrVal = bstr;\n    hr = SafeArrayUnaccessData(psaStrings);\n    hr = pdoc-&gt;write(psaStrings);\ncleanup:\n    // SafeArrayDestroy calls SysFreeString for each BSTR\n    if (psaStrings != NULL) {\n        SafeArrayDestroy(psaStrings);\n    }\n}\n\n// *** Преобразование SVG в Bitmap ***\nGdiplus::Bitmap* SvgToBitmap(const WCHAR* svgcontent, int w_image, int h_image) {\n\n    const int HIMETRIC_INCH = 2540; \n    SIZEL sz = { 0 };\n    RECTL rcClient = { 0 };\n    HDC screendc;\n    HDC hdc;\n\n    WCHAR svghtml1[] = L\"&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=11\\\" /&gt;&lt;/head&gt;&lt;body&gt;\";\n    WCHAR svghtml2[] = L\"&lt;/body&gt;&lt;/html&gt;\";\n\n    Gdiplus::Bitmap* bmp = NULL;\n    Gdiplus::Graphics* g = NULL;\n    IHTMLDocument2* d2 = NULL;\n    IOleObject* pObj = NULL;\n    IViewObject* pView = NULL;\n\n    BOOL b = SystemParametersInfo(SPI_GETWORKAREA, 0, &amp;rcClient, 0);\n    if (b == FALSE) { rcClient.bottom = 480; rcClient.right = 640; }\n\n    int width = (int)(rcClient.right - rcClient.left);\n    int height = (int)(rcClient.bottom - rcClient.top);\n\n\n    //создание документа\n    HRESULT hr = CoCreateInstance(CLSID_HTMLDocument, NULL, CLSCTX_INPROC_SERVER, IID_IHTMLDocument2, (LPVOID*)&amp;d2);\n    if (FAILED(hr)) {\n        MessageBox(NULL, L\"CoCreateInstance failed\", NULL, MB_OK|MB_ICONERROR); goto End;\n    }\n\n    hr = d2-&gt;QueryInterface(IID_IOleObject, (LPVOID*)&amp;pObj);\n    if (FAILED(hr)) { MessageBox(NULL, L\"QueryInterface failed\", 0, 0); goto End; }\n\n    //установка размера документа\n    screendc = GetDC(NULL);\n    sz.cx = (UINT)MulDiv(width, HIMETRIC_INCH, GetDeviceCaps(screendc, LOGPIXELSX));\n    sz.cy = (UINT)MulDiv(height, HIMETRIC_INCH, GetDeviceCaps(screendc, LOGPIXELSY));\n    ReleaseDC(NULL,screendc);\n\n    hr = pObj-&gt;SetExtent(DVASPECT_CONTENT,&amp;sz);\n    if (FAILED(hr)) { MessageBox(NULL, L\"SetExtent failed\", NULL, MB_OK | MB_ICONERROR); goto End; }\n\n    //запись SVG в документ\n    DocumentWrite(d2, svghtml1);\n    DocumentWrite(d2, svgcontent);\n    DocumentWrite(d2, svghtml2);\n    d2-&gt;close();    \n\n    //преобразование в Bitmap\n    hr = d2-&gt;QueryInterface(IID_IViewObject, (LPVOID*)&amp;pView);\n    if (FAILED(hr)) { MessageBox(NULL, L\"Cannot get IViewObject!\", NULL, MB_OK | MB_ICONERROR); goto End; }\n\n    bmp = new Gdiplus::Bitmap(w_image, h_image);\n    g = Gdiplus::Graphics::FromImage(bmp);\n\n    hdc = g-&gt;GetHDC();\n    hr = pView-&gt;Draw(DVASPECT_CONTENT,-1, NULL, NULL, NULL, hdc, &amp; rcClient, NULL,NULL, 0); \n    g-&gt;ReleaseHDC(hdc); \n\n    if (FAILED(hr)) MessageBox(NULL, L\"Draw failed\", NULL, MB_OK | MB_ICONERROR);\n\nEnd:\n\n    if( g != NULL) delete g;\n    if (d2 != NULL)d2-&gt;Release();\n    if (pObj != NULL)pObj-&gt;Release();\n    if (pView != NULL)pView-&gt;Release(); \n\n    return bmp;\n}\n\n// *** GUI ***\nint APIENTRY wWinMain(_In_ HINSTANCE hInstance,\n                     _In_opt_ HINSTANCE hPrevInstance,\n                     _In_ LPWSTR    lpCmdLine,\n                     _In_ int       nCmdShow)\n{\n    UNREFERENCED_PARAMETER(hPrevInstance);\n    UNREFERENCED_PARAMETER(lpCmdLine);\n\n    CoInitialize(NULL);    \n    Gdiplus::GdiplusStartupInput gdiplusStartupInput;\n    ULONG_PTR gdiplusToken;\n    Gdiplus::GdiplusStartup(&amp;gdiplusToken, &amp;gdiplusStartupInput, NULL);\n    MyRegisterClass(hInstance);\n\n    // Выполнить инициализацию приложения\n    if (!InitInstance (hInstance, nCmdShow))\n    {\n        return FALSE;\n    }    \n\n    MSG msg;\n\n    while (GetMessage(&amp;msg, nullptr, 0, 0))\n    {       \n            TranslateMessage(&amp;msg);\n            DispatchMessage(&amp;msg);        \n    }\n\n    return (int) msg.wParam;\n}\n\n\nATOM MyRegisterClass(HINSTANCE hInstance)\n{\n    WNDCLASSEXW wcex = { 0 };\n    wcex.cbSize = sizeof(WNDCLASSEX);\n    wcex.style          = CS_HREDRAW | CS_VREDRAW;\n    wcex.lpfnWndProc    = WndProc;\n    wcex.cbClsExtra     = 0;\n    wcex.cbWndExtra     = 0;\n    wcex.hInstance      = hInstance;   \n    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);\n    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);    \n    wcex.lpszClassName  = szWindowClass;    \n    return RegisterClassExW(&amp;wcex);\n}\n\n\nBOOL InitInstance(HINSTANCE hInstance, int nCmdShow)\n{\n   hInst = hInstance; // Сохранить маркер экземпляра в глобальной переменной\n\n   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,\n      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);\n\n   if (!hWnd)\n   {\n      return FALSE;\n   }\n\n   ShowWindow(hWnd, nCmdShow);\n   UpdateWindow(hWnd);\n\n   return TRUE;\n}\n\nLRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    switch (message)\n    {\n    case WM_CREATE:\n        {\n\n        //загрузка изображения\n        std::wifstream fStream(L\"c:\\\\web\\\\image.svg\");      \n        std::wstringstream wstrStream;\n        wstrStream &lt;&lt; fStream.rdbuf();\n        std::wstring s = wstrStream.str();      \n\n        svgbitmap = SvgToBitmap(s.c_str(), W_IMAGE, H_IMAGE);\n\n        }\n        break;\n    case WM_PAINT:\n        {\n            //отрисовка изображения\n            PAINTSTRUCT ps;\n            HDC hdc = BeginPaint(hWnd, &amp;ps);\n            Gdiplus::Graphics g(hdc);\n\n            Gdiplus::Status res = g.DrawImage(svgbitmap, 0, 0, 0, 0, W_IMAGE, H_IMAGE, Gdiplus::Unit::UnitPixel);\n\n            EndPaint(hWnd, &amp;ps);\n        }\n        break;\n    case WM_DESTROY:\n        PostQuitMessage(0);\n        break;\n    default:\n        return DefWindowProc(hWnd, message, wParam, lParam);\n    }\n    return 0;\n}\n</code></pre>\n"}