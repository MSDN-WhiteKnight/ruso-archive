{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":5,"last_activity_date":1528954760,"creation_date":1528954760,"answer_id":841834,"question_id":840790,"body":"<blockquote>\n  <p>Влияет ли как-то на GetILAsByteArray() режим компиляции</p>\n</blockquote>\n\n<p>Ответ - \"да\". В этом легко убедиться на практике. Напишем тестовый метод:</p>\n\n<pre><code>public void Method(int a, int b)\n{    \n    string str = (a+b).ToString();\n    MessageBox.Show(str);\n}\n</code></pre>\n\n<p>Далее, напишем такой код для извлечения первого операнда из его MSIL-кода и отображения имени операции:</p>\n\n<pre><code>using System;\nusing System.Text;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\n...\n\nvar mi = this.GetType().GetMethod(\"Method\");\nbyte[] msil = mi.GetMethodBody().GetILAsByteArray();\nushort op;\n\nif(msil[0]==0xfe) \n    op = (ushort)(msil[1] | 0xfe00);\nelse \n    op = (ushort)(msil[0]);\n\n//найдем имя операции\nstring str=\"\";\nFieldInfo[] mas = typeof(OpCodes).GetFields();\nfor(int i=0;i&lt;mas.Length;i++)\n{                \n    if (mas[i].FieldType == typeof(OpCode))\n    {\n        OpCode opcode = (OpCode)mas[i].GetValue(null);\n        if (opcode.Value == op)\n        {\n            str = opcode.ToString();\n            break;\n        }\n    }\n}\n\ntextBox1.Text = \"0x\"+op.ToString(\"X4\")+\": \"+str;\n</code></pre>\n\n<p><strong>Результат:</strong> </p>\n\n<p>Debug - <code>0x0000: nop</code></p>\n\n<p>Release - <code>0x0003: ldarg.1</code></p>\n\n<p>Объясняется это тем, что в отладочной сборке в начале каждого метода вставляется пустой оператор для облегчения отладки (чтобы можно было поставить точку останова на самое начало метода, тогда как в релизной сборке можно только на первую строку). Таким образом, режим компиляции действительно влияет на IL-код метода.</p>\n"}