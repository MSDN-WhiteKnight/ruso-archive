{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":2,"last_activity_date":1536659324,"creation_date":1536659324,"answer_id":879984,"question_id":878097,"body":"<p>График аудиофайла типично строится как график зависимости средних или пиковых абсолютных  амплитуд от времени (для стерео-записи, верхняя половина графика представляет один канал, а вторая, направленная вниз - второй). </p>\n\n<p>Алгоритм выглядит так:</p>\n\n<ol>\n<li><p>Выделить из WAV-данных массив мгновенных значений звука (семплов) в формате, с которым удобно работать (например, значения float в диапазоне от -1.0 до 1.0). Информацию о том, как это делается, можно найти например <a href=\"https://ru.stackoverflow.com/questions/760083/wav-data-%D0%BA%D0%B0%D0%BA-%D1%81%D0%B8%D0%B4%D1%8F%D1%82-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5?rq=1\">здесь</a>.</p></li>\n<li><p>Разбить массив на интервалы,  примерно соответствующие пикселю на изображении графика. Формула для вычисления длины интервала:</p></li>\n</ol>\n\n<blockquote>\n  <p>interval = (N_SAMPLES) / (K * W_WINDOW);</p>\n</blockquote>\n\n<p>где </p>\n\n<p><strong>N_SAMPLES</strong> - число семплов (одного канала);<br>\n<strong>W_WINDOW</strong> - ширина окна для отображения графика, в пикселах;<br>\n<strong>K</strong> - коэффициент, задающий \"детализированность\" графика, обычно в диапазоне (1.0; 2.0).    </p>\n\n<ol start=\"3\">\n<li><p>Определить значение модуля амплитуды (среднее, пиковое) на каждом интервале</p></li>\n<li><p>Нарисовать график с помощью любой графической библиотеки</p></li>\n</ol>\n\n<p>Пример кода для построения графика средних амплитуд одного канала (т.е., верхней половины приведенного рисунка):</p>\n\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;memory.h&gt;\n#include &lt;math.h&gt;\n#include &lt;glut.h&gt;   //Для рисования\n\n#pragma comment(lib, \"opengl32.lib\")\n#pragma comment(lib, \"glu32.lib\")\n#pragma comment(lib, \"glut32.lib\")\n\nstruct  WAV_HEADER\n{\n    /* RIFF Chunk Descriptor */\n    uint8_t         RIFF[4];        // RIFF Header Magic header\n    uint32_t        ChunkSize;      // RIFF Chunk Size\n    uint8_t         WAVE[4];        // WAVE Header\n                                    /* \"fmt\" sub-chunk */\n    uint8_t         fmt[4];         // FMT header\n    uint32_t        Subchunk1Size;  // Size of the fmt chunk\n    uint16_t        AudioFormat;    // Audio format 1=PCM,6=mulaw,7=alaw,     257=IBM Mu-Law, 258=IBM A-Law, 259=ADPCM\n    uint16_t        NumOfChan;      // Number of channels 1=Mono 2=Sterio\n    uint32_t        SamplesPerSec;  // Sampling Frequency in Hz\n    uint32_t        bytesPerSec;    // bytes per second\n    uint16_t        blockAlign;     // 2=16-bit mono, 4=16-bit stereo\n    uint16_t        bitsPerSample;  // Number of bits per sample\n                                    /* \"data\" sub-chunk */\n    uint32_t         Subchunk2ID; // \"data\"  string\n    uint32_t        Subchunk2Size;  // Sampled data length\n};\n\n\n//Возвращает следующий семпл начиная с указанной позиции в массиве байт\nfloat ReadNextSample (        \n    /*IN*/ WAV_HEADER* hdr, //заголовок WAV\n    /*IN*/ unsigned char* rawdata, //данные WAV\n    /*IN,OUT*/ uint64_t * startindex //начальный индекс (после вызова функции устанавливается в индекс следующего семпла)\n){\n      float res = 0.0f;\n      unsigned char byte = 0;\n      int16_t val16 = 0;\n\n      switch (hdr-&gt;AudioFormat)\n      {\n        case 1://PCM\n        if (hdr-&gt;bitsPerSample == 8)\n        {      \n            byte = rawdata[*startindex];\n            *startindex += 1;\n            res = (byte - 128.0f) / 255.0f;\n\n         }\n         else if (hdr-&gt;bitsPerSample == 16)\n         {\n            memcpy(&amp;val16,rawdata+(*startindex),2);\n            *startindex += 2;\n            res = (val16) / 32767.0f;\n\n         }         \n\n         if (res &gt; 1.0f) res = 1.0f;\n         if (res &lt; -1.0f) res = -1.0f;\n         break;\n\n         case 3: //IEEE Float\n         if (hdr-&gt;bitsPerSample == 32) {\n                memcpy(&amp;res,rawdata+(*startindex),sizeof(float));\n                        *startindex += sizeof(float);\n         }\n         break;\n\n      }\n\n      return res;\n}\n\n//Преобразует данные WAV в массив нормализованных Float-значений в интервале (-1.0;1.0). Возвращает размер массива.\nuint64_t GetSamples(\n    /* IN */ WAV_HEADER* hdr, //заголовок WAV\n    /* IN */ unsigned char* data, //данные WAV\n    /* OUT */ float** psamples //выходной массив\n){\n\n    float* samples = NULL;\n    uint64_t samples_count = hdr-&gt;Subchunk2Size / ((int)hdr-&gt;bitsPerSample / 8);\n    samples = (float*)malloc(samples_count * sizeof(float));\n    uint64_t i_data; \n    uint64_t i_sample=0;    \n\n    for(i_data=0; i_data&lt;hdr-&gt;Subchunk2Size; ){     \n        if(i_sample&gt;=samples_count)break;\n        samples[i_sample] = ReadNextSample(hdr,data,&amp;i_data);       \n        i_sample++;\n    }\n\n    *psamples = samples;\n    return i_sample;\n}\n\n\n//Считывает заголовок и данные WAV из файла\nuint64_t ReadWav(\n    /* IN */ wchar_t* file, //путь к файлу\n    /* OUT */ WAV_HEADER* hdr, //указатель на переменную для записи заголовка\n    /* OUT */ unsigned char** pdata //указатель на переменную для записи данных\n){\n    memset(hdr,0,sizeof(WAV_HEADER));\n    FILE* f = _wfopen(file,L\"rb\");\n    if(f == NULL){\n        printf(\"Cannot open file!\\n\");\n        return 0;\n    }\n\n    //считываем заголовок\n    fread(&amp;(hdr-&gt;RIFF),4,1,f);\n    fread(&amp;(hdr-&gt;ChunkSize),4,1,f);\n    fread(&amp;(hdr-&gt;WAVE),4,1,f);\n    fread(&amp;(hdr-&gt;fmt),4,1,f);\n    fread(&amp;(hdr-&gt;Subchunk1Size),4,1,f);\n\n    if(!(hdr-&gt;RIFF[0] == 'R' &amp;&amp; hdr-&gt;RIFF[1] == 'I' &amp;&amp; hdr-&gt;RIFF[2] == 'F' &amp;&amp; hdr-&gt;RIFF[3] == 'F') ||\n       !(hdr-&gt;WAVE[0] == 'W' &amp;&amp; hdr-&gt;WAVE[1] == 'A' &amp;&amp;  hdr-&gt;WAVE[2] == 'V' &amp;&amp;  hdr-&gt;WAVE[3] == 'E')){\n           printf(\"File is not RIFF/WAV!\\n\");\n           fclose(f);\n           return 0;\n    }\n\n    fread(&amp;(hdr-&gt;AudioFormat),2,1,f);\n    fread(&amp;(hdr-&gt;NumOfChan),2,1,f);\n    fread(&amp;(hdr-&gt;SamplesPerSec),4,1,f);\n    fread(&amp;(hdr-&gt;bytesPerSec),4,1,f);\n    fread(&amp;(hdr-&gt;blockAlign),2,1,f);\n    fread(&amp;(hdr-&gt;bitsPerSample),2,1,f);\n\n    uint16_t fmtExtraSize = 0;  \n    if (hdr-&gt;Subchunk1Size == 18) {  \n        fread(&amp;(fmtExtraSize),2,1,f);                        \n        fseek(f,fmtExtraSize,SEEK_CUR);\n    }         \n\n    unsigned char* data=NULL;\n    size_t data_size;\n    size_t res; \n\n    //пытаемся считать данные\n    fread(&amp;(hdr-&gt;Subchunk2ID),4,1,f);\n    fread(&amp;(hdr-&gt;Subchunk2Size),4,1,f);\n\n    while(1){\n      data = (unsigned char*)malloc(hdr-&gt;Subchunk2Size);\n      data_size = fread(data,1,hdr-&gt;Subchunk2Size,f);     \n\n      if(hdr-&gt;Subchunk2ID == 0x61746164) break;//данные найдены\n\n      //если Subchunk2Id нет тот, что ожидался, пропускаем и пробуем снова\n      free(data);\n      data = NULL;\n      hdr-&gt;Subchunk2ID = 0;\n      hdr-&gt;Subchunk2Size = 0;\n\n      res=fread(&amp;(hdr-&gt;Subchunk2ID),4,1,f);\n      if(res &lt; 4)break;\n      res=fread(&amp;(hdr-&gt;Subchunk2Size),4,1,f);\n      if(res &lt; 4)break;\n    }\n\n    fclose(f);\n    *pdata = data;\n    if(data == NULL || hdr-&gt;Subchunk2Size == 0) return 0;\n\n    if(data_size &lt; hdr-&gt;Subchunk2Size) {\n        printf(\"Warning: data size is lower then expected!\\n\");\n        hdr-&gt;Subchunk2Size = res;\n    }\n\n    return hdr-&gt;Subchunk2Size;\n}\n\nfloat* values = NULL; //массив значений Y для графика\nuint64_t interval=0; //размер интервала усреднения\nuint64_t intervals = 0; //количество интервалов\nint width = 500; //ширина окна\n\nvoid Initialize()\n{\n //Выбрать фоновый цвет\n glClearColor(1.0,1.0,1.0,1.0);\n\n //Установить проекцию\n glMatrixMode(GL_PROJECTION);\n glLoadIdentity();\n glOrtho(0.0,1.0,0.0,1.0,-1.0,1.0);\n}\n\nvoid DrawGraph(float* values,uint64_t count) //отрисовка графика по массиву значений\n{ \n\n glColor3f(0.0,1.0,0.0); //Выбираем цвет\n glBegin(GL_LINES);\n\n float x0,y0;\n float x,y;\n\n //Задаем точки  \n for(int i=0;i&lt;intervals;i++){\n\n    x0=i * 1.0f/(intervals);\n    y0=values[i];\n    glVertex3f(x0,y0,0.0); \n\n    x=(i+1) * 1.0f/(intervals);\n    y=values[i+1];\n    glVertex3f(x,y,0.0);    \n }\n\n glEnd();\n glFlush();\n}\n\nvoid Draw(){\n    DrawGraph(values,intervals);\n}\n\nint main(int argc, char **argv)\n{\n\n    WAV_HEADER hdr={0}; //заголовок WAV \n    unsigned char* bytes = NULL; //данные WAV   \n\n    float* data = NULL; //массив семплов\n    uint64_t count = 0; //число семплов\n\n    //считываем файл\n    if(ReadWav(L\"c:\\\\Media\\\\File1.wav\",&amp;hdr,&amp;bytes)==0){\n        getchar();\n        return 0;\n    }   \n\n    //получаем массив семплов\n    count = GetSamples(&amp;hdr,bytes,&amp;data);\n    free(bytes);    \n\n    //определяем интервал для усреднения\n    int chans = hdr.NumOfChan;\n    interval = (count/ chans) / (1.5f* width);\n\n    if(interval==0) interval=1;\n    intervals = (count/ chans) / interval;\n\n    //формируем массив значений для графика\n    values = (float*)malloc(intervals*sizeof(float));   \n    float y;\n\n    for(int i=0;i&lt;intervals;i++){\n        y=0.0f;\n        for(int j=i*interval;j&lt;(i+1)*interval;j++){\n            if(j*chans&gt;=count)break;            \n            y += abs(data[j * chans]);\n        }\n        y =   y/(float)interval; //находим среднее значение для каждого интервала\n        values[i]=y;        \n    }\n\n    free(data); \n\n    glutInit(&amp;argc,argv);\n    glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);\n    glutInitWindowSize(width,400);      //Размер окна\n    glutInitWindowPosition(100,100);    //Позиция окна\n    glutCreateWindow(\"Graph\");      \n    Initialize();                       \n    glutDisplayFunc(Draw);              //Задаем функцию отрисовки\n    glutMainLoop(); \n    return 0;\n}\n</code></pre>\n\n<p>Поддерживает форматы кодирования PCM (8 или 16 бит) и IEEE Float (32 бит). Требует Visual C++ 2010+ и библиотеку <a href=\"https://www.opengl.org/resources/libraries/glut/\" rel=\"nofollow noreferrer\">Glut</a>.</p>\n\n<p><strong>Источники:</strong></p>\n\n<p><a href=\"https://manual.audacityteam.org/man/audacity_waveform.html\" rel=\"nofollow noreferrer\">Audacity Waveform</a></p>\n\n<p><a href=\"https://stackoverflow.com/questions/26663494/algorithm-to-draw-waveform-from-audio\">Algorithm to draw waveform from audio</a></p>\n\n<p><a href=\"http://www.supermegaultragroovy.com/2009/10/06/drawing-waveforms/\" rel=\"nofollow noreferrer\">Drawing Waveforms</a></p>\n"}