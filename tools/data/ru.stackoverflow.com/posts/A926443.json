{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":0,"last_activity_date":1545986898,"creation_date":1545986898,"answer_id":926443,"question_id":923818,"body":"<p>Для того, чтобы ReadProcessMemory отработала успешно, нужно следующее:</p>\n\n<ol>\n<li><p>Дескриптор процесса должен быть открыт с правом PROCESS_VM_READ. У вас он открывается с правом PROCESS_TERMINATE, что явно не то.</p></li>\n<li><p><strong>Вся</strong> запрашиваемая область памяти быть доступна на чтение. Так как вы запрашиваете область, начинающуюся от нулевого байта, у вас всегда будет выбивать ошибку, ведь часть младших адресов памяти зарезервирована для отлова багов с обращением к нулевым указателям и недоступна на чтение. Нужно считывать память блоками меньшего размера.</p></li>\n</ol>\n\n<p>Также, для адресов лучше использовать тип IntPtr, а не uint, иначе программа не сможет корректно работать при 64-битной целевой архитектуре.</p>\n\n<p>Пример считывания первого доступного блока памяти в 1024 байта:</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.IO;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        public enum DesiredAccessProcess : uint\n        {\n            PROCESS_TERMINATE = 0x0001,\n            PROCESS_CREATE_THREAD = 0x0002,\n            PROCESS_VM_OPERATION = 0x0008,\n            PROCESS_VM_READ = 0x0010,\n            PROCESS_VM_WRITE = 0x0020,\n            PROCESS_DUP_HANDLE = 0x0040,\n            PROCESS_CREATE_PROCESS = 0x0080,\n            PROCESS_SET_QUOTA = 0x0100,\n            PROCESS_SET_INFORMATION = 0x0200,\n            PROCESS_QUERY_INFORMATION = 0x0400,\n            SYNCHRONIZE = 0x00100000,\n            PROCESS_ALL_ACCESS = SYNCHRONIZE | 0xF0FFF\n        }\n\n        [DllImport(\"Kernel32.dll\", SetLastError = true)]\n        public static extern IntPtr OpenProcess(DesiredAccessProcess dwDesiredAccess, bool bInheritHandle, uint dwProcessId);\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        public static extern int ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [In, Out] byte[] buffer, IntPtr size, out IntPtr lpNumberOfBytesRead);\n\n        static void Main(string[] args)\n        {\n            IntPtr m_startAddress = (IntPtr)0; // Адрес, с которого начинается сканирование\n            IntPtr m_scanLength = (IntPtr)1024; // Длина сканируемой области в байтах\n            IntPtr m_bytesRead; // Количество прочитанных байт\n            byte[] buffer = new byte[(int)m_scanLength];\n\n            Process m_process = null;\n            Process[] processes = Process.GetProcessesByName(\"notepad++\");\n            if (processes.Length == 0) throw new Exception(\"Can't find process!\");\n            m_process = processes[0];\n\n            using (m_process)\n            {\n                IntPtr m_intptrProcess = OpenProcess(DesiredAccessProcess.PROCESS_VM_READ, false, (uint)m_process.Id);\n                if (m_intptrProcess == IntPtr.Zero)\n                    throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());\n\n                for (UInt64 n = 0; n &lt; UInt64.MaxValue - (UInt64)m_scanLength; n += (UInt64)m_scanLength)\n                {\n                    m_startAddress = (IntPtr)n;\n                    Console.Write(\"Address 0x\" + n.ToString(\"X\").PadLeft(16, '0') + \": \");\n\n                    int res = ReadProcessMemory(m_intptrProcess, (IntPtr)m_startAddress, buffer, m_scanLength, out m_bytesRead);\n                    if (res == 0)\n                    {\n                        Console.WriteLine(\"ReadProcessMemory failed. Code: {0}\", Marshal.GetLastWin32Error());\n                    }\n                    else\n                    {\n                        Console.WriteLine(\"Bytes read: {0}\", m_bytesRead);\n                        for (int i = 0; i &lt; (int)m_scanLength; i++)\n                        {\n                            Console.Write(buffer[i].ToString(\"X\").PadLeft(2,'0') + \" \");\n                        }\n                        break;\n                    }\n                }\n            }\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre>\n"}