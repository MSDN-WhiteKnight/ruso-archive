---
title: "Баги при работе с клавиатурными хуками"
se.owner.user_id: 278293
se.owner.display_name: "Luser"
se.owner.link: "https://ru.stackoverflow.com/users/278293/luser"
se.link: "https://ru.stackoverflow.com/questions/1027755/%d0%91%d0%b0%d0%b3%d0%b8-%d0%bf%d1%80%d0%b8-%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%b5-%d1%81-%d0%ba%d0%bb%d0%b0%d0%b2%d0%b8%d0%b0%d1%82%d1%83%d1%80%d0%bd%d1%8b%d0%bc%d0%b8-%d1%85%d1%83%d0%ba%d0%b0%d0%bc%d0%b8"
se.question_id: 1027755
se.post_type: question
se.score: 1
---
<p>Есть участок кода где перехватываются клавиши и блокируются:</p>

<pre><code>public IntPtr LowLevelKeyboardHookProc(int nCode, IntPtr wParam, IntPtr lParam)
{
    if (nCode &gt;= 0)
    {
       var objKeyInfo = (KBDLLHOOKSTRUCT)System.Runtime.InteropServices.Marshal.PtrToStructure(lParam, typeof(KBDLLHOOKSTRUCT));
       if (objKeyInfo.key == Keys.RWin || objKeyInfo.key == Keys.LWin)
       {
          return (IntPtr)1; // &lt;WinKey&gt; 
       }
       else if (objKeyInfo.key == Keys.Alt || objKeyInfo.key == Keys.Tab)
       {
          return (IntPtr)1; // &lt;Alt&gt;+&lt;Tab&gt; 
       }
       else if (objKeyInfo.key == Keys.Alt || objKeyInfo.key == Keys.Space)
       {
          return (IntPtr)1; // &lt;Alt&gt;+&lt;Space&gt; 
       }
       else if (objKeyInfo.key == Keys.LControlKey || objKeyInfo.key == Keys.RControlKey || objKeyInfo.key == Keys.LShiftKey || objKeyInfo.key == Keys.RShiftKey || objKeyInfo.key == Keys.Escape)
       {
           return (IntPtr)1; // &lt;Control&gt;+&lt;Shift&gt;+&lt;Escape&gt; 
       }
       else if (objKeyInfo.key == Keys.LControlKey || objKeyInfo.key == Keys.Alt || objKeyInfo.key == Keys.Delete)
       {
          return (IntPtr)1; // &lt;Control&gt;+&lt;Alt&gt;+&lt;Del&gt; 
       }
    }
    return CallNextHookEx(this.m_hHook, nCode, wParam, lParam);
}
</code></pre>

<p>Почему при таком подходе не все клавиши блокируются?</p>

<p>В Данном случае не блокируется это сочетание клавиш: ( Не видит клавишу Alt )</p>

<pre><code>else if (objKeyInfo.key == Keys.LControlKey || objKeyInfo.key == Keys.Alt || objKeyInfo.key == Keys.Delete)
{
   MessageBox.Show(objKeyInfo.key.ToString()); // Проверка какая клавиша нажата
   return (IntPtr)1; // &lt;Control&gt;+&lt;Alt&gt;+&lt;Del&gt; 
}
</code></pre>

<p>Просто для каждой блокировки клавиш выделять отдельный метод с отдельными клавишами для похукивания не айс. </p>

<hr>

<p>Вызов хука - в классе <code>SetHook():</code></p>

<pre><code>public IntPtr m_hHook;
public void SetHook()
{
    m_callback = LowLevelKeyboardHookProc;
    m_hHook = SetWindowsHookEx(WH_KEYBOARD_LL, m_callback, GetModuleHandle(IntPtr.Zero), 0);
}
</code></pre>

<hr>

<p>Попробовал так же сделать связку через: vkCode </p>

<pre><code>int vkCode = Marshal.ReadInt32(lParam);
if (Keys.Control == Control.ModifierKeys || Keys.Delete == (Keys)vkCode || Keys.Alt == (Keys)vkCode)
{
   MessageBox.Show(objKeyInfo.key.ToString());
   return (IntPtr)1; // Ctrl + Alt + Delete
}
</code></pre>

<p>Просто Alt не хочет читать, подскажите почему такой баг возникает? </p>

<p>И есть ли решение данной проблемы?</p>

<p>[<strong>Новая проверка</strong>]</p>

<p>Пробую проверять так:</p>

<pre><code>if ((objKeyInfo.flags &amp; LLKHF_ALTDOWN) != 0 &amp;&amp; vkCode == (uint)Keys.Control &amp;&amp; vkCode == (uint)Keys.Delete)
{
  return (IntPtr)1;
}
// или даже так:

if (Keys.Control == Control.ModifierKeys &amp;&amp; (objKeyInfo.flags &amp; LLKHF_ALTDOWN) != 0 &amp;&amp; vkCode == (uint)Keys.Delete)
{
   return (IntPtr)1;
}
</code></pre>

<p>Но всё ровно не блокируется именно это сочетание клавиш, хочу понять почему такое случается.</p>

<p>P.S: Система Windows 10 x64</p>
