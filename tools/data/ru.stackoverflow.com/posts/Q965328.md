---
title: "Как выгрузить c# библиотеку из CLR, не завершая процесса"
se.owner.user_id: 317677
se.owner.display_name: "Egorosh"
se.owner.link: "https://ru.stackoverflow.com/users/317677/egorosh"
se.link: "https://ru.stackoverflow.com/questions/965328/%d0%9a%d0%b0%d0%ba-%d0%b2%d1%8b%d0%b3%d1%80%d1%83%d0%b7%d0%b8%d1%82%d1%8c-c-%d0%b1%d0%b8%d0%b1%d0%bb%d0%b8%d0%be%d1%82%d0%b5%d0%ba%d1%83-%d0%b8%d0%b7-clr-%d0%bd%d0%b5-%d0%b7%d0%b0%d0%b2%d0%b5%d1%80%d1%88%d0%b0%d1%8f-%d0%bf%d1%80%d0%be%d1%86%d0%b5%d1%81%d1%81%d0%b0"
se.question_id: 965328
se.post_type: question
se.score: 2
---
<p>Подскажите, пожалуйста, каким образом можно выгрузить с# библиотеку из нативного кода или как-то изнутри самой библиотеки.</p>

<p>Дело в том, что есть нативное оконное приложение на delphi. Для него мной был написан плагин на с# с вызовом функции, внутри которой стартует отдельный поток с wpf приложением и запуском окна, но внутри основного процесса. </p>

<p>В приложении на delphi dll подключается с помощью WinAPI (LoadLibrary, GetProcAddress и FreeLibrary). Так вот, при освобождении с помощью FreeLibrary плагин на самом деле не освобождается, а продолжает висеть в CLR вплоть до завершения процесса. </p>

<p>В англоязычном сегменте, нашёл ответ, что нужно выгружать AppDomain, но без примеров. Как в моём случае решить данную проблему, откуда выгружать AppDomain, каким образом?</p>

<p>Экспортируемая функция внутри C# либы выглядит следующим образом:</p>

<pre class="lang-cs prettyprint-override"><code> public static int showCyclegramm(IntPtr allWindowsClosedCallback)
        {
            if (_wpfLoaded)
                App.ShowWindow();
            else
            {
                _thread = new Thread(App.StartWpf);
                _thread.SetApartmentState(ApartmentState.STA);
                _thread.Start(allWindowsClosedCallback);
                _wpfLoaded = true;
            }

            return 0;
        }
</code></pre>

<p>StartWpf это по сути тот же main из обычного WPF приложения:</p>

<pre class="lang-cs prettyprint-override"><code>public static void StartWpf(object allWindowsClosedCallback)
        {
            var cPointer = (IntPtr) allWindowsClosedCallback;
            if (cPointer != IntPtr.Zero)
                _allClosedWindowsAction =
                    Marshal.GetDelegateForFunctionPointer&lt;Action&gt;((IntPtr) allWindowsClosedCallback);

            try
            {
                _app = new App();
            }
            catch (InvalidOperationException e)
            {
                MessageBox.Show("Последнее окно было закрыто. Перезагрузите библиотеку");
                return;
            }

            _app.InitializeComponent();
            _app.Run();
        }
</code></pre>
