{"tags":["c#","ооп","наследование"],"owner":{"reputation":2728,"user_id":212981,"user_type":"registered","accept_rate":100,"profile_image":"https://i.stack.imgur.com/wtxks.jpg?s=128&g=1","display_name":"Andrei Khotko","link":"https://ru.stackoverflow.com/users/212981/andrei-khotko"},"is_answered":true,"view_count":176,"closed_date":1558597658,"accepted_answer_id":984206,"answer_count":5,"score":7,"last_activity_date":1560505441,"creation_date":1558512699,"last_edit_date":1558521699,"question_id":984189,"link":"https://ru.stackoverflow.com/questions/984189/%d0%9a%d0%b0%d0%ba-%d0%bf%d1%80%d0%b0%d0%b2%d0%b8%d0%bb%d1%8c%d0%bd%d0%be-%d0%be%d1%80%d0%b3%d0%b0%d0%bd%d0%b8%d0%b7%d0%be%d0%b2%d0%b0%d1%82%d1%8c-%d0%be%d1%82%d0%bd%d0%be%d1%88%d0%b5%d0%bd%d0%b8%d0%b5-%d0%bc%d0%b5%d0%b6%d0%b4%d1%83-%d0%ba%d0%b2%d0%b0%d0%b4%d1%80%d0%b0%d1%82%d0%be%d0%bc-%d0%b8-%d0%bf%d1%80%d1%8f%d0%bc%d0%be%d1%83%d0%b3%d0%be%d0%bb%d1%8c%d0%bd%d0%b8%d0%ba%d0%be%d0%bc-%d1%81-%d1%82%d0%be%d1%87%d0%ba%d0%b8-%d0%b7","closed_reason":"Duplicate of…","title":"Как правильно организовать отношение между квадратом и прямоугольником с точки зрения наследования?","body":"<p>Представим, что у нас есть два класса: прямоугольник <code>Rectangle</code> и квадрат <code>Square</code>. Как между ними правильно организовать отношение с точки зрения наследования? </p>\n\n<p>С одной стороны, квадрат - это частный случай прямоугольника, поэтому квадрат будет наследником, а прямоугольник - родителем (и это логично, ведь если изображать в кругах Эйлера, то круг Квадрат будет внутри круга Прямоугольник).</p>\n\n<p>С другой стороны, с точки зрения ООП все должно быть наоборот, т.е. прямоугольник должен наследоваться от квадрата, поскольку квадрату достаточно знать длину одной стороны, в то время как прямоугольнику - две.</p>\n\n<p>Чтобы не быть голословным, приведу 2 примера на языке C#.</p>\n\n<ol>\n<li><p>Rectangle наследует Square:</p>\n\n<pre><code>public class Square\n{\n    public int SideA { get; set; }\n\n    public Square(int sideA)\n    {\n        SideA = sideA;\n    }\n\n    public virtual int Perimeter =&gt; 4 * SideA;\n}\n\npublic class Rectangle : Square\n{\n    public int SideB { get; set; }\n\n    public Rectangle(int sideA, int sideB) : base(sideA)\n    {\n        SideB = sideB;\n    }\n\n    public override int Perimeter =&gt; 2 * (SideA + SideB);\n}\n</code></pre>\n\n<p>Здесь функциональность расширяется благодаря появлению новой стороны <code>SideB</code>, однако пришлось переопределить свойство Perimeter. С точки зрения ООП, на мой взгляд, все хорошо (поправьте, если я не прав).</p></li>\n<li><p>Square наследует Rectangle:</p>\n\n<pre><code>public class Square : Rectangle\n{\n    public Square(int sideA) : base(sideA, sideA)\n    {\n    }\n}\n\npublic class Rectangle\n{\n    public int SideA { get; set; }\n    public int SideB { get; set; }        \n\n    public Rectangle(int sideA, int sideB)\n    {\n        SideA = sideA;\n        SideB = sideB;\n    }\n\n    public int Perimeter =&gt; 2 * (SideA + SideB);\n}\n</code></pre>\n\n<p>Здесь, если рассматривать класс Square, для него появилось\n\"бесполезное\" свойство SideB, которое является копией SideA. Т.е. по\nфакту, с точки зрения ООП, функциональность сузилась.</p></li>\n</ol>\n\n<p>Лично мне больше нравится второй вариант, он более лаконичный и правильный с точки зрения логики, но все же, как же правильно поступать в таком случае?</p>\n"}