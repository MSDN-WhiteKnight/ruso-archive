{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":2,"last_activity_date":1521963104,"last_edit_date":1521963104,"creation_date":1515513439,"answer_id":768514,"question_id":767999,"body":"<p><code>GetKeyboardState</code> работает только в случаях, когда сообщение о нажатии клавиши дошло до очереди вашего процесса (т.е., когда ваше окно в фокусе). Для получения состояния клавиши напрямую используется функция <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms646293(v=vs.85).aspx\" rel=\"nofollow noreferrer\">GetAsyncKeyState</a>. Она не работает для переключаемых клавиш типа Caps Lock - для них нужно использовать <code>GetKeyState</code> (или, в C# <code>Control.IsKeyLocked</code>, который ее использует).</p>\n\n<pre><code>if ((GetAsyncKeyState(VK_CONTROL) &amp; 0x8000) != 0){\n    //нажата клавиша control\n}\n</code></pre>\n\n<p>Если нужно в течение длительного времени отслеживать нажатие каких-то клавиш, лучше использовать Keyboard Hook.</p>\n\n<p>Toggled state - состояние Вкл/Выкл для клавиш типа Caps Lock. Для всех остальных клавиш его значение не определено. </p>\n\n<p>C вызовом <code>GetKeyboardLayout(0)</code> похожая проблема - он возвращает раскладку для текущего потока, которая может не соответствовать реальной системной раскладке, если окно свернуто. Надо найти поток текущего активного окна, и брать его раскладку.</p>\n\n<hr>\n\n<p>Итоговый пример кода (C#):</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Runtime.InteropServices;\n\npublic class Keyboard\n{\n    public const uint VK_CAPITAL = 0x14;\n\n    [DllImport(\"USER32.dll\")]\n    public static extern short GetKeyState(int vKey);\n\n    [DllImport(\"user32.dll\")]\n    public static extern short GetAsyncKeyState(int vKey);\n\n    [DllImport(\"user32.dll\")]\n    public static extern int ToUnicodeEx(\n        uint wVirtKey,\n        uint wScanCode,\n        byte[] lpKeyState,\n        [Out, MarshalAs(UnmanagedType.LPWStr)] StringBuilder pwszBuff,\n        int cchBuff,\n        uint wFlags,\n        IntPtr dwhkl);\n\n    [DllImport(\"user32.dll\")]\n    public static extern bool GetKeyboardState(byte[] lpKeyState);\n\n    [DllImport(\"user32.dll\")]\n    public static extern uint MapVirtualKey(\n        uint uCode,\n        uint uMapType);\n\n    [DllImport(\"user32.dll\")]\n    public static extern IntPtr GetKeyboardLayout(uint idThread);\n\n    [DllImport(\"user32.dll\")]\n    public static extern uint GetWindowThreadProcessId(IntPtr hWnd, IntPtr ProcessId);\n\n    [DllImport(\"user32.dll\")]\n    public static extern IntPtr GetForegroundWindow();\n\n    public static string VKCodeToUnicode(uint vkCode)\n    {\n        StringBuilder buf = new StringBuilder();\n\n        byte[] keyboardState = new byte[255];            \n\n        short x;\n        byte y;            \n\n        for (int i = 0; i &lt; 255; i++)\n        {                \n            if (i == VK_CAPITAL)\n            {\n                x = GetKeyState(i);                                          \n            }\n            else\n            {\n                x = GetAsyncKeyState(i);                    \n            }\n            y = 0;\n            if ((x &amp; 0x8000) != 0) y = (byte)(y | 0x80);\n            if ((x &amp; 0x0001) != 0) y = (byte)(y | 0x01);\n            keyboardState[i] = y;\n        }\n\n        ToUnicodeEx(vkCode, MapVirtualKey(vkCode, 0), keyboardState, buf, 5, 0, \n            GetKeyboardLayout(GetWindowThreadProcessId(GetForegroundWindow(), IntPtr.Zero)));\n        return buf.ToString();\n    }\n\n}\n</code></pre>\n"}