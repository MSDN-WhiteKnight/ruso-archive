{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":2,"last_activity_date":1529835452,"creation_date":1529835452,"answer_id":846042,"question_id":845750,"body":"<p>Для HTTP-пакетов - парсить GET-запрос и искать параметр Host. Но его может и не быть, тогда сайт можно получить запросом к обратному DNS (если он там есть). Для HTTPS получить запросы без расшифровки трафика, понятное дело, нельзя, но можно попробовать найти SSL Handshake и посмотреть, к какому домену идет запрос. </p>\n\n<p>Пример захвата HTTP и SSL/TLS трафика на первом найденном IPv4-интерфейсе, с использованием Raw Socket (для запуска требуются права администратора):</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Text;\nusing System.Diagnostics;\nusing System.Threading;\nusing System.IO;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Net.NetworkInformation;\n\nnamespace ConsoleTest1\n{    \n    class Program\n    {\n        //Получает все локальные IP-адреса\n        public static List&lt;IPAddress&gt; GetIpAddresses()\n        {\n            List&lt;IPAddress&gt; res = new List&lt;IPAddress&gt;(10);\n\n            var ifs = NetworkInterface.GetAllNetworkInterfaces();\n\n            foreach (var interf in ifs)\n            {               \n\n                var ipprop = interf.GetIPProperties();\n                if (ipprop == null) continue;\n                var unicast = ipprop.UnicastAddresses;\n                if (unicast == null) continue;\n\n                //находим первый Unicast-адрес\n                foreach (var addr in unicast)\n                {\n                    if (addr.Address.AddressFamily != AddressFamily.InterNetwork) continue;\n                    res.Add(addr.Address);\n                    break;\n                }\n\n            }\n\n            return res;\n        }\n\n        const byte PROTO_TCP = 6;\n        const byte SSL_HANDSHAKE = 0x16;\n\n        public class ParseResult\n        {\n            public string TrafficType {get;set;}\n            public string Host { get; set; }            \n        }\n\n        public static ParseResult ParseIpPacket(byte[] data, IPAddress src_ip)\n        {\n            ushort dummy;\n            byte b;\n\n            MemoryStream ms = new MemoryStream(data);\n            BinaryReader br = new BinaryReader(ms);\n            uint header_len;\n            uint total_len;\n            IPAddress src,dst;\n            string host=\"\";\n            ParseResult result;\n\n            //parse IP packet header\n            using (ms)\n            using (br)\n            {\n                b = br.ReadByte();\n                byte ver = (byte)((b &amp; (byte)0xF0) &gt;&gt; 4); //IP version\n                if (ver != 4)\n                {\n                    Console.WriteLine(\"Unsupported IP version: {0}\", ver);\n                    return null;\n                }                \n\n                byte ihl = (byte)(b &amp; (byte)0x0F);//header length\n                header_len = ihl * 4u;\n\n                b = br.ReadByte();\n\n                //packet length\n                byte[] temp = new byte[2];\n                temp[1] = br.ReadByte();\n                temp[0] = br.ReadByte();\n                total_len = BitConverter.ToUInt16(temp, 0);\n\n                dummy = br.ReadUInt16();\n                dummy = br.ReadUInt16();\n\n                byte ttl = br.ReadByte();\n                byte proto = br.ReadByte();\n\n                dummy = br.ReadUInt16();\n\n                //source IP\n                temp = new byte[4];\n                temp[0] = br.ReadByte();\n                temp[1] = br.ReadByte();\n                temp[2] = br.ReadByte();\n                temp[3] = br.ReadByte();\n                src = new IPAddress(temp);                \n\n                //destination IP\n                temp[0] = br.ReadByte();\n                temp[1] = br.ReadByte();\n                temp[2] = br.ReadByte();\n                temp[3] = br.ReadByte();\n                dst = new IPAddress(temp);                \n\n                if (proto != PROTO_TCP) return null;  \n            }\n\n            //Parse TCP packet\n            uint tcp_size = total_len - header_len;\n            byte[] tcp_data = new byte[tcp_size];\n            Array.Copy(data, header_len, tcp_data, 0, tcp_size);\n\n            ms = new MemoryStream(tcp_data);\n            br = new BinaryReader(ms);\n            byte tcp_header_size;\n            uint http_size;\n\n            using (ms)\n            using (br)\n            {\n                var src_port = br.ReadUInt16();\n                var dst_port = br.ReadUInt16();                \n                br.ReadUInt32();\n                br.ReadUInt32();\n                tcp_header_size = (byte)(br.ReadByte() &gt;&gt; 4);\n                tcp_header_size *= 4;\n                http_size = tcp_size - tcp_header_size;\n            }\n\n            byte[] http_data = new byte[http_size];\n            Array.Copy(tcp_data, tcp_header_size, http_data, 0, http_size);\n\n            //parse SSL record\n            if (http_data.Length &gt;= 5 &amp;&amp; src.Equals(src_ip))\n            {\n                ms = new MemoryStream(http_data);\n                br = new BinaryReader(ms);\n                using (ms)\n                using (br)\n                {                    \n                    byte record_type = br.ReadByte();\n                    byte b1 = br.ReadByte();\n                    byte b2 = br.ReadByte();\n                    byte[] bytes = new byte[]{b2,b1};\n                    ushort ssl_ver = BitConverter.ToUInt16(bytes,0);                    \n                    ushort ssl_len = br.ReadUInt16();\n\n                    if ( ((ssl_ver &gt;= 0x0300 &amp;&amp; ssl_ver &lt;= 0x0304) || ssl_ver == 0x0002)\n                        &amp;&amp; (record_type == SSL_HANDSHAKE))\n                    {                        \n                        //пытаемся получить имя узла из обратного DNS\n                        try\n                        {\n                            host = Dns.GetHostEntry(dst).HostName;\n                        }\n                        catch (SocketException)\n                        {\n                            host = \"\";\n                        }\n\n                        result = new ParseResult();\n                        result.TrafficType = \"SSL / TLS\";\n                        if (host != \"\") result.Host = host;                        \n                        else result.Host = dst.ToString();                        \n                        return result;\n                    }\n                }\n            }\n\n            //Parse HTTP data\n            string res = Encoding.UTF8.GetString(http_data);\n            string[] arr = res.Split(\"\\n\\r\".ToCharArray(),StringSplitOptions.RemoveEmptyEntries);\n\n            if (arr.Length &gt; 2 &amp;&amp; arr[0].StartsWith(\"GET\") &amp;&amp; arr[0].Contains(\"HTTP/\"))\n            {                \n                //найдем поле Host\n                for(int i=1;i&lt;arr.Length;i++)\n                {\n                    if (arr[i].StartsWith(\"Host: \"))\n                    {\n                        host = arr[i].Replace(\"Host: \", \"\");                        \n                        break;\n                    }\n                }\n\n                if (host == \"\")\n                {\n                    //пытаемся получить имя узла из обратного DNS\n                    try\n                    {\n                        host = Dns.GetHostEntry(dst).HostName;\n                    }\n                    catch (SocketException)\n                    {\n                        host = \"\";\n                    }\n                }\n\n                result = new ParseResult();\n                result.TrafficType = \"HTTP\";\n                result.Host = host;                \n                return result;\n            }\n            return null;\n        }\n\n        static void Main(string[] args)\n        {\n            var mainSocket = new Socket(AddressFamily.InterNetwork, SocketType.Raw,\n                       ProtocolType.IP);\n\n            var ips = GetIpAddresses();\n            IPAddress ipaddr=new IPAddress(0L);\n            foreach (var ip in ips)\n            {\n                if (ip.GetAddressBytes()[0] != 127)\n                {\n                    Console.WriteLine(\"Interface IP: {0}\",ip);\n                    ipaddr = ip;\n                    break;\n                }\n            }\n\n            mainSocket.Bind(new IPEndPoint(ipaddr, 0));\n\n\n            mainSocket.SetSocketOption(SocketOptionLevel.IP,  //Applies only to IP packets\n                           SocketOptionName.HeaderIncluded, //Set the include header\n                           true);                           //option to true\n\n            byte[] byTrue = new byte[4] { 1, 0, 0, 0 };\n            byte[] byOut = new byte[4];\n\n            //Socket.IOControl is analogous to the WSAIoctl method of Winsock 2\n            mainSocket.IOControl(IOControlCode.ReceiveAll,  //SIO_RCVALL of Winsock\n                     byTrue, byOut);\n\n            byte[] buffer = new byte[1024*20];\n            int res;\n\n            while (true)\n            {\n                try\n                {\n                    res = mainSocket.Receive(buffer);                    \n\n                    ParseResult result = ParseIpPacket(buffer, ipaddr);\n                    if (result != null)\n                    {\n                        Console.WriteLine(\"[{0}] {1}\",result.TrafficType,result.Host);\n                    }                    \n                }\n                catch (Exception ex)\n                {\n                    Console.WriteLine(ex.ToString());\n                }\n            }           \n\n        }\n    }\n}\n</code></pre>\n\n<p>Источники:</p>\n\n<p><a href=\"https://www.codeproject.com/Articles/17031/A-Network-Sniffer-in-C\" rel=\"nofollow noreferrer\">CodeProject - A Network Sniffer in C#</a></p>\n\n<p><a href=\"https://ru.wikipedia.org/wiki/IPv4\" rel=\"nofollow noreferrer\">Википедия - Протокол IPv4</a></p>\n\n<p><a href=\"https://ru.wikipedia.org/wiki/Transmission_Control_Protocol\" rel=\"nofollow noreferrer\">Википедия - Протокол TCP</a></p>\n\n<p><a href=\"https://www.cisco.com/c/en/us/support/docs/security-vpn/secure-socket-layer-ssl/116181-technote-product-00.html#anc2\" rel=\"nofollow noreferrer\">Cisco - SSL Introduction with Sample Transaction and Packet Exchange</a></p>\n"}