---
title: "Answer 1004337"
se.owner.user_id: 344699
se.owner.display_name: "Сергей Синельников"
se.owner.link: "https://ru.stackoverflow.com/users/344699/%d0%a1%d0%b5%d1%80%d0%b3%d0%b5%d0%b9-%d0%a1%d0%b8%d0%bd%d0%b5%d0%bb%d1%8c%d0%bd%d0%b8%d0%ba%d0%be%d0%b2"
se.answer_id: 1004337
se.question_id: 1004275
se.post_type: answer
se.score: 1
se.is_accepted: False
---
<p>Вот так как-то</p>

<pre><code>interface ICommonData
{
    int Id { get; set; }
    string Name { get; set; }
}
struct DataA : ICommonData
{
    string DataA1 { get; set; }
    public int Id { get; set; }
    public string Name { get; set; }
}
</code></pre>

<p>и т.д....затем</p>

<pre><code>     private Dictionary&lt;byte, Type&gt; types;
     private List&lt;ICommonData&gt; data = new List&lt;ICommonData&gt;();

        types = new Dictionary&lt;byte, Type&gt;();
        types[1] = typeof(DataA);
        types[2] = typeof(DataB);
        types[3] = typeof(DataC);
        types[4] = typeof(DataD);
        types[5] = typeof(DataE);
</code></pre>

<p>и уже далее</p>

<pre><code>        for (byte i = 0; i &lt; byte.MaxValue; i++)
        {
            if (types.ContainsKey(i))
            {
                data.Add((ICommonData)Activator.CreateInstance(types[i]));
            }
        }
</code></pre>
