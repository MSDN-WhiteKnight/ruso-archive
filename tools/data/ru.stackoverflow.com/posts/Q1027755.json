{"tags":["c#","winforms","hook","keyboardhook"],"owner":{"reputation":497,"user_id":278293,"user_type":"registered","accept_rate":78,"profile_image":"https://i.stack.imgur.com/rJv3r.jpg?s=128&g=1","display_name":"Luser","link":"https://ru.stackoverflow.com/users/278293/luser"},"is_answered":true,"view_count":82,"accepted_answer_id":1028145,"answer_count":1,"score":1,"last_activity_date":1569502901,"creation_date":1569368534,"last_edit_date":1569502901,"question_id":1027755,"link":"https://ru.stackoverflow.com/questions/1027755/%d0%91%d0%b0%d0%b3%d0%b8-%d0%bf%d1%80%d0%b8-%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%b5-%d1%81-%d0%ba%d0%bb%d0%b0%d0%b2%d0%b8%d0%b0%d1%82%d1%83%d1%80%d0%bd%d1%8b%d0%bc%d0%b8-%d1%85%d1%83%d0%ba%d0%b0%d0%bc%d0%b8","title":"Баги при работе с клавиатурными хуками","body":"<p>Есть участок кода где перехватываются клавиши и блокируются:</p>\n\n<pre><code>public IntPtr LowLevelKeyboardHookProc(int nCode, IntPtr wParam, IntPtr lParam)\n{\n    if (nCode &gt;= 0)\n    {\n       var objKeyInfo = (KBDLLHOOKSTRUCT)System.Runtime.InteropServices.Marshal.PtrToStructure(lParam, typeof(KBDLLHOOKSTRUCT));\n       if (objKeyInfo.key == Keys.RWin || objKeyInfo.key == Keys.LWin)\n       {\n          return (IntPtr)1; // &lt;WinKey&gt; \n       }\n       else if (objKeyInfo.key == Keys.Alt || objKeyInfo.key == Keys.Tab)\n       {\n          return (IntPtr)1; // &lt;Alt&gt;+&lt;Tab&gt; \n       }\n       else if (objKeyInfo.key == Keys.Alt || objKeyInfo.key == Keys.Space)\n       {\n          return (IntPtr)1; // &lt;Alt&gt;+&lt;Space&gt; \n       }\n       else if (objKeyInfo.key == Keys.LControlKey || objKeyInfo.key == Keys.RControlKey || objKeyInfo.key == Keys.LShiftKey || objKeyInfo.key == Keys.RShiftKey || objKeyInfo.key == Keys.Escape)\n       {\n           return (IntPtr)1; // &lt;Control&gt;+&lt;Shift&gt;+&lt;Escape&gt; \n       }\n       else if (objKeyInfo.key == Keys.LControlKey || objKeyInfo.key == Keys.Alt || objKeyInfo.key == Keys.Delete)\n       {\n          return (IntPtr)1; // &lt;Control&gt;+&lt;Alt&gt;+&lt;Del&gt; \n       }\n    }\n    return CallNextHookEx(this.m_hHook, nCode, wParam, lParam);\n}\n</code></pre>\n\n<p>Почему при таком подходе не все клавиши блокируются?</p>\n\n<p>В Данном случае не блокируется это сочетание клавиш: ( Не видит клавишу Alt )</p>\n\n<pre><code>else if (objKeyInfo.key == Keys.LControlKey || objKeyInfo.key == Keys.Alt || objKeyInfo.key == Keys.Delete)\n{\n   MessageBox.Show(objKeyInfo.key.ToString()); // Проверка какая клавиша нажата\n   return (IntPtr)1; // &lt;Control&gt;+&lt;Alt&gt;+&lt;Del&gt; \n}\n</code></pre>\n\n<p>Просто для каждой блокировки клавиш выделять отдельный метод с отдельными клавишами для похукивания не айс. </p>\n\n<hr>\n\n<p>Вызов хука - в классе <code>SetHook():</code></p>\n\n<pre><code>public IntPtr m_hHook;\npublic void SetHook()\n{\n    m_callback = LowLevelKeyboardHookProc;\n    m_hHook = SetWindowsHookEx(WH_KEYBOARD_LL, m_callback, GetModuleHandle(IntPtr.Zero), 0);\n}\n</code></pre>\n\n<hr>\n\n<p>Попробовал так же сделать связку через: vkCode </p>\n\n<pre><code>int vkCode = Marshal.ReadInt32(lParam);\nif (Keys.Control == Control.ModifierKeys || Keys.Delete == (Keys)vkCode || Keys.Alt == (Keys)vkCode)\n{\n   MessageBox.Show(objKeyInfo.key.ToString());\n   return (IntPtr)1; // Ctrl + Alt + Delete\n}\n</code></pre>\n\n<p>Просто Alt не хочет читать, подскажите почему такой баг возникает? </p>\n\n<p>И есть ли решение данной проблемы?</p>\n\n<p>[<strong>Новая проверка</strong>]</p>\n\n<p>Пробую проверять так:</p>\n\n<pre><code>if ((objKeyInfo.flags &amp; LLKHF_ALTDOWN) != 0 &amp;&amp; vkCode == (uint)Keys.Control &amp;&amp; vkCode == (uint)Keys.Delete)\n{\n  return (IntPtr)1;\n}\n// или даже так:\n\nif (Keys.Control == Control.ModifierKeys &amp;&amp; (objKeyInfo.flags &amp; LLKHF_ALTDOWN) != 0 &amp;&amp; vkCode == (uint)Keys.Delete)\n{\n   return (IntPtr)1;\n}\n</code></pre>\n\n<p>Но всё ровно не блокируется именно это сочетание клавиш, хочу понять почему такое случается.</p>\n\n<p>P.S: Система Windows 10 x64</p>\n"}