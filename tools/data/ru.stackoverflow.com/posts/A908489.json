{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1563360679,"last_edit_date":1563360679,"creation_date":1542615740,"answer_id":908489,"question_id":490470,"body":"<p>Функция в С/С++ не обязана быть непрерывной последовательностью инструкций машинного кода с четко выраженным началом и концом. Если несколько функций содержат одинаковый завершающий блок кода (\"эпилог\"), оптимизирующий компилятор может включить его в бинарник только в одной функции, а в других заменить его на инструкцию перехода в первую. В таком случае понятие \"размер функции\" становится неоднозначным. Кроме того, попытка перенести машинный код из одного процесса в другой \"как есть\" скорее всего закончится неудачей, ведь инструкции часто оперируют относительными адресами. Более правильным решением было бы реализовать инжектируемый блок кода полностью в виде ассемблерной вставки, как например <a href=\"https://ru.stackoverflow.com/a/751021/240512\">здесь</a>.</p>\n\n<p>Тем не менее, API для получения размера функции (как справочной информации) существуют. Например, так это можно сделать в Windows с помощью dbghelp:</p>\n\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;windows.h&gt;\n#include \"DbgHelp.h\"\n#pragma comment(lib, \"Dbghelp.lib\")\n\nstruct Function {\n    const char* name;\n    unsigned int size;\n    bool success;\n};\n\nBOOL CALLBACK EnumSymProc(PSYMBOL_INFO pSymInfo, ULONG SymbolSize, PVOID context) {\n\n    Function* pfstruct = (Function*)context;    \n\n    if (strcmp(pSymInfo-&gt;Name, pfstruct-&gt;name) == 0) {\n\n        pfstruct-&gt;size = SymbolSize;\n        pfstruct-&gt;success = true;       \n        return FALSE; //закончить поиск\n\n    }\n    return TRUE; //продолжить поиск\n}\n\n// Находит размер функции fname и помещает в переменную resultvar\n// Требует наличия отладочных символов (PDB-файла) в каталоге с программой\nbool GetFunctionSize(const char* fname, unsigned int&amp; resultvar) {\n\n    bool ret;\n    Function fstruct;\n    fstruct.name = fname;\n    fstruct.size = 0;\n    fstruct.success = false;\n\n    HANDLE hProcess = GetCurrentProcess(); //текущий процесс\n    char Mask[] = \"*!\"; //искать среди всех модулей\n    BOOL status;\n\n    status = SymInitialize(hProcess, NULL, TRUE); //загрузка символов\n    if (status == FALSE)\n    {\n        printf(\"SymInitialize failed. Error code: %d\\n\", GetLastError());\n        return false;\n    }\n\n    //поиск символов\n    if (SymEnumSymbols(hProcess, 0, Mask, &amp;EnumSymProc, (void*)&amp;fstruct))\n    {\n        if (fstruct.success != false) {\n\n            resultvar = fstruct.size; //возвращаем размер\n            ret = true; \n        }\n        else {\n            printf(\"Symbol [%s] not found\\n\", fname);\n            ret = false; \n        }\n    }\n    else\n    {\n        printf(\"SymEnumSymbols failed. Error code: %d\\n\", GetLastError());\n        ret = false;\n    }\n\n    SymCleanup(hProcess);\n    return ret;\n}\n\n//**********************************\n\nvoid Func() {\n    printf(\"Hello, World!\\n\"); \n}\n\nint main(int argc, char **argv)\n{\n    uintptr_t p = (uintptr_t)&amp;Func;\n    printf(\"Func address: 0x%x\\n\", (UINT)p);    \n\n    unsigned int size = 0;\n    if (GetFunctionSize(\"Func\", size) != false) {\n        printf(\"Func size: %u bytes\", size);\n    }\n\n    getchar();\n    return 0;\n}\n</code></pre>\n\n<p>При использовании Visual Studio 2017+ для корректной работы данного кода необходимо собирать проект с параметром <code>/DEBUG:FULL</code> (см. <a href=\"https://docs.microsoft.com/en-us/cpp/build/reference/debug-generate-debug-info?view=vs-2019\" rel=\"nofollow noreferrer\">/DEBUG</a>).</p>\n"}