---
title: "Answer 832133"
se.owner.user_id: 193306
se.owner.display_name: "Sergej Loos"
se.owner.link: "https://ru.stackoverflow.com/users/193306/sergej-loos"
se.answer_id: 832133
se.question_id: 831776
se.post_type: answer
se.score: 1
se.is_accepted: True
---
<p>Натолкнулся на одно решение и оно у меня на Windows 10 с небольшими изменениями работает:
<a href="https://stackoverflow.com/questions/6319568/how-to-bring-a-form-already-shown-up-to-the-very-foreground-and-focus-it/22737820#22737820">https://stackoverflow.com/questions/6319568/how-to-bring-a-form-already-shown-up-to-the-very-foreground-and-focus-it/22737820#22737820</a></p>

<pre><code>    [DllImport("user32.dll")]
    private static extern IntPtr GetForegroundWindow();

    [DllImport("user32.dll")]
    private static extern uint GetWindowThreadProcessId(IntPtr hWnd, IntPtr ProcessId);

    [DllImport("user32.dll")]
    private static extern bool AttachThreadInput(uint idAttach, uint idAttachTo, bool fAttach);

    public static void xActivateAndBringToFront(this Form form) {

        // activate window
        var currentForegroundWindow = GetForegroundWindow();
        var thisWindowThreadId = GetWindowThreadProcessId(form.Handle, IntPtr.Zero);
        var currentForegroundWindowThreadId = GetWindowThreadProcessId(currentForegroundWindow, IntPtr.Zero);
        AttachThreadInput(currentForegroundWindowThreadId, thisWindowThreadId, true);
        form.Activate(); // or: SetForegroundWindow(form.Handle); 
        AttachThreadInput(currentForegroundWindowThreadId, thisWindowThreadId, false);

        // set window to front
        form.TopMost = true;
        form.TopMost = false;
    }
</code></pre>

<hr>

<p>Дополнение после подсказок от MSDN.WhiteKnight.</p>

<p>MSDN.WhiteKnight указал на то, что применение метода AttachThreadInput может вызывать в некоторых случаях проблемы. Краткий поиск в интернете подтверждает это. </p>

<p>Поэтому, с его же подсказки, я попробовал применить метод AllowSetForegroundWindow. С успехом! А именно, приложение при первом запуске сохраняет ID своего процесса в реестре:</p>

<pre><code>Application.UserAppDataRegistry.SetValue(CORE_PROCESS_ID, Process.GetCurrentProcess().Id);
</code></pre>

<p>Затем, при повторном запуске приложение перед посылкой сообщения ядру вызывает метод AllowSetForegroundWindow:</p>

<pre><code>int processID = (int)Application.UserAppDataRegistry.GetValue(CORE_PROCESS_ID);
bool b =  AllowSetForegroundWindow(processID);
// .. сообщение ядру ..
// .. выход ..
</code></pre>

<p>Ядро создает и отображает окно, окно получает фокус ввода как положено. Не нужно даже как-то принудительно подымать окно. По сути form.Activate() достаточно, но даже этот вызов не нужен, если окно создается и отображается в регламентированном порядке через Show(), ShowDialog() или Application.Run(form).</p>
