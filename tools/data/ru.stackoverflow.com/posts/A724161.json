{"owner":{"reputation":15055,"user_id":178556,"user_type":"registered","profile_image":"https://i.stack.imgur.com/lxzbH.png?s=128&g=1","display_name":"default locale","link":"https://ru.stackoverflow.com/users/178556/default-locale"},"is_accepted":false,"score":6,"last_activity_date":1506583279,"last_edit_date":1506583279,"creation_date":1506582834,"answer_id":724161,"question_id":722795,"body":"<p>Как вариант, средствами Win32 можно объединить приложение и запущенные из него процессы в задание (<a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms684161(v=vs.85).aspx\" rel=\"noreferrer\">Job</a>) тогда процессы Interop будут завершаться вместе с родительским приложением.</p>\n\n<p>Для этого нужно будет создать задание с помощью <a href=\"https://msdn.microsoft.com/en-us/library/ms682409(VS.85).aspx\" rel=\"noreferrer\"><code>CreateJobObject</code></a>, а затем добавлять созданные процессы в задание с помощью <a href=\"https://msdn.microsoft.com/en-us/library/ms681949(v=vs.85).aspx\" rel=\"noreferrer\"><code>AssignProcessToJobObject</code></a></p>\n\n<p>Есть похожее обсуждение на английском языке: «<a href=\"https://stackoverflow.com/questions/3342941/kill-child-process-when-parent-process-is-killed\">Kill child process when parent process is killed</a>». Из <a href=\"https://stackoverflow.com/questions/3342941/kill-child-process-when-parent-process-is-killed#37034966\">ответа @Ron</a> можно взять код класса-обертки <code>ChildProcessTracker</code>:</p>\n\n<pre><code>/// &lt;summary&gt;\n/// Allows processes to be automatically killed if this parent process unexpectedly quits.\n/// This feature requires Windows 8 or greater. On Windows 7, nothing is done.&lt;/summary&gt;\n/// &lt;remarks&gt;References:\n///  https://stackoverflow.com/a/4657392/386091\n///  https://stackoverflow.com/a/9164742/386091 &lt;/remarks&gt;\npublic static class ChildProcessTracker\n{\n    /// &lt;summary&gt;\n    /// Add the process to be tracked. If our current process is killed, the child processes\n    /// that we are tracking will be automatically killed, too. If the child process terminates\n    /// first, that's fine, too.&lt;/summary&gt;\n    /// &lt;param name=\"processHandle\"&gt;&lt;/param&gt;\n    public static void AddProcess(int processHandle)\n    {\n        if (s_jobHandle != IntPtr.Zero)\n        {\n            bool success = AssignProcessToJobObject(s_jobHandle, new IntPtr(processHandle));\n            if (!success)\n                throw new Win32Exception();\n        }\n    }\n\n    static ChildProcessTracker()\n    {\n        // This feature requires Windows 8 or later. To support Windows 7 requires\n        //  registry settings to be added if you are using Visual Studio plus an\n        //  app.manifest change.\n        //  https://stackoverflow.com/a/4232259/386091\n        //  https://stackoverflow.com/a/9507862/386091\n        if (Environment.OSVersion.Version &lt; new Version(6, 2))\n            return;\n\n        // The job name is optional (and can be null) but it helps with diagnostics.\n        //  If it's not null, it has to be unique. Use SysInternals' Handle command-line\n        //  utility: handle -a ChildProcessTracker\n        string jobName = \"ChildProcessTracker\" + Process.GetCurrentProcess().Id;\n        s_jobHandle = CreateJobObject(IntPtr.Zero, jobName);\n\n        var info = new JOBOBJECT_BASIC_LIMIT_INFORMATION\n        {\n            LimitFlags = JOBOBJECTLIMIT.JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE\n        };\n\n        // This is the key flag. When our process is killed, Windows will automatically\n        //  close the job handle, and when that happens, we want the child processes to\n        //  be killed, too.\n\n        var extendedInfo = new JOBOBJECT_EXTENDED_LIMIT_INFORMATION();\n        extendedInfo.BasicLimitInformation = info;\n\n        int length = Marshal.SizeOf(typeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION));\n        IntPtr extendedInfoPtr = Marshal.AllocHGlobal(length);\n        try\n        {\n            Marshal.StructureToPtr(extendedInfo, extendedInfoPtr, false);\n\n            if (!SetInformationJobObject(s_jobHandle, JobObjectInfoType.ExtendedLimitInformation,\n                extendedInfoPtr, (uint)length))\n            {\n                throw new Win32Exception();\n            }\n        }\n        finally\n        {\n            Marshal.FreeHGlobal(extendedInfoPtr);\n        }\n    }\n\n    [DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode)]\n    static extern IntPtr CreateJobObject(IntPtr lpJobAttributes, string name);\n\n    [DllImport(\"kernel32.dll\")]\n    static extern bool SetInformationJobObject(IntPtr job, JobObjectInfoType infoType,\n        IntPtr lpJobObjectInfo, uint cbJobObjectInfoLength);\n\n    [DllImport(\"kernel32.dll\", SetLastError = true)]\n    static extern bool AssignProcessToJobObject(IntPtr job, IntPtr process);\n\n    // Windows will automatically close any open job handles when our process terminates.\n    //  This can be verified by using SysInternals' Handle utility. When the job handle\n    //  is closed, the child processes will be killed.\n    private static readonly IntPtr s_jobHandle;\n}\n\npublic enum JobObjectInfoType\n{\n    AssociateCompletionPortInformation = 7,\n    BasicLimitInformation = 2,\n    BasicUIRestrictions = 4,\n    EndOfJobTimeInformation = 6,\n    ExtendedLimitInformation = 9,\n    SecurityLimitInformation = 5,\n    GroupInformation = 11\n}\n\n[StructLayout(LayoutKind.Sequential)]\npublic struct JOBOBJECT_BASIC_LIMIT_INFORMATION\n{\n    public Int64 PerProcessUserTimeLimit;\n    public Int64 PerJobUserTimeLimit;\n    public JOBOBJECTLIMIT LimitFlags;\n    public UIntPtr MinimumWorkingSetSize;\n    public UIntPtr MaximumWorkingSetSize;\n    public UInt32 ActiveProcessLimit;\n    public Int64 Affinity;\n    public UInt32 PriorityClass;\n    public UInt32 SchedulingClass;\n}\n\n[Flags]\npublic enum JOBOBJECTLIMIT : uint\n{\n    JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE = 0x2000\n}\n\n[StructLayout(LayoutKind.Sequential)]\npublic struct IO_COUNTERS\n{\n    public UInt64 ReadOperationCount;\n    public UInt64 WriteOperationCount;\n    public UInt64 OtherOperationCount;\n    public UInt64 ReadTransferCount;\n    public UInt64 WriteTransferCount;\n    public UInt64 OtherTransferCount;\n}\n\n[StructLayout(LayoutKind.Sequential)]\npublic struct JOBOBJECT_EXTENDED_LIMIT_INFORMATION\n{\n    public JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;\n    public IO_COUNTERS IoInfo;\n    public UIntPtr ProcessMemoryLimit;\n    public UIntPtr JobMemoryLimit;\n    public UIntPtr PeakProcessMemoryUsed;\n    public UIntPtr PeakJobMemoryUsed;\n}\n</code></pre>\n\n<p>, и регистрировать с помощью него процессы Excel как дочерние:</p>\n\n<pre><code>[DllImport(\"user32.dll\")]\nstatic extern int GetWindowThreadProcessId(int hWnd, out int lpdwProcessId);\n\nvar app = new Microsoft.Office.Interop.Excel.Application();\nint processId;\nGetWindowThreadProcessId(app.Hwnd, out processId);\nChildProcessTracker.AddProcess(processId); \n</code></pre>\n\n<p>, и тогда ОС будет убивать их вместе с родительским процессом.</p>\n\n<p>Рекоммендую ознакомиться с документацией и почитать комментарии в обсуждении по ссылке, могут возникнуть нюансы с поддержкой разных версий ОС и Visual Studio, при запуске с ограниченными правами, при запуске родительского приложения из других процессов.</p>\n\n<blockquote>\n  <p>Если нет, то можно ли понять при запуске(повторном) приложения, что в процессах висит мусор, который остался от прошлого запуска и грохнуть эти процессы, не затронув реальные приложения офиса(например, юзер запустил Excel.)</p>\n</blockquote>\n\n<p>Сомневаюсь в существовании надежного метода. Процесс Excel запущенный старым процессом ничем не отличается от процесса запущенного текущим/другими приложениями/пользователем. Можно, как предложил @VadimTagil,  написать код, который будет сохранять запущенные процессы в постоянное хранилище (диск/БД/реестр) и убивать их по определенной логике. Еще один вариант, вынести формирование Excel в отдельные процессы-задания, не зависящие от основного приложения. </p>\n\n<p>Вообще, если в нормальном ходе работы приложения мусор не остается, то проблемы будут возникать лишь в исключительных случаях (убитый извне процесс), обработку которых можно будет оставить пользователю. Убедитесь, что для всех объектов вызывается <a href=\"https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.marshal.releasecomobject(v=vs.110).aspx\" rel=\"noreferrer\"><code>Marshal.ReleaseComObject</code></a> и что все процессы завершаются и, возможно, без задания можно будет обойтись.</p>\n"}