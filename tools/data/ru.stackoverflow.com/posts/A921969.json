{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":4,"last_activity_date":1578565842,"last_edit_date":1578565842,"creation_date":1545039085,"answer_id":921969,"question_id":921801,"body":"<p>COM Interop работает в <a href=\"http://joelleach.net/2018/06/06/com-interop-with-net-core-2-0/\" rel=\"nofollow noreferrer\">.NET Core 2.0+</a>. В диалоге добавления ссылки для проектов .NET Core в Visual Studio нет вкладки COM, но можно нажать \"Обзор\" и указать tlb/dll файл вручную, для него будет корректно сформирована Interop-сборка. Однако, в .NET Core (до версии 3.0) не реализовано позднее связывание (IDispatch), поэтому большая часть функционала Office Automation действительно будет трудно использовать.</p>\n\n<p><strong>Обновление:</strong> В .NET Core 3.0+ была добавлена поддержка маршаллинга IDispatch (пример можно найти здесь: <a href=\"https://github.com/dotnet/samples/tree/master/core/extensions/ExcelDemo\" rel=\"nofollow noreferrer\">https://github.com/dotnet/samples/tree/master/core/extensions/ExcelDemo</a>). Код ниже уже не актуален. </p>\n\n<hr>\n\n<p>Применительно к Excel, к примеру, вот такой код работает:</p>\n\n<pre><code>Application app = new Application();\napp.Visible = true;\n\nvar books = app.Workbooks;\nvar book = books.Add();\nWorksheet sheet = book.ActiveSheet;\nConsole.WriteLine(sheet.Name);\nsheet.Name = \"Hello from .NET Core\";\n</code></pre>\n\n<p>А вот такой - уже нет:</p>\n\n<pre><code>sheet.Cells[1,1] = \"Hello from .NET Core\"; //ноль эффекта\n</code></pre>\n\n<p>Чтобы задействовать интерфейс Range, использующий позднее связывание, понадобится куда более сложный код:</p>\n\n<pre><code>using System;\nusing System.Runtime.InteropServices;\nusing ComTypes = System.Runtime.InteropServices.ComTypes;\nusing Microsoft.Office.Interop.Excel;\n\nnamespace NetCoreTest\n{ \n    class Program\n    {        \n        static void Main(string[] args)\n        {            \n\n            Application app = new Application();\n            app.Visible = true;\n\n            var books = app.Workbooks;\n            var book = books.Add();\n            _Worksheet sheet = book.ActiveSheet;\n\n            Range r = sheet.get_Range(\"A1\");\n            SetProperty(r, \"Value\", \"Hello from .NET Core\");    \n\n            Console.ReadKey();\n        }\n\n        //Устанавливает свойство COM-объекта с использованием позднего связывания\n        public static void SetProperty(object obj, string property, string value)\n        {\n            int dispId = GetDispId(obj, property); \n            InvokePropertySetter(obj as IDispatch, dispId, value);\n        }\n\n        const uint DISPATCH_METHOD = 0x1;\n        const uint DISPATCH_PROPERTYGET = 0x2;\n        const uint DISPATCH_PROPERTYPUT = 0x4;\n\n        // Получение DispId для указанного метода (свойства) COM-объекта с использованием позднего связывания\n        // Источник: https://github.com/dotnet/corefx/issues/19731\n        public static int GetDispId(object rcw, string methodName) \n        {\n            IDispatch dispatchObject = rcw as IDispatch;\n            if (dispatchObject == null)\n            {\n                Console.WriteLine(\"Passed-in argument is not a IDispatch object\");\n                return -1;\n            }\n\n            int[] dispIds = new int[1];\n            Guid emtpyRiid = Guid.Empty;\n            dispatchObject.GetIDsOfNames(\n                emtpyRiid,\n                new string[] { methodName },\n                1,\n                0,\n                dispIds);\n\n            if (dispIds[0] == -1)\n            {\n                Console.WriteLine(\"Method name {0} cannot be recognized.\", methodName);\n            }\n\n            return dispIds[0];\n        }\n\n        public static object InvokePropertySetter(IDispatch target, int dispId, string val)\n        {\n            const int DISPID_PROPERTYPUT = -3;\n            IntPtr pArg = IntPtr.Zero;\n            IntPtr pNamedArgs = IntPtr.Zero;\n            IntPtr pStr = IntPtr.Zero;\n            IntPtr dispIdArray = IntPtr.Zero, tmpVariants = IntPtr.Zero;\n\n            if (target == null) { Console.WriteLine(\"Cannot cast target to IDispatch.\"); return null; }\n\n            try\n            {\n                pStr = Marshal.StringToBSTR(val);\n                Variant variant = new Variant();\n                variant.vt = 8; //VT_BSTR\n                variant.p = pStr;\n\n                pArg = Marshal.AllocHGlobal(Marshal.SizeOf(variant));\n                Marshal.StructureToPtr(variant, pArg, false);\n\n                pNamedArgs = Marshal.AllocHGlobal(4);\n                Marshal.WriteInt32(pNamedArgs, DISPID_PROPERTYPUT);\n\n                var paramArray = new ComTypes.DISPPARAMS[1];\n                paramArray[0].rgvarg = pArg;\n                paramArray[0].cArgs = 1;\n                paramArray[0].cNamedArgs = 1;\n                paramArray[0].rgdispidNamedArgs = pNamedArgs;\n\n                ComTypes.EXCEPINFO info = default(ComTypes.EXCEPINFO);\n                object result = null;                                \n                uint puArgErrNotUsed = 0;\n\n                target.Invoke(dispId, new Guid(), 0x0409, ComTypes.INVOKEKIND.INVOKE_PROPERTYPUT,\n                        paramArray, out result, out info, out puArgErrNotUsed);\n\n                return result;\n            }\n            finally\n            {\n                if (pStr != IntPtr.Zero) Marshal.FreeBSTR(pStr);\n                if (pArg != IntPtr.Zero) Marshal.FreeHGlobal(pArg);\n                if (pNamedArgs != IntPtr.Zero) Marshal.FreeHGlobal(pNamedArgs);\n            }\n\n        }\n\n        [DllImport(\"ole32.dll\")]\n        public static extern int CLSIDFromProgID([MarshalAs(UnmanagedType.LPWStr)] string lpszProgID, out Guid pclsid);\n\n\n        [Guid(\"00020400-0000-0000-c000-000000000046\")]\n        [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n        [ComImport]\n        public interface IDispatch\n        {\n            [PreserveSig]\n            int GetTypeInfoCount(out int info);\n\n            [PreserveSig]\n            int GetTypeInfo(int iTInfo, int lcid, out ComTypes.ITypeInfo ppTInfo);\n\n            void GetIDsOfNames(\n                [MarshalAs(UnmanagedType.LPStruct)] Guid iid,\n                [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPWStr)] string[] rgszNames,\n                int cNames,\n                int lcid,\n                [Out, MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.I4)] int[] rgDispId);\n\n            void Invoke(\n                int dispIdMember,\n                [MarshalAs(UnmanagedType.LPStruct)] Guid iid,\n                int lcid,\n                ComTypes.INVOKEKIND wFlags,\n                [In, Out] [MarshalAs(UnmanagedType.LPArray)] ComTypes.DISPPARAMS[] paramArray,\n                out object pVarResult,\n                out ComTypes.EXCEPINFO pExcepInfo,\n                out uint puArgErr);\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct Variant\n        {\n            public ushort vt;\n            ushort wReserved1;\n            ushort wReserved2;\n            ushort wReserved3;\n            public IntPtr p;            \n        }\n    }\n}\n</code></pre>\n"}