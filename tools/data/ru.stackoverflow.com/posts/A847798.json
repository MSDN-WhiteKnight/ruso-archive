{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":2,"last_activity_date":1530180768,"last_edit_date":1530180768,"creation_date":1530180389,"answer_id":847798,"question_id":823677,"body":"<p>Встроить файл конфигурации в EXE-файл нельзя (так как весь смысл конфигурации - это возможность редактирования параметров без перекомпиляции программы, такой возможности не предусмотрели). Влиять на параметр <code>supportedRuntime</code> из кода на C# также нельзя, так этот параметр используется неуправляемым кодом загрузчика до того, как в процесс загружена CLR, и в этот момент управляемый код еще не может выполняться.</p>\n\n<p>Если нужно управлять выбором версии CLR без файла конфигурации, единственный способ - написать свой собственный загрузчик на С++, пользуясь <a href=\"https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/index\" rel=\"nofollow noreferrer\">Unmanaged .NET API</a>.</p>\n\n<p>Например, создадим такую программу на C#:</p>\n\n<pre><code>using System;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static int Run(string arg)\n        {\n            Console.WriteLine(\"Hello from .NET \" + Environment.Version.ToString());\n            Console.ReadKey();\n            return 0;\n        }\n\n        static void Main(string[] args)\n        {\n            Run(\"\");\n        }        \n    }    \n}\n</code></pre>\n\n<p>Скомпилируем ее, получаем файл <em>Program.exe</em>. Создадим проект С++, добавим в него файл <em>Program.exe</em> и создадим файл ресурсов <em>resource.rc</em> следующего содержания:</p>\n\n<pre><code>#define IDR_RCDATA1 101\n\nIDR_RCDATA1 RCDATA \"Program.exe\"\n</code></pre>\n\n<p>Напишем на С++ код загрузчика, который находит первую установленную версию CLR, загружает ее, извлекает из ресурсов программу на C# во временную папку и запускает ее:</p>\n\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n#include &lt;metahost.h&gt;\n\n#pragma comment(lib, \"mscoree.lib\")\n\n#define IDR_RCDATA1 101\n\nint wmain(int argc, wchar_t* argv[])\n{\n    LPCWSTR prog_name = L\"Program.exe\"; //имя программы на C#\n\n    //построим путь к временному файлу  \n    WCHAR temppath[300] = L\"c:\\\\temp\\\\\";\n    GetTempPath(300,temppath);\n    wcscat(temppath,prog_name); \n\n    //извлечем программу из ресурсов\n    HRSRC myResource = ::FindResource(NULL, MAKEINTRESOURCE(IDR_RCDATA1), RT_RCDATA);\n    UINT Size = ::SizeofResource(NULL, myResource);\n    HGLOBAL myResourceData = ::LoadResource(NULL, myResource);\n    void* pMyBinaryData = ::LockResource(myResourceData);\n    FILE* f = _wfopen(temppath,L\"wb\");\n    fwrite(pMyBinaryData,Size,1,f);\n    fclose(f);\n\n    //инициализация CLR...\n    HRESULT hr;\n    ICLRMetaHost *pMetaHost = NULL;\n    ICLRRuntimeInfo *pRuntimeInfo = NULL;\n    ICLRRuntimeHost *pClrRuntimeHost = NULL; \n    IEnumUnknown* pEnum= NULL;\n    ICLRRuntimeInfo* pInfo= NULL;\n    IUnknown* pUnk = NULL;\n\n    hr = CLRCreateInstance(CLSID_CLRMetaHost, IID_PPV_ARGS(&amp;pMetaHost));\n    if(FAILED(hr)){printf(\"CLRCreateInstance failed\\n\");goto End;}\n\n    //поиск установленных версий CLR...\n    pMetaHost-&gt;EnumerateInstalledRuntimes(&amp;pEnum);\n    if(FAILED(hr)){printf(\"EnumerateInstalledRuntimes failed\\n\");goto End;}\n\n    ULONG c= 0;\n    WCHAR buffer[250];\n    DWORD cch = 250;\n\n    while(1){\n        if(pInfo!=NULL){pInfo-&gt;Release();pInfo = NULL;}\n        if(pUnk!=NULL){pUnk-&gt;Release();pUnk = NULL;}\n        if(pRuntimeInfo!=NULL){pRuntimeInfo-&gt;Release();pRuntimeInfo = NULL;}        \n\n        hr = pEnum-&gt;Next(1,&amp;pUnk,&amp;c);\n        if(hr != S_OK)break;\n\n        pUnk-&gt;QueryInterface(IID_ICLRRuntimeInfo, (void**)&amp;pInfo);\n        if(FAILED(hr)){printf(\"QueryInterface failed\\n\");continue;}\n\n        pInfo-&gt;GetVersionString(buffer,&amp;cch);\n        if(FAILED(hr)){printf(\"GetVersionString failed\\n\");continue;}\n\n        hr = pMetaHost-&gt;GetRuntime(buffer, IID_PPV_ARGS(&amp;pRuntimeInfo));\n        if(hr == S_OK){break;}      \n        else {wprintf(L\".NET %s: GetRuntime HRESULT 0x%x\\n\",buffer,(UINT)hr);}\n    }\n\n    if(pRuntimeInfo == NULL){printf(\"Failed to initialize CLR\\n\");goto End;}\n\n    /* Можно также указать версию явно, например:\n          pMetaHost-&gt;GetRuntime(L\"v2.0.50727\", IID_PPV_ARGS(&amp;pRuntimeInfo));\n          pMetaHost-&gt;GetRuntime(L\"v4.0.30319\", IID_PPV_ARGS(&amp;pRuntimeInfo));\n       и т.п.\n    */\n\n    hr = pRuntimeInfo-&gt;GetInterface(CLSID_CLRRuntimeHost,\n        IID_PPV_ARGS(&amp;pClrRuntimeHost));\n    if(FAILED(hr)){printf(\"GetInterface failed\\n\");goto End;}\n\n    //запуск CLR\n    hr = pClrRuntimeHost-&gt;Start();\n    if(FAILED(hr)){printf(\"Start failed\\n\");goto End;}\n\n    //Запуск программы на C#\n    DWORD pReturnValue;\n    hr = pClrRuntimeHost-&gt;ExecuteInDefaultAppDomain(\n        temppath,\n        L\"ConsoleApplication1.Program\", //класс\n        L\"Run\", //метод\n        L\"\", //параметр\n        &amp;pReturnValue);\n    if(FAILED(hr)){printf(\"ExecuteInDefaultAppDomain failed 0x%x\\n\",(UINT)hr);goto End;}\n\nEnd:\n\n    //Освобождение ресурсов\n    if(pMetaHost != NULL) pMetaHost-&gt;Release();\n    if(pRuntimeInfo != NULL) pRuntimeInfo-&gt;Release();\n    if(pClrRuntimeHost != NULL) pClrRuntimeHost-&gt;Release();\n    if(pEnum != NULL) pEnum-&gt;Release();\n    if(pInfo != NULL) pInfo-&gt;Release();\n    if(pUnk != NULL) pUnk-&gt;Release();       \n    return 0;\n}\n</code></pre>\n\n<p>В результате программа, собранная под .NET 2.0, при его отсутствии будет запускаться на имеющейся версии .NET, как и при использовании параметра <code>supportedRuntime</code>.</p>\n\n<p><strong>Источники:</strong></p>\n\n<p><a href=\"https://stackoverflow.com/a/45056961/8674428\">Embedding supportedRuntime into exe file - ответ Ondrej Svejdar</a></p>\n\n<p><a href=\"https://stackoverflow.com/a/9240388/8674428\">How to load a custom binary resource in a VC++ static library as part of a dll?\n - ответ LihO</a></p>\n"}