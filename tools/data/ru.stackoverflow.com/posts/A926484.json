{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":5,"last_activity_date":1546153526,"last_edit_date":1546153526,"creation_date":1545993825,"answer_id":926484,"question_id":926467,"body":"<p>Если под \"Очистить\" понимается \"Вызвать метод Clear() через позднее связывание или упасть, если его нету\", то как-то так:</p>\n\n<pre><code>Type RuntimeType = obj.GetType();\nMethodInfo method = RuntimeType.GetMethod(\"Clear\");\nif (method == null) throw new ApplicationException(\"Object type does not have Clear() method!\");\nelse method.Invoke(obj, new object[] { });\n</code></pre>\n\n<hr>\n\n<p>Если под \"Очистить\" понимается \"Присвоить свойству значение новой пустой коллекции\", то как-то так:</p>\n\n<pre><code>static bool IsIEnumerable(Type t)\n{\n    if (!t.IsGenericType) return false;\n    Type InterfType = typeof(IEnumerable&lt;&gt;);\n    if (t.GetGenericTypeDefinition() == InterfType) return true;\n\n    foreach (Type it in t.GetInterfaces())\n    {\n        if (it.IsGenericType &amp;&amp; it.GetGenericTypeDefinition() == InterfType) return true;\n    }\n\n    return false;\n}\n\nstatic void ClearIEnumerable(PropertyInfo prop, object obj)\n{\n    Type PropType = prop.PropertyType;\n    if (!IsIEnumerable(PropType)) throw new ArgumentException(\"Property is not IEnumerable&lt;T&gt;\");\n\n    Type InnerType = PropType.GetGenericArguments()[0];\n    Type ListType;\n    if (PropType.GetGenericTypeDefinition() == typeof(IEnumerable&lt;&gt;))\n        ListType = typeof(List&lt;&gt;).MakeGenericType(InnerType);\n    else\n        ListType = PropType;\n\n    object new_val = Activator.CreateInstance(ListType);\n    prop.SetValue(obj, new_val);\n}\n</code></pre>\n"}