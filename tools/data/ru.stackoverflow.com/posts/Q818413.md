---
title: "Как подключить dll(c++) к с#?"
se.owner.user_id: 239394
se.owner.display_name: "Александр Ли"
se.owner.link: "https://ru.stackoverflow.com/users/239394/%d0%90%d0%bb%d0%b5%d0%ba%d1%81%d0%b0%d0%bd%d0%b4%d1%80-%d0%9b%d0%b8"
se.link: "https://ru.stackoverflow.com/questions/818413/%d0%9a%d0%b0%d0%ba-%d0%bf%d0%be%d0%b4%d0%ba%d0%bb%d1%8e%d1%87%d0%b8%d1%82%d1%8c-dllc-%d0%ba-%d1%81"
se.question_id: 818413
se.post_type: question
se.score: 1
---
<p>Знаю, что популярная проблема. Но нужно срочно, а я вообще не бум-бум.</p>

<p>Нужно подключить вот эту функцию:</p>

<pre><code>DLL_EXPORT int __stdcall EvalCRC(IStream* Data, IStream* Params, IStream* Output)
{
    if (!Data) return ERROR_NULL_DATA;

    // Data - это входной поток с прошивкой, контрольку в которой нужно пересчитать
    // Params и Output пока не используются и зарезервированы на будущее
    int Result = PLUGIN_SUCCESS; // По-умолчанию возвращаем результат успешного выполнения

    ULARGE_INTEGER size_;
    LARGE_INTEGER larg_;

    //ENCODE_START

    larg_.QuadPart = 0;
    Data-&gt;Seek(larg_, STREAM_SEEK_END, &amp;size_);

    // Считаем КС прошивки
    if (size_.QuadPart == VALIDFWSIZE1 || size_.QuadPart == VALIDFWSIZE2)
    {
        try
        {
            char arr[IDLEN+1];
            ULONG ulong;
            unsigned int caloffset;

            switch(size_.QuadPart)
            {
                case VALIDFWSIZE1:
                {
                    // Калибровки
                    larg_.QuadPart = CAL_POS1;
                    Data-&gt;Seek(larg_ ,STREAM_SEEK_SET, &amp;size_);
                    Data-&gt;Read(&amp;arr, sizeof(arr), &amp;ulong); // Вычитываем идентификатор
                    arr[IDLEN]=0x00;

                    if (CheckNumber(arr)) caloffset=CAL_POS1;
                    else return ERROR_SIGNATURE;
                }
                break;
                case VALIDFWSIZE2:
                {
                    // Фулл
                    larg_.QuadPart = CAL_POS2;
                    Data-&gt;Seek(larg_ ,STREAM_SEEK_SET, &amp;size_);
                    Data-&gt;Read(&amp;arr, sizeof(arr), &amp;ulong); // Вычитываем идентификатор
                    arr[IDLEN]=0x00;

                    if (CheckNumber(arr)) caloffset=CAL_POS2;
                    else
                    {
                        larg_.QuadPart = CAL_POS3;
                        Data-&gt;Seek(larg_ ,STREAM_SEEK_SET, &amp;size_);
                        Data-&gt;Read(&amp;arr, sizeof(arr), &amp;ulong); // Вычитываем идентификатор
                        arr[IDLEN]=0x00;

                        if (CheckNumber(arr)) caloffset=CAL_POS3;
                        else return ERROR_SIGNATURE;
                    }
                }
                break;
            }

            larg_.QuadPart = caloffset;
            Data-&gt;Seek(larg_ ,STREAM_SEEK_SET, &amp;size_);
            WORD wval=0;
            for(unsigned int i=0;i&lt;(cRangeSize/2)-1;i++)
            {
                WORD wword;
                Data-&gt;Read(&amp;wword, sizeof(WORD), &amp;ulong);
                wword = (wword &gt;&gt; 8) | (wword &lt;&lt; 8); // Переворачиваем
                if (i!=cCSPos/2) wval += wword; // Считаем все, кроме контрольных сумм
            }

            wval=0-wval;
            larg_.QuadPart = caloffset+cCSPos;
            Data-&gt;Seek(larg_ ,STREAM_SEEK_SET, &amp;size_);
            wval = (wval &gt;&gt; 8) | (wval &lt;&lt; 8); // Переворачиваем
            Data-&gt;Write(&amp;wval, sizeof(WORD), &amp;ulong);
        }
        catch(...)
        {
            Result = ERROR_EXCEPTION;
        }
    }
    else Result = ERROR_INVALID_SIZE;

    return Result;
}
</code></pre>

<p>Пробовал по всякому, то типы данных не совпадают, то просто какие-то вылеты без ошибок и результатов. 
Если это не сложно, подскажите, как должна выглядеть строка подключения?</p>
