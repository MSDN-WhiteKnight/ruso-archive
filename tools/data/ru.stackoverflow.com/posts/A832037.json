{"owner":{"reputation":16068,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":3,"last_activity_date":1527067383,"last_edit_date":1527067383,"creation_date":1527049392,"answer_id":832037,"question_id":831776,"body":"<p>Дело в том, что у функции <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms633539(v=vs.85).aspx\" rel=\"nofollow noreferrer\">SetForegroundWindow</a> в Windows есть некоторые ограничения. Изменить активное окно может только процесс, который уже владеет активным окном, у которого недавно было свернуто активное окно, в который недавно осуществлялся ввод с помощью клавиатуры или мыши, либо которому явно выдано разрешение на изменение активного окна с помощью <em>AllowSetForegroundWindow</em> (есть и другие случаи, см. документацию). Поэтому данная схема работает не всегда. Обходится это довольно просто (на Win7, по крайней мере), перед активацией окна сначала его свернуть и восстановить:</p>\n\n<pre><code>private void NamedPipeManager_ReceiveString(string obj)\n{\n    main.WindowState = FormWindowState.Minimized;            \n    main.WindowState = FormWindowState.Normal;\n    main.Activate();\n}\n</code></pre>\n\n<p>Но в целом, вся схема с мьютексами и каналами для проверки единственности окна программы кажется слишком сложной и ненужной. То же самое можно реализовать гораздо проще, не упираясь в эти ограничения. Существующее окно программы можно найти через <em>Process.MainWindowHandle</em>, а для передачи командной строки использовать <em>WM_COPYDATA</em>:</p>\n\n<pre><code>using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Text;\nusing System.Windows.Forms;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\n\nnamespace WindowsFormsTest1\n{    \n    public partial class Form1 : Form\n    {\n        [DllImport(\"user32.dll\")]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        static extern bool SetForegroundWindow(IntPtr hWnd);\n\n        [DllImport(\"user32.dll\")]\n        static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);\n\n        const int ShowWindow_Restore = 9;\n\n        [DllImport(\"user32.dll\")]\n        public static extern IntPtr SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, ref COPYDATASTRUCT lParam);\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct COPYDATASTRUCT\n        {\n            public IntPtr dwData;\n            public int cbData;                        \n            public IntPtr lpData;\n        }\n\n        const uint WM_COPYDATA = 0x004A;\n\n        public Form1()\n        {\n            InitializeComponent();            \n\n            Process this_process = Process.GetCurrentProcess();            \n\n            //найти все процессы с таким же именем\n            Process[] other_processes =\n                Process.GetProcessesByName(this_process.ProcessName).Where(pr =&gt; pr.Id != this_process.Id).ToArray();\n\n            foreach (var pr in other_processes)\n            {\n                pr.WaitForInputIdle(1000); //на случай, если процесс еще не загрузился\n\n                //берем первый процесс с окном\n                IntPtr hWnd = pr.MainWindowHandle;\n                if (hWnd == IntPtr.Zero) continue;\n\n                //отправляем командную строку\n                string command_line = \"/activate\";\n                var cds = new COPYDATASTRUCT();\n                cds.dwData = (IntPtr)1;\n                cds.cbData = (command_line.Length + 1) * 2;\n                cds.lpData = Marshal.StringToHGlobalUni(command_line);\n                SendMessage(hWnd, WM_COPYDATA, IntPtr.Zero, ref cds);\n                Marshal.FreeHGlobal(cds.lpData);\n\n                //активируем окно и выходим\n                ShowWindow(hWnd, ShowWindow_Restore);\n                SetForegroundWindow(hWnd);\n                Environment.Exit(0);\n            }\n            //если ничего не найдено, продолжаем работу\n        }\n\n        protected override void WndProc(ref Message m)\n        {\n            if (m.Msg == WM_COPYDATA)\n            {\n                COPYDATASTRUCT data = new COPYDATASTRUCT();\n                data = (COPYDATASTRUCT)Marshal.PtrToStructure(m.LParam, data.GetType());                \n                textBox1.Text = Marshal.PtrToStringUni(data.lpData);                 \n            }\n            base.WndProc(ref m);\n        }    \n\n        private void Form1_Load(object sender, EventArgs e)\n        {\n            textBox1.Focus();\n            textBox1.Select();\n        }\n\n    }           \n\n}\n</code></pre>\n"}