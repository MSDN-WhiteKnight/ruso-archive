{"owner":{"reputation":16137,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":1,"last_activity_date":1546800835,"creation_date":1546800835,"answer_id":929087,"question_id":928816,"body":"<p>Нет, это не работает. Смысл хуков - отслеживание событий, а не активное воздействие на них. Тем не менее, хук позволяет отменить событие, вернув из процедуры единицу, так что оно не дойдет до целевого приложения. Тогда вы можете сгенерировать вместо него свое с помощью SendInput:</p>\n\n<pre><code>LRESULT CALLBACK LowLevelKeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)\n{        \n    if (nCode == HC_ACTION)\n    {\n        switch (wParam)\n        {\n        case WM_KEYDOWN:\n            PKBDLLHOOKSTRUCT p = (PKBDLLHOOKSTRUCT)lParam;\n            if(p-&gt;vkCode == VK_SPACE) {\n\n                INPUT ip;\n                ip.type = INPUT_KEYBOARD;\n                ip.ki.wScan = 0; \n                ip.ki.time = 0;\n                ip.ki.dwExtraInfo = 0;    \n                ip.ki.wVk = 0x5A; //Z\n                ip.ki.dwFlags = 0; // key press\n                SendInput(1, &amp;ip, sizeof(INPUT));\n\n                ip.ki.dwFlags = KEYEVENTF_KEYUP; // key release\n                SendInput(1, &amp;ip, sizeof(INPUT));\n\n                return 1;\n            }           \n            break;\n        }\n    }\n    return CallNextHookEx(NULL, nCode, wParam, lParam);\n} \n</code></pre>\n\n<p>События, сгенерированные SendInput, могут восприниматься некоторыми приложениями не так, как настоящие события клавиатуры. </p>\n"}