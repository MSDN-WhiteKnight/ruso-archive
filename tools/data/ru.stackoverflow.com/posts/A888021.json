{"owner":{"reputation":16117,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":2,"last_activity_date":1538456732,"creation_date":1538456732,"answer_id":888021,"question_id":886968,"body":"<p>У вас не из той структуры значение берется. Да и значение в структуре на самом деле не имя устройства, а путь к нему. Имя устройства еще нужно искать (проще всего, через реестр). Как-то так:</p>\n\n<pre><code>#include &lt;Windows.h&gt;\n#include \"dbt.h\"\n#include \"initguid.h\"\n#include \"usbiodef.h\"\n\n//...\n\nHDEVNOTIFY NotificationHande;\nDEV_BROADCAST_DEVICEINTERFACE DeviceStruct;\n\n//получение имени устройства\nbool GetDeviceName(const wchar_t* symlink, wchar_t* name, int cname) {\n\n    if(symlink == NULL) return false;\n    if (name == NULL) return false;\n    if (wcslen(symlink) &lt; 10) return false;\n\n    //распарсим путь к устройству на составляющие\n    const wchar_t* pEnum = symlink + 3;\n\n    const wchar_t* pDeviceID = wcsstr(symlink, L\"#\");\n    if(pDeviceID == NULL) return false;\n    int lenEnum = pDeviceID - pEnum;\n    pDeviceID++;\n\n    const wchar_t* pInstID = wcsstr(pDeviceID, L\"#\");\n    if (pInstID == NULL) return false;\n    int lenDeviceID = pInstID - pDeviceID;\n    pInstID++;\n\n    const wchar_t* pEnd = wcsstr(pInstID, L\"#\");\n    if (pEnd == NULL) return false;\n    int lenInstID = pEnd - pInstID;\n\n    //соберем из них путь к ключу реестра\n    wchar_t path[1024] = L\"SYSTEM\\\\CurrentControlSet\\\\Enum\";    \n\n    wcsncat_s(path, 1024, pEnum, lenEnum);\n    wcsncat_s(path, 1024, L\"\\\\\", 1);\n    wcsncat_s(path, 1024, pDeviceID, lenDeviceID);\n    wcsncat_s(path, 1024, L\"\\\\\", 1);\n    wcsncat_s(path, 1024, pInstID, lenInstID);\n\n    //попытаемся получить имя или описание устройства из реестра\n    HKEY hKey = NULL;\n    LONG lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, path, 0, KEY_READ, &amp;hKey);\n    if (ERROR_SUCCESS != lRes)\n    {       \n        return false;\n    }\n\n    WCHAR szBuffer[1024] = L\"\";\n    DWORD dwBufferSize = sizeof(szBuffer);\n    lRes = RegQueryValueExW(hKey, L\"FriendlyName\", 0, NULL, (LPBYTE)szBuffer, &amp;dwBufferSize);\n    if (ERROR_SUCCESS != lRes)\n    {\n        dwBufferSize = sizeof(szBuffer);\n        lRes = RegQueryValueExW(hKey, L\"DeviceDesc\", 0, NULL, (LPBYTE)szBuffer, &amp;dwBufferSize);\n    }\n\n    if (ERROR_SUCCESS != lRes)\n    {       \n        RegCloseKey(hKey);\n        return false;\n    }\n\n    wcscpy_s(name, cname, szBuffer);\n    return true;\n}\n\nLRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    switch (message)\n    {\n    case WM_CREATE:\n        {               \n\n        DeviceStruct.dbcc_size = sizeof(DeviceStruct);\n        DeviceStruct.dbcc_classguid = GUID_DEVINTERFACE_USB_DEVICE;\n        DeviceStruct.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;\n        NotificationHande = RegisterDeviceNotification(hWnd, &amp;DeviceStruct, DEVICE_NOTIFY_WINDOW_HANDLE | DEVICE_NOTIFY_ALL_INTERFACE_CLASSES);\n\n        }\n        break;\n    case WM_DEVICECHANGE:\n        if (wParam == DBT_DEVICEARRIVAL)\n        {\n            DEV_BROADCAST_HDR* NewDevice = (DEV_BROADCAST_HDR*)lParam;\n            if (NewDevice-&gt;dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE)\n            {\n                DEV_BROADCAST_DEVICEINTERFACE* pDev = (DEV_BROADCAST_DEVICEINTERFACE*)lParam;\n\n                WCHAR name[1024] = L\"\";\n                if(GetDeviceName(pDev-&gt;dbcc_name, name, 1024) != false)\n                    MessageBoxW(hWnd, name, L\"Device\", MB_OK);\n                else \n                    MessageBoxW(hWnd, pDev-&gt;dbcc_name, L\"Device\", MB_OK);\n\n            }\n        }\n        break;\n\n    case WM_DESTROY:\n        PostQuitMessage(0);\n        break;\n    default:\n        return DefWindowProc(hWnd, message, wParam, lParam);\n    }\n    return 0;\n}\n</code></pre>\n"}