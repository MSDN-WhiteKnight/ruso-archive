{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":1,"last_activity_date":1509203347,"last_edit_date":1509203347,"creation_date":1509085907,"answer_id":736536,"question_id":733291,"body":"<p>Значения GUID свойств находятся в <em>Functiondiscoverykeys_devpkey.h</em>. Например, имя устройства - <code>PKEY_Device_FriendlyName</code>.</p>\n\n<p>Но информация о разъемах - это не свойства. Ее получают с помощью другого API -  <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/dd370825(v=vs.85).aspx\" rel=\"nofollow noreferrer\">Device Topology</a>. Интерфейс <code>IKsJackDescription</code> позволяет получить структуру <code>KSJACK_DESCRIPTION</code>, содержащую данные о типе разъема, его расположении и т.д.</p>\n\n<p>Пример кода для вывода ID, имени и информации о разъемах для всех аудиоустройств:</p>\n\n<pre><code>#define INITGUID\n#include &lt;stdio.h&gt;\n#include &lt;tchar.h&gt;\n#include &lt;Windows.h&gt;\n#include &lt;Objbase.h&gt;\n#include &lt;Shobjidl.h&gt;\n#include &lt;MMDeviceAPI.h&gt;\n#include &lt;locale.h&gt;\n#include &lt;Functiondiscoverykeys_devpkey.h&gt;\n#include &lt;Devicetopology.h&gt;\n\n#pragma comment(lib, \"uuid.lib\")\n\n\n#define SAFE_RELEASE(punk)  \\\n              if ((punk) != NULL)  \\\n                { (punk)-&gt;Release(); (punk) = NULL; }\n\n\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n setlocale(LC_ALL,\"Russian\");\n CoInitialize(NULL);\n TCHAR* pstr=NULL;\n DWORD state;\n\n IMMDeviceEnumerator *deviceEnumerator = NULL;\n IMMDeviceCollection *deviceCollection = NULL;\n IMMDevice* dev=NULL;\n IPropertyStore *propertyStore=NULL;\n IDeviceTopology *pDeviceTopology = NULL;\n IConnector *pConnFrom = NULL;\n IConnector *pConnTo = NULL;\n IPart *pPart = NULL;\n IKsJackDescription *pJackDesc = NULL;\n\n HRESULT hr = CoCreateInstance(__uuidof(MMDeviceEnumerator), NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&amp;deviceEnumerator));\n if(FAILED(hr)) {printf(\"CoCreateInstance failed\");goto End;}\n\n /*Получение аудиоустройств*/ \n hr = deviceEnumerator-&gt;EnumAudioEndpoints(eRender,  DEVICE_STATE_ACTIVE|DEVICE_STATE_UNPLUGGED, &amp;deviceCollection);\n if(FAILED(hr)) {printf(\"EnumAudioEndpoints failed\");goto End;}\n\n UINT deviceCount;\n hr = deviceCollection-&gt;GetCount(&amp;deviceCount);\n if(FAILED(hr)) {printf(\"GetCount failed\");goto End;}\n\n for (UINT DeviceIndex = 0 ; DeviceIndex &lt; deviceCount; DeviceIndex++)\n {\n    deviceCollection-&gt;Item(DeviceIndex,&amp;dev);\n    if(FAILED(hr)) {printf(\"Item failed\");continue;}\n    dev-&gt;GetId(&amp;pstr);\n    if(FAILED(hr)) {printf(\"GetId failed\");continue;}\n    printf(\"Device id: \");\n    wprintf(pstr);\n    printf(\"\\n\");\n\n\n    hr = dev-&gt;OpenPropertyStore(STGM_READ, &amp;propertyStore); \n    if(FAILED(hr)) {printf(\"OpenPropertyStore failed\");goto Next;}\n\n    /*Получение имени устройства*/\n    PROPVARIANT friendlyName;\n    PropVariantInit(&amp;friendlyName);\n    hr = propertyStore-&gt;GetValue(PKEY_Device_FriendlyName, &amp;friendlyName);\n\n    if(FAILED(hr)) {printf(\"GetValue failed\");goto Next;}\n    wprintf(friendlyName.pwszVal);\n    printf(\"\\n\");\n    PropVariantClear(&amp;friendlyName);  \n\n    /*Получение информации о разъемах*/\n\n    hr = dev-&gt;Activate(__uuidof(IDeviceTopology), CLSCTX_ALL,\n                           NULL, (void**)&amp;pDeviceTopology);\n    if(FAILED(hr)) {printf(\"Activate failed\");goto Next;}\n\n    hr = pDeviceTopology-&gt;GetConnector(0, &amp;pConnFrom);\n    if(FAILED(hr)) {printf(\"GetConnector failed\");goto Next;} \n\n    hr = pConnFrom-&gt;GetConnectedTo(&amp;pConnTo);\n    if (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)\n    {\n        // The adapter device is not currently active.\n        hr = E_NOINTERFACE;\n    }\n    if(FAILED(hr)) {printf(\"GetConnector 2 failed\");goto Next;} \n\n    // Get the connector's IPart interface.\n    hr = pConnTo-&gt;QueryInterface(__uuidof(IPart), (void**)&amp;pPart);\n    if(FAILED(hr)) {printf(\"QueryInterface failed\");goto Next;}\n\n    // Activate the connector's IKsJackDescription interface.  \n    hr = pPart-&gt;Activate(CLSCTX_INPROC_SERVER,\n                         __uuidof(IKsJackDescription), (void**)&amp;pJackDesc);\n    if(FAILED(hr)) {printf(\"IKsJackDescription failed: %d\\n\",hr);goto Next;}\n\n    UINT jacks=0;\n    KSJACK_DESCRIPTION jdesc;\n    hr=pJackDesc-&gt;GetJackCount(&amp;jacks);\n    if(FAILED(hr)) {printf(\"GetJackCount failed\");goto Next;}\n    printf(\"Jack count: %d\\n\\n\",jacks);\n\n    /*Вывод разъемов*/\n    for(UINT i=0;i&lt;jacks;i++){\n        hr=pJackDesc-&gt;GetJackDescription(i,&amp;jdesc);\n        if(FAILED(hr)) {printf(\"GetJackDescription failed\");continue;}\n        printf(\"* Jack #%d *\\n\",(int)(i+1)); \n\n        if(jdesc.IsConnected==0){//состояние\n            printf(\"Device not connected\\n\");      \n        }else{\n            printf(\"Device connected\\n\");\n        }\n\n        wprintf(L\"Connection Type: \");\n        switch (jdesc.ConnectionType)//тип разъема\n        {\n        case eConnType3Point5mm: wprintf(L\"Разъем 3.5 мм \\n\");break;\n        case eConnTypeAtapiInternal:wprintf(L\"Разъем ATAPI \\n\");break;\n        case eConnTypeRCA: wprintf(L\"Разъем RCA \\n\");break;\n        case eConnTypeQuarter: wprintf(L\"Разъем 1/2 дюйма \\n\");break;\n        case eConnTypeOtherAnalog: wprintf(L\"Аналоговый разъем \\n\");break;\n        case eConnTypeOtherDigital: wprintf(L\"Цифровой разъем \\n\"); break;\n        default: wprintf(L\"0x%x\\n\",jdesc.ConnectionType); break;\n        }\n\n        wprintf(L\"GeoLocation: \");\n\n        switch (jdesc.GeoLocation)//расположение разъема\n        {\n        case eGeoLocFront: wprintf(L\"Передняя панель\\n\");break;\n        case eGeoLocRear: wprintf(L\"Задняя панель\\n\");break;\n        case eGeoLocHDMI: wprintf(L\"HDMI\\n\");break;\n        case eGeoLocATAPI: wprintf(L\"ATAPI\\n\");break;\n        case eGeoLocNotApplicable: wprintf(L\"Не определено\\n\");break;\n        default: printf(\"0x%x\\n\",jdesc.GeoLocation);break;\n        }\n\n\n     }\n     /* очистка ресурсов */\n  Next:SAFE_RELEASE(dev);SAFE_RELEASE(propertyStore);SAFE_RELEASE(pDeviceTopology);\n       SAFE_RELEASE(pConnFrom);SAFE_RELEASE(pConnTo);SAFE_RELEASE(pPart);\n       SAFE_RELEASE(pJackDesc);\n       printf(\"\\n\");\n } \n\nEnd:\n SAFE_RELEASE(deviceEnumerator);\n SAFE_RELEASE(deviceCollection);\n system(\"PAUSE\");\n CoUninitialize();\n return 0;\n}\n</code></pre>\n"}