---
title: "Answer 760685"
se.owner.user_id: 182825
se.owner.display_name: "AnT"
se.owner.link: "https://ru.stackoverflow.com/users/182825/ant"
se.answer_id: 760685
se.question_id: 760436
se.post_type: answer
se.score: 5
se.is_accepted: False
---
<p>В современном С++ более предпочтительным считается именно второй вариант. Т.е. если вы знаете, что вам в любом случае понадобится копия, то лучше чтобы эту копию для вас делал компилятор, а не вы сами.</p>

<p>Однако традиционное обоснование, приводящееся для этого утверждения, рассчитывает на типы, которые "тяжелы" для копирования не потому, что велики по размеру сами по себе, а потому, что требуют <em>глубокого</em> (deep) копирования. Т.е. речь идет о типах, которые являются компактными на <em>мелком</em> (shallow) уровне, но владеют дополнительными ресурсами через указатели/хендлы. Вся идея тут в том, что компилятор будет в состоянии заменить копирование на перемещение в ситуациях, когда исходное значение является временным/переместимым.</p>

<p>Например, если в вашем случае заменить <code>S</code> на <code>std::string</code>, то при вызове <code>test("abc")</code> второй вариант при подготовке аргументов обойдется без глубокого копирования вообще, в то время как в первом варианте вы сами безусловно выполните глубокое копирование.</p>

<p>(Еще более эффективным может быть вариант с двумя отдельными функциями - для параметра <code>const std::string &amp;</code> и для параметра <code>std::string &amp;&amp;</code>, но если вы не пытаетесь выжать последние такты процессора, то одна функция с параметром <code>std::string</code> часто выглядит привлекательнее.)</p>

<p>В случае же, когда "тяжесть" объекта встроена непосредственно в сам объект, как в вашем примере, сэкономить на копировании не удастся. Я бы ожидал одинаковой производительности от обоих вариантов. </p>

<p>Некоторым нюансом является то, что, согласно абстрактной семантике языка, создание копии во втором варианте делается в контексте <em>вызывающего</em> кода. Некоторые реализации следуют этой семантике буквально - они выполняют создание копии и резервирование памяти для нее в контексте вызывающего кода. При этом память может резервироваться заранее, независимо от того, будет ли фактически вызываться функция в процессе выполнения. Т.е. написав, скажем, вот такую рекурсивную функцию</p>

<pre><code>void recursive(unsigned n, const S &amp;s)
{
  if (n &gt; 0)
    recursive(n - 1, s);
  else
    test(s);
}
</code></pre>

<p>вы можете с удивлением обнаружить, что при использовании второго варианта функции <code>test</code> память в стеке для копии <code>s</code> выделяется на <em>каждом</em> уровне рекурсии, в то время как фактически эта память нужна только на самом дне рекурсии. Первый вариант <code>test</code> будет свободен от этого недостатка.</p>

<p>Другие реализации могут поступать более экономно: даже при использовании второго варианта <code>test</code> выполнять резервирование памяти только если функция действительно вызывается.</p>
