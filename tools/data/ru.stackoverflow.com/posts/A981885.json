{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":2,"last_activity_date":1557944158,"creation_date":1557944158,"answer_id":981885,"question_id":981523,"body":"<p>PlaySound - самый примитивный из звуковых API в Windows, кроме того, устаревший лет 10 назад. Параллельное воспроизведение он действительно не поддерживает (видимо, для отслеживания состояния воспроизведения используется какой-то глобальный объект, который каждый раз сбрасывается). PlaySound нормально использовать для воспроизведения коротких звуков из ресурсов или системных звуков, но для файлов лучше взять что-то более продвинутое, хотя бы <a href=\"https://docs.microsoft.com/en-us/windows/desktop/directshow/how-to-play-a-file\" rel=\"nofollow noreferrer\">DirectShow</a>:</p>\n\n<pre><code>#include &lt;windows.h&gt;\n#include &lt;Dshow.h&gt;\n#include &lt;stdio.h&gt;\n\n#pragma comment( lib, \"winmm.lib\" )\n#pragma comment( lib, \"Strmiids.lib\" )\n\nvoid PlaySoundNew_Impl(const TCHAR* file){ //реализация воспроизведения файла с использованием DirectShow\n\n    IGraphBuilder *pGraph = NULL;\n    IMediaControl *pControl = NULL;\n    IMediaEvent   *pEvent = NULL;       \n\n    // Create the filter graph manager and query for interfaces.\n    HRESULT hr = CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER, \n                        IID_IGraphBuilder, (void **)&amp;pGraph);\n    if (FAILED(hr))\n    {\n        printf(\"ERROR - Could not create the Filter Graph Manager.\");\n        return;\n    }\n\n    hr = pGraph-&gt;QueryInterface(IID_IMediaControl, (void **)&amp;pControl);\n    hr = pGraph-&gt;QueryInterface(IID_IMediaEvent, (void **)&amp;pEvent);\n\n    // Build the graph. \n    hr = pGraph-&gt;RenderFile(file, NULL);\n    if (SUCCEEDED(hr))\n    {\n        // Run the graph.\n        hr = pControl-&gt;Run();\n        if (SUCCEEDED(hr))\n        {\n            // Wait for completion.\n            long evCode;\n            pEvent-&gt;WaitForCompletion(INFINITE, &amp;evCode);                       \n        }\n    }\n    else printf(\"RenderFile error 0x%x\",(UINT)hr);\n\n    pControl-&gt;Release();\n    pEvent-&gt;Release();\n    pGraph-&gt;Release();\n}\n\nDWORD WINAPI PlaySoundNew_ThreadProc(LPVOID lpThreadParameter){ //функция для фонового потока\n\n    HRESULT hr = CoInitialize(NULL); //для фонового потока также нужна инициализация COM\n    if (FAILED(hr))\n    {\n        printf(\"ERROR - Could not initialize COM library\");\n        return 1;\n    }\n\n    const TCHAR* file = (const TCHAR*)lpThreadParameter;\n    PlaySoundNew_Impl(file);\n\n    CoUninitialize();\n    return 0;\n}\n\nvoid PlaySoundNew(const TCHAR* file, bool async){ //воспроизведение файла через DirectShow\n\n    if( async == FALSE){ \n        PlaySoundNew_Impl(file); //синхронно        \n    }\n    else{ \n        CreateThread(NULL,0,PlaySoundNew_ThreadProc,(LPVOID)file,0,NULL); //асинхронно\n    }\n}\n\nint main(int argc, char* argv[])\n{   \n    HRESULT hr = CoInitialize(NULL);\n    if (FAILED(hr))\n    {\n        printf(\"ERROR - Could not initialize COM library\");\n        return 1;\n    }\n\n    PlaySoundNew(L\"C:\\\\Music\\\\Sound1.wav\", true);\n    Sleep(2000);\n    PlaySoundNew(L\"C:\\\\Music\\\\Sound2.wav\", true);   \n\n    getchar();\n    CoUninitialize();\n    return 0;\n}\n</code></pre>\n"}