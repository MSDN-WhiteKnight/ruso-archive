{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1557084399,"creation_date":1557084399,"answer_id":978363,"question_id":976992,"body":"<p>Как ни странно, это возможно. Просто вместо <strong>использования</strong> SMTP-сервера нужно <strong>взять на себя</strong> его работу: определить целевой SMTP-сервер путем запроса MX-записи, подключиться к нему и передать данные. Для этого понадобится два вспомогательных класса:</p>\n\n<p>Для получения MX-записей (взято с <a href=\"https://social.msdn.microsoft.com/Forums/vstudio/en-US/89b21138-596f-4efc-8e86-d440d260c41e/how-to-find-smtp-mail-server-name-and-port?forum=csharpgeneral\" rel=\"nofollow noreferrer\">https://social.msdn.microsoft.com/Forums/vstudio/en-US/89b21138-596f-4efc-8e86-d440d260c41e/how-to-find-smtp-mail-server-name-and-port?forum=csharpgeneral</a>)</p>\n\n<pre><code>using System;\nusing System.Collections;\nusing System.Text;\nusing System.Runtime.InteropServices;\n\nnamespace ConsoleTest1\n{\n    public static class Mx\n    {\n\n        [DllImport(\"dnsapi\", EntryPoint = \"DnsQuery_W\", CharSet = CharSet.Unicode, SetLastError = true, ExactSpelling = true)]\n        private static extern int DnsQuery([MarshalAs(UnmanagedType.VBByRefStr)]ref string pszName, QueryTypes wType, QueryOptions options, int aipServers, ref IntPtr ppQueryResults, int pReserved);\n\n        [DllImport(\"dnsapi\", CharSet = CharSet.Auto, SetLastError = true)]\n        private static extern void DnsRecordListFree(IntPtr pRecordList, int FreeType);\n\n        public static string[] GetMXRecords(string domain)\n        {\n\n            IntPtr ptr1 = IntPtr.Zero;\n            IntPtr ptr2 = IntPtr.Zero;\n            MXRecord recMx;\n            if (Environment.OSVersion.Platform != PlatformID.Win32NT)\n            {\n                throw new NotSupportedException();\n            }\n            ArrayList list1 = new ArrayList();\n            int num1 = Mx.DnsQuery(ref domain, QueryTypes.DNS_TYPE_MX, QueryOptions.DNS_QUERY_BYPASS_CACHE, 0, ref ptr1, 0);\n            if (num1 != 0)\n            {\n                throw new ApplicationException(num1.ToString());\n            }\n            for (ptr2 = ptr1; !ptr2.Equals(IntPtr.Zero); ptr2 = recMx.pNext)\n            {\n                recMx = (MXRecord)Marshal.PtrToStructure(ptr2, typeof(MXRecord));\n                if (recMx.wType == 15)\n                {\n                    string text1 = Marshal.PtrToStringAuto(recMx.pNameExchange);\n                    list1.Add(text1);\n                }\n            }\n            Mx.DnsRecordListFree(ptr2, 0);\n            return (string[])list1.ToArray(typeof(string));\n        }\n\n        private enum QueryOptions\n        {\n            DNS_QUERY_ACCEPT_TRUNCATED_RESPONSE = 1,\n            DNS_QUERY_BYPASS_CACHE = 8,\n            DNS_QUERY_DONT_RESET_TTL_VALUES = 0x100000,\n            DNS_QUERY_NO_HOSTS_FILE = 0x40,\n            DNS_QUERY_NO_LOCAL_NAME = 0x20,\n            DNS_QUERY_NO_NETBT = 0x80,\n            DNS_QUERY_NO_RECURSION = 4,\n            DNS_QUERY_NO_WIRE_QUERY = 0x10,\n            DNS_QUERY_RESERVED = -16777216,\n            DNS_QUERY_RETURN_MESSAGE = 0x200,\n            DNS_QUERY_STANDARD = 0,\n            DNS_QUERY_TREAT_AS_FQDN = 0x1000,\n            DNS_QUERY_USE_TCP_ONLY = 2,\n            DNS_QUERY_WIRE_ONLY = 0x100\n        }\n\n        private enum QueryTypes\n        {\n            DNS_TYPE_MX = 15\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        private struct MXRecord\n        {\n            public IntPtr pNext;\n            public string pName;\n            public short wType;\n            public short wDataLength;\n            public int flags;\n            public int dwTtl;\n            public int dwReserved;\n            public IntPtr pNameExchange;\n            public short wPreference;\n            public short Pad;\n        }\n    }\n}\n</code></pre>\n\n<p>Для отправки почты по SMTP (слегка модифицированный класс отсюда: <a href=\"http://www.nullskull.com/articles/20030316.asp\" rel=\"nofollow noreferrer\">http://www.nullskull.com/articles/20030316.asp</a>)</p>\n\n<pre><code>using System;\nusing System.Text;\nusing System.IO;\nusing System.Net.Sockets;\nusing System.Net;\nusing System.Net.NetworkInformation;\nusing System.Web.Mail;\n\nnamespace SMTP\n{\n    /// &lt;summary&gt;\n    /// provides methods to send email via smtp direct to mail server\n    /// &lt;/summary&gt;\n    public class SmtpDirect\n    {\n        /// &lt;summary&gt;\n        /// Get / Set the name of the SMTP mail server\n        /// &lt;/summary&gt;\n        public static string SmtpServer;\n\n        public static StringBuilder output;\n\n        private enum SMTPResponse : int\n        {\n            CONNECT_SUCCESS = 220,\n            GENERIC_SUCCESS = 250,\n            DATA_SUCCESS = 354,\n            QUIT_SUCCESS = 221\n        }\n        public static bool Send(MailMessage message)\n        {\n            output = new StringBuilder(300);\n            IPHostEntry IPhst = Dns.Resolve(SmtpServer);\n            IPEndPoint endPt = new IPEndPoint(IPhst.AddressList[0], 25);\n            Socket s = new Socket(endPt.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n            s.Connect(endPt);\n\n            if (!Check_Response(s, SMTPResponse.CONNECT_SUCCESS))\n            {\n                s.Close();\n                return false;\n            }\n\n            Senddata(s, \"HELO example.com\\r\\n\");\n            output.AppendLine(\"HELO\");\n\n            if (!Check_Response(s, SMTPResponse.GENERIC_SUCCESS))\n            {\n                s.Close();\n                return false;\n            }\n\n            Senddata(s, string.Format(\"MAIL From: {0}\\r\\n\", message.From));\n            output.AppendLine(\"MAIL From\");\n            if (!Check_Response(s, SMTPResponse.GENERIC_SUCCESS))\n            {\n\n                s.Close();\n                return false;\n            }\n\n            string _To = message.To;\n            string[] Tos = _To.Split(new char[] { ';' });\n            foreach (string To in Tos)\n            {\n                Senddata(s, string.Format(\"RCPT TO: {0}\\r\\n\", To));\n                output.AppendLine(\"RCPT TO\");\n                if (!Check_Response(s, SMTPResponse.GENERIC_SUCCESS))\n                {\n                    s.Close();\n                    return false;\n                }\n            }\n\n            if (message.Cc != null)\n            {\n                Tos = message.Cc.Split(new char[] { ';' });\n                foreach (string To in Tos)\n                {\n                    Senddata(s, string.Format(\"RCPT TO: {0}\\r\\n\", To));\n                    output.AppendLine(\"RCPT TO\");\n                    if (!Check_Response(s, SMTPResponse.GENERIC_SUCCESS))\n                    {\n                        s.Close();\n                        return false;\n                    }\n                }\n            }\n\n            StringBuilder Header = new StringBuilder();\n            Header.Append(\"From: \" + message.From + \"\\r\\n\");\n            Tos = message.To.Split(new char[] { ';' });\n            Header.Append(\"To: \");\n            for (int i = 0; i &lt; Tos.Length; i++)\n            {\n                Header.Append(i &gt; 0 ? \",\" : \"\");\n                Header.Append(Tos[i]);\n            }\n            Header.Append(\"\\r\\n\");\n            if (message.Cc != null)\n            {\n                Tos = message.Cc.Split(new char[] { ';' });\n                Header.Append(\"Cc: \");\n                for (int i = 0; i &lt; Tos.Length; i++)\n                {\n                    Header.Append(i &gt; 0 ? \",\" : \"\");\n                    Header.Append(Tos[i]);\n                }\n                Header.Append(\"\\r\\n\");\n            }\n            Header.Append(\"Date: \");\n            Header.Append(DateTime.Now.ToString(\"ddd, d M y H:m:s z\"));\n            Header.Append(\"\\r\\n\");\n            Header.Append(\"Subject: \" + message.Subject + \"\\r\\n\");\n            Header.Append(\"X-Mailer: SMTPDirect v1\\r\\n\");\n            string MsgBody = message.Body;\n            if (!MsgBody.EndsWith(\"\\r\\n\"))\n                MsgBody += \"\\r\\n\";\n            if (message.Attachments.Count &gt; 0)\n            {\n                Header.Append(\"MIME-Version: 1.0\\r\\n\");\n                Header.Append(\"Content-Type: multipart/mixed; boundary=unique-boundary-1\\r\\n\");\n                Header.Append(\"\\r\\n\");\n                Header.Append(\"This is a multi-part message in MIME format.\\r\\n\");\n                StringBuilder sb = new StringBuilder();\n                sb.Append(\"--unique-boundary-1\\r\\n\");\n                sb.Append(\"Content-Type: text/plain\\r\\n\");\n                sb.Append(\"Content-Transfer-Encoding: 7Bit\\r\\n\");\n                sb.Append(\"\\r\\n\");\n                sb.Append(MsgBody + \"\\r\\n\");\n                sb.Append(\"\\r\\n\");\n\n                foreach (object o in message.Attachments)\n                {\n                    MailAttachment a = o as MailAttachment;\n                    byte[] binaryData;\n                    if (a != null)\n                    {\n                        FileInfo f = new FileInfo(a.Filename);\n                        sb.Append(\"--unique-boundary-1\\r\\n\");\n                        sb.Append(\"Content-Type: application/octet-stream; file=\" + f.Name + \"\\r\\n\");\n                        sb.Append(\"Content-Transfer-Encoding: base64\\r\\n\");\n                        sb.Append(\"Content-Dispos\" + \"ition: attachment; filename=\" + f.Name + \"\\r\\n\");\n                        sb.Append(\"\\r\\n\");\n                        FileStream fs = f.OpenRead();\n                        binaryData = new Byte[fs.Length];\n                        long bytesRead = fs.Read(binaryData, 0, (int)fs.Length);\n                        fs.Close();\n                        string base64String = System.Convert.ToBase64String(binaryData, 0, binaryData.Length);\n\n                        for (int i = 0; i &lt; base64String.Length; )\n                        {\n                            int nextchunk = 100;\n                            if (base64String.Length - (i + nextchunk) &lt; 0)\n                                nextchunk = base64String.Length - i;\n                            sb.Append(base64String.Substring(i, nextchunk));\n                            sb.Append(\"\\r\\n\");\n                            i += nextchunk;\n                        }\n                        sb.Append(\"\\r\\n\");\n                    }\n                }\n                MsgBody = sb.ToString();\n            }\n\n            Senddata(s, (\"DATA\\r\\n\"));\n            output.AppendLine(\"DATA\");\n            if (!Check_Response(s, SMTPResponse.DATA_SUCCESS))\n            {\n                s.Close();\n                return false;\n            }\n            Header.Append(\"\\r\\n\");\n            Header.Append(MsgBody);\n            Header.Append(\".\\r\\n\");\n            Header.Append(\"\\r\\n\");\n            Header.Append(\"\\r\\n\");\n            Senddata(s, Header.ToString());\n            if (!Check_Response(s, SMTPResponse.GENERIC_SUCCESS))\n            {\n                s.Close();\n                return false;\n            }\n\n            Senddata(s, \"QUIT\\r\\n\");\n            output.AppendLine(\"QUIT\");\n            Check_Response(s, SMTPResponse.QUIT_SUCCESS);\n            s.Close();\n            return true;\n        }\n        private static void Senddata(Socket s, string msg)\n        {\n            byte[] _msg = Encoding.ASCII.GetBytes(msg);\n            s.Send(_msg, 0, _msg.Length, SocketFlags.None);\n        }\n        private static bool Check_Response(Socket s, SMTPResponse response_expected)\n        {\n            string sResponse;\n            int response;\n            byte[] bytes = new byte[1024];\n            while (s.Available == 0)\n            {\n                System.Threading.Thread.Sleep(100);\n            }\n\n            s.Receive(bytes, 0, s.Available, SocketFlags.None);\n            sResponse = Encoding.ASCII.GetString(bytes);\n\n            sResponse = sResponse.Replace(\"\\0\", \"\");\n            output.Append(sResponse);\n\n            response = Convert.ToInt32(sResponse.Substring(0, 3));\n            if (response != (int)response_expected)\n                return false;\n            return true;\n        }\n\n\n    }\n}\n</code></pre>\n\n<p>Использование:</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Web;\nusing System.Web.Mail;\nusing SMTP;\n\nnamespace ConsoleTest1\n{\n    class Program\n    {       \n        static void Main(string[] args)\n        {\n            string dest = \"pupkin@example.com\";\n            string[] elems = dest.Split(\"@\".ToCharArray());\n            string[] arr = Mx.GetMXRecords(elems[1]);\n\n            string s = \"\";\n            foreach (string x in arr) s += x + Environment.NewLine;\n            Console.WriteLine(\"MX records:\" + Environment.NewLine + s);\n\n            MailMessage msg = new MailMessage();\n            msg.To = dest;\n            msg.From = \"pupkin@example.com\";\n            msg.Subject = \"Hello, world\";\n            msg.Body = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\";\n            SmtpDirect.SmtpServer = arr[0];\n\n            SmtpDirect.Send(msg);\n            Console.WriteLine(SmtpDirect.output.ToString());\n\n            Console.ReadKey();\n        }\n\n    }\n}\n</code></pre>\n\n<p>Недостаток в том, что отправленное таким образом письмо гарантированно попадет в спам, а также рядом с адресом отправителя будет отображаться предупреждение, что он \"подделан\".</p>\n"}