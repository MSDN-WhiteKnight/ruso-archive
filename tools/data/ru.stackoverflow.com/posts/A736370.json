{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":4,"last_activity_date":1509038182,"last_edit_date":1509038182,"creation_date":1509037679,"answer_id":736370,"question_id":472263,"body":"<p>VID и PID для USB Hub можно определить разбором его <a href=\"https://docs.microsoft.com/en-us/windows-hardware/drivers/install/standard-usb-identifiers\" rel=\"nofollow noreferrer\">Hardware ID</a>. Hardware ID можно получить с помощью функции <a href=\"https://msdn.microsoft.com/en-us/library/windows/hardware/ff551967(v=vs.85).aspx\" rel=\"nofollow noreferrer\">SetupDiGetDeviceRegistryProperty</a> (Setup API). Функция возвращает несколько значений, нужно взять первое с вхождением подстрок VID/PID. Для корневого концентратора формат строки выглядит так:</p>\n\n<blockquote>\n  <p>USB\\ROOT_HUB30&amp;VID8086&amp;PID8C31&amp;REV0005</p>\n</blockquote>\n\n<p>Пример кода на c++ для вывода symbolic link, названия, VID и PID для всех USB Hub-ов; основан на <a href=\"https://stackoverflow.com/a/36728329/8674428\">этом ответе</a>.</p>\n\n<pre><code>#pragma comment(lib,\"Setupapi.lib\")\n\n#include &lt;Windows.h&gt;\n#include &lt;Setupapi.h&gt;\n#include &lt;winusb.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;Devpkey.h&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;memory&gt;\n#include &lt;strsafe.h&gt;\n\n\nvoid ErrorMes(LPTSTR lpszFunction) \n{ \n    // Retrieve the system error message for the last-error code\n\n    LPVOID lpMsgBuf;\n    LPVOID lpDisplayBuf;\n    DWORD dw = GetLastError(); \n\n    FormatMessage(\n        FORMAT_MESSAGE_ALLOCATE_BUFFER | \n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,\n        dw,\n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n        (LPTSTR) &amp;lpMsgBuf,\n        0, NULL );\n\n    // Display the error message \n\n    lpDisplayBuf = (LPVOID)LocalAlloc(LMEM_ZEROINIT, \n        (lstrlen((LPCTSTR)lpMsgBuf) + lstrlen((LPCTSTR)lpszFunction) + 40) * sizeof(TCHAR)); \n    wprintf(L\"%s failed with error %d: %s\", \n        lpszFunction, dw, lpMsgBuf);     \n\n    LocalFree(lpMsgBuf);\n    LocalFree(lpDisplayBuf);\n\n}\n\n\nint main()\n{\n    setlocale(LC_ALL,\"Russian\");\n\n    GUID guid;\n\n\n    HRESULT hr = CLSIDFromString(L\"{F18A0E88-C30C-11D0-8815-00A0C906BED8}\", (LPCLSID)&amp;guid);//USB Hub\n\n    HDEVINFO deviceInfoHandle = SetupDiGetClassDevs(&amp;guid, 0, 0, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);\n\n    if (deviceInfoHandle != INVALID_HANDLE_VALUE)\n    {\n        int deviceIndex = 0;\n        while (true)\n        {\n            SP_DEVICE_INTERFACE_DATA deviceInterface = { 0 };\n            deviceInterface.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);\n\n            //перечисление всех интерфейсов USB Hub\n            if (SetupDiEnumDeviceInterfaces(deviceInfoHandle, 0, &amp;guid, deviceIndex, &amp;deviceInterface))\n            {\n                DWORD cbRequired = 0;\n\n                SetupDiGetDeviceInterfaceDetail(deviceInfoHandle, &amp;deviceInterface, 0, 0, &amp;cbRequired, 0);\n                if (ERROR_INSUFFICIENT_BUFFER == GetLastError())\n                {\n                    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceInterfaceDetail = \n                        (PSP_DEVICE_INTERFACE_DETAIL_DATA)(new char[cbRequired]);\n                    memset(deviceInterfaceDetail, 0, cbRequired);\n                    deviceInterfaceDetail-&gt;cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);\n\n                    if (!SetupDiGetDeviceInterfaceDetail(deviceInfoHandle, &amp;deviceInterface, deviceInterfaceDetail, \n                        cbRequired, &amp;cbRequired, 0))\n                    {\n                        deviceIndex++;\n                        continue;\n                    }\n\n                    // Initialize the structure before using it.\n                    memset(deviceInterfaceDetail, 0, cbRequired);\n                    deviceInterfaceDetail-&gt;cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);\n\n                    // Call the API a second time to retrieve the actual\n                    // device path string.\n                    BOOL status = SetupDiGetDeviceInterfaceDetail(\n                        deviceInfoHandle,  // Handle to device information set\n                        &amp;deviceInterface,     // Pointer to current node in devinfo set\n                        deviceInterfaceDetail,   // Pointer to buffer to receive device path\n                        cbRequired,   // Length of user-allocated buffer\n                        &amp;cbRequired,  // Pointer to arg to receive required buffer length\n                        NULL);        // Not interested in additional data\n\n                    wprintf(deviceInterfaceDetail-&gt;DevicePath);//вывод symbolic link\n                    wprintf(L\"\\n\");\n\n                    //получение информации о устройстве\n                    DEVPROPTYPE dpt=0;\n                    wchar_t buffer[1000]=L\"\";\n                    DWORD RequiredSize = 0;\n                    SP_DEVINFO_DATA devinfo = { 0 };\n                        devinfo.cbSize = sizeof(SP_DEVINFO_DATA);\n\n                    BOOL success = SetupDiEnumDeviceInfo(deviceInfoHandle, deviceIndex, &amp;devinfo);\n                    if(success==FALSE){ErrorMes(L\"SetupDiEnumDeviceInfo\");}\n\n                    BOOL res;\n\n                    //name\n                    res=SetupDiGetDeviceProperty(deviceInfoHandle,&amp;devinfo,\n                        &amp;DEVPKEY_Device_DeviceDesc,&amp;dpt,(PBYTE)buffer,1000,NULL,0);\n\n                    printf(\"Name: \");\n                    if(res==FALSE)ErrorMes(L\"SetupDiGetDeviceProperty\");\n                    else wprintf(buffer);\n                    printf(\"\\n\");\n\n                    //hardware id\n                    DWORD regType = REG_MULTI_SZ;\n                    unsigned char* ptr = new unsigned char[2048];\n                    if (SetupDiGetDeviceRegistryProperty(deviceInfoHandle, &amp;devinfo, SPDRP_HARDWAREID, &amp;regType, \n                        ptr, 2048, &amp;RequiredSize))\n                    {\n                        wchar_t* input=reinterpret_cast&lt;wchar_t*&gt;(ptr);\n                        wchar_t sep[]=L\"&amp;\\\\\";\n                        wchar_t vid[5]=L\"\";\n                        wchar_t pid[5]=L\"\";\n                        bool found=false;\n\n                        /*проходим по всем элементам REG_MULTI_SZ*/\n                        while(true){\n\n                            wchar_t* tok=NULL;\n                            wchar_t* pos=NULL;\n\n                            //разбор hardware id\n                            tok=wcstok(input,sep);\n                            while( tok != NULL )  \n                            {                       \n                                pos=wcsstr(tok,L\"VID\");\n\n                                if(pos!=NULL){                          \n                                    pos+=3;\n                                    if(pos[0]==L'_')pos++;\n                                    StringCchCopy(vid,5,pos);   \n                                    found=true;\n                                }\n\n                                pos=wcsstr(tok,L\"PID\");\n\n                                if(pos!=NULL){                          \n                                    pos+=3;\n                                    if(pos[0]==L'_')pos++;\n                                    StringCchCopy(pid,5,pos);\n                                    found=true;\n                                }\n\n                                tok = wcstok( NULL, sep ); \n                            }//конец разбора hardware id\n\n                            if(found!=false)break;\n\n                            input+=wcslen(input)+1;//переход к следующему элементу REG_MULTI_SZ\n\n                            if(wcscmp(input,L\"\")==0)break;\n                        }//конец прохода\n\n                        if(found!=false)\n                        {\n                            wprintf( L\"VID: %s\\n\", vid );\n                            wprintf( L\"PID: %s\\n\", pid );                           \n                        }\n                        else \n                        {\n                            wprintf( L\"Not found\\n\");\n                        }\n\n                    }\n                    else ErrorMes(L\"SetupDiGetDeviceRegistryProperty\");\n\n                    delete[] ptr;\n                    delete[] deviceInterfaceDetail;\n\n                    printf(\"\\n\");                   \n\n                }\n            }\n            else\n            {\n                break;\n            }\n\n            ++deviceIndex;\n        }\n\n        SetupDiDestroyDeviceInfoList(deviceInfoHandle);\n    }\n\n\n    system(\"PAUSE\");\n    return 0;\n}\n</code></pre>\n"}