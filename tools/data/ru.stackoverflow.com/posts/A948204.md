---
title: "Answer 948204"
se.owner.user_id: 240512
se.owner.display_name: "MSDN.WhiteKnight"
se.owner.link: "https://ru.stackoverflow.com/users/240512/msdn-whiteknight"
se.answer_id: 948204
se.question_id: 906663
se.post_type: answer
se.score: 9
se.is_accepted: False
---
<blockquote>
  <p>Получается, методы расширения — это опасная штука?</p>
</blockquote>

<p>Да, это несомненно так. Методы расширения — грубый хак, нарушающий принципы объектно-ориентированного программирования, и помимо проблемы неконтролируемого скрытия членами расширяемого класса они также страдают от проблемы конфликтов между самими собой (ведь разные библиотеки могут создавать методы расширения для одного класса). Чрезмерно использовать их не стоит. </p>

<p><a href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/extension-methods" rel="nofollow noreferrer">Framework Design Guidelines</a> явно не рекомендуют это:</p>

<blockquote>
  <p><strong>AVOID</strong> frivolously defining extension methods, especially on types you don’t own. </p>
</blockquote>

<p>Там же упоминают два случая, когда использование методов расширения оправдано:</p>

<ul>
<li><p>Добавление какого-либо функционала во все типы, реализующие определенный интерфейс. В этом случае опасность несколько ниже, ведь в интерфейсы обычно не добавляют новые методы (так как это требовало бы переписывания кода кучи классов, которые уже реализуют этот интерфейс). Именно таким образом работает LINQ.</p></li>
<li><p>Методы, завязанные на типы, определенные в вашем собственном коде. Допустим, вы создаете метод расширения к классу <code>String</code>, принимающий аргумент типа <code>Person</code>, определенного в вашем проекте. В этом случае описанного конфликта также не будет, ведь даже если MS добавят новый метод в класс <code>String</code>, он точно никак не будет использовать класс из вашего кода.  </p></li>
</ul>

<p>К сожалению, следование этим рекомендациям все равно полностью не решает проблемы, так как остаются конфликты между самими методами расширений из разных библиотек. Именно <a href="https://github.com/morelinq/MoreLINQ/issues/351" rel="nofollow noreferrer">с этой проблемой</a> столкнулись разработчики библиотеки MoreLinq. </p>

<p>Конечно, Framework Design Guidelines — это рекомендации для разработчиков публичных API библиотек, а не любого кода в приложениях. Но сути это мало меняет, так как нужно стремиться делать любой код пригодным к повторному использованию. Проекты имеют тенденцию расти, разделяться и т.п; какой-то код, который раньше использовался только в одном проекте, впоследствии захочется вынести в общую библиотеку. Поэтому эти рекомендации во многом можно распространить и на код приложений.</p>

<hr>

<p><strong>Обновление.</strong> В C# 8.0 появилась новая возможность - <a href="https://docs.microsoft.com/ru-ru/dotnet/csharp/tutorials/default-interface-methods-versions" rel="nofollow noreferrer">методы интерфейсов по умолчанию</a>. Благодаря ей, библиотеки могут добавлять новые методы в интерфейс, не нарушая обратной совместимости. Поэтому, для методов расширения интерфейсов теперь также существует проблема потенциального скрытия методом расширяемого интерфейса. </p>

<p>С другой стороны, это нововведение уменьшает необходимость писать методы расширения для добавления функционала в интерфейсы, так как этот функционал можно теперь реализовать в виде методов по умолчанию.</p>
