---
title: "Answer 972593"
se.owner.user_id: 184217
se.owner.display_name: "Alexander Petrov"
se.owner.link: "https://ru.stackoverflow.com/users/184217/alexander-petrov"
se.answer_id: 972593
se.question_id: 969870
se.post_type: answer
se.score: 1
se.is_accepted: False
---
<blockquote>
  <p>есть список объектов, который я хочу сохранить в файл<br>
  сколько памяти потребуется для текстового файла, сколько для бинарного и сколько для xml-файла</p>
</blockquote>

<p>Допустим, имеется следующий класс:</p>

<pre><code>public class Equipment
{
    //public string Department { get; set; }
    //public string Name { get; set; }
    public int amount { get; set; }
    public double unitCost { get; set; }
    public double totalCost { get; set; }
}
</code></pre>

<p>И записывается он в бинарный файл с помощью <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter?view=netframework-4.8" rel="nofollow noreferrer">BinaryWriter</a>:</p>

<pre><code>binaryWriter.Write(equipment.amount);
binaryWriter.Write(equipment.unitCost);
binaryWriter.Write(equipment.totalCost);
</code></pre>

<p>То есть данные идут вплотную, без дополнительной метаинформации.</p>

<p>Размер примитивных типов можно получить оператором <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sizeof" rel="nofollow noreferrer">sizeof</a>. Следовательно, размер одного экземпляра и всего списка вычисляется следующим образом:</p>

<pre><code>int equipmentSize = sizeof(int) + sizeof(double) + sizeof(double);
int listSize = equipmentSize * equipmentList.Count;
</code></pre>

<p>O(1) - эффективнее некуда.</p>

<hr>

<p>Однако, если раскомментировать строковые свойства, то ситуация усложнится.</p>

<p>Длина строки в байтах зависит от используемой кодировки (<code>BinaryWriter</code> может использовать любую). Следовательно, нужно вычислять эту длину.</p>

<pre><code>int nameSize = encoding.GetByteCount(equipment.Name);
int departmentSize = encoding.GetByteCount(equipment.Department);
</code></pre>

<p>где <code>encoding</code> - та же кодировка, что используется при записи в файл.</p>

<p>Естественно, длина строк у разных объектов в списке может быть разная, поэтому придётся сделать проход по всему списку и добавить сумму длин в <code>listSize</code>. Получаем O(n).</p>

<p>Дело осложняется тем, что при записи строк в файл <code>BinaryWriter</code> предваряет значение записываемой строки её длиной. Это значение тоже нужно приплюсовать к итоговому размеру. Причём длина рассчитывается как 7-bit encoded. Подробнее <a href="https://stackoverflow.com/q/47409296/5045688">здесь</a> и <a href="https://stackoverflow.com/q/44401928/5045688">здесь</a>.</p>

<hr>

<p>Вычисление размера текстового файла зависит от используемой кодировки и от формата. Его сделать относительно несложно используя метод <code>Encoding.GetByteCount</code>.</p>

<p>XML-файл по сути является текстовым. Аналогично, его размер можно рассчитать аналитически, без самой записи. Но возникает много проблем с предварительным определением его формата: с индентацией и без, с переносом атрибутов на новую строку или без переноса и многое другое.</p>

<p>При желании, можно заморочиться ручным вычислением. Но это окупится лишь в том случае, если нужно рассчитывать размеры большого количества файлов/потоков большого размера. А главное, код в ответе MSDN.WhiteKnight именно это и делает.</p>
