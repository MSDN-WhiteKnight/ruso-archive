---
title: "Answer 810044"
se.owner.user_id: 10105
se.owner.display_name: "VladD"
se.owner.link: "https://ru.stackoverflow.com/users/10105/vladd"
se.answer_id: 810044
se.question_id: 809884
se.post_type: answer
se.score: 14
se.is_accepted: True
---
<p>Смотрите, у вас на самом деле довольно сложное задание. Но в современном C# есть инструменты, которые облегчат вам его. Например, вы можете воспользоваться Roslyn API.</p>

<p>Давайте напишем простой пример, на основе которого вы сможете добавлять нужную функциональность.</p>

<p>Итак, для начала создадим консольный проект на C#, назовём его HelloWorld, и положим туда такой вот код:</p>

<pre><code>using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            string[] strings = { "Hello ", "world" };
            foreach (var s in strings)
                Console.Write(s);
            Console.WriteLine();
        }
    }
}
</code></pre>

<p>Этот проект мы будем использовать как тестовый для нашего анализатора.
Целью нашего анализатора будет найти, что переменная <code>s</code> на самом деле имеет тип <code>string</code>.</p>

<p>Создадим проект самого анализатора. Для этого поставьте Roslyn SDK через Visual Studio Installer:</p>

<p><a href="https://i.stack.imgur.com/VFKgv.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/VFKgv.png" alt="Roslyn SDK, без него никак в нашем мире"></a></p>

<p>Теперь, в Visual Studio появится проект типа «Stand-Alone Code Analysis Tool». Создаём его.</p>

<p><a href="https://i.stack.imgur.com/iMgoR.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/iMgoR.png" alt="и проект тоже я сломал?"></a></p>

<p>Затем, зайдём в Dependencies → Manage NuGet Packages, обязательно обновим пакеты до последней версии и доустановим Microsoft.Tpl.DataFlow (без него у меня не работает, и это, кажется, известный баг).</p>

<p><a href="https://i.stack.imgur.com/w0xOV.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/w0xOV.png" alt="Отака фигня, малята"></a></p>

<p>Теперь, собственно наш анализатор.</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Symbols;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.MSBuild;
using Microsoft.CodeAnalysis.Text;

namespace CodeAnalyzer
{
    class Program
    {
        static async Task Main(string[] args)
        {
            var workspace = MSBuildWorkspace.Create();
            // подправьте путь на путь к вашему solution'у
            var solution = await workspace.OpenSolutionAsync(@"D:\HelloWorld.sln");
            // у нас только один проект
            var project = solution.Projects.Single();
            var compilation = await project.GetCompilationAsync();

            // для каждого из файлов в проекте у нас отдельное синтаксическое дерево
            // даже в пустом проекте их несколько, например, AssemblyInfo.cs
            foreach (var syntaxTree in compilation.SyntaxTrees)
            {
                var root = await syntaxTree.GetRootAsync();
                // создаём семантический анализатор
                var model = compilation.GetSemanticModel(syntaxTree);
                // получаем все типы переменных
                foreach (var type in GetVariableTypes(root))
                {
                    // спрашиваем у анализатора, что это за тип
                    var typeSymbol = (ITypeSymbol)model.GetSymbolInfo(type).Symbol;
                    // проверяем, не строка ли это
                    if (typeSymbol.Name == "String" &amp;&amp;
                        typeSymbol.ContainingNamespace?.Name == "System" &amp;&amp;
                        typeSymbol.ContainingAssembly?.Name == "mscorlib")
                    {
                        // если да, выдаём положение этой строки в исходниках
                        var position = type.GetLocation().GetLineSpan();
                        Console.WriteLine($"String is used, location = {position}");
                    }
                }
            }
        }

        // этот вспомогательный метод получает типы всех локальных переменных
        static IEnumerable&lt;TypeSyntax&gt; GetVariableTypes(SyntaxNode root)
        {
            // получаем декларации переменных
            var localVariableTypes =
                    root.DescendantNodes()
                        .OfType&lt;VariableDeclarationSyntax&gt;()
                        .Select(decl =&gt; decl.Type);
            // не забываем foreach, он почему-то отдельно
            var foreachVariableTypes =
                    root.DescendantNodes()
                        .OfType&lt;ForEachStatementSyntax&gt;()
                        .Select(decl =&gt; decl.Type);
            return localVariableTypes.Concat(foreachVariableTypes);
        }
    }
}
</code></pre>

<p>Запускаем на нашем тестовом проекте, получаем:</p>

<blockquote>
<pre><code>String is used, location = D:\HelloWorld\Program.cs: (9,21)-(9,24)
</code></pre>
</blockquote>

<p>Литература:</p>

<ul>
<li><a href="https://github.com/dotnet/roslyn/wiki/Getting-Started-C%23-Semantic-Analysis" rel="nofollow noreferrer">Документация на семантический анализ Roslyn</a>.</li>
<li><a href="https://sharplab.io/#v2:EYLgtghgzgLgpgJwDQxNGAfAAgBgARYCMA3ALABQFAdhGHFAA4QDGceAEnADZcD2A6rwRcAJhQDeFPNIIAmAoQDsUmZPIyNCgGwEALAoAcACiI4A2gF08EBAHMoAShWa8aly9OWFOKHgC8rngARJw8vMFIwQDuQqJBeAC+ZOruGgBmQnAsABZ4RgBuNni+AJZU3o7OqZoAwrxUULxccAB0/Agl8EaOydUyRACcRg697glV4+QJQA" rel="nofollow noreferrer">А здесь можно посмотреть синтаксическое дерево</a>.</li>
</ul>

<hr>

<p>Небольшое дополнение. Вы не можете узнать, какие типы используются в классе, по одному только тексту файла. Например, если у вас в соседнем файле есть такое определение:</p>

<pre><code>namespace HelloWorld
{
    struct String
    {
        public static implicit operator String(System.String s) =&gt; default;
    }
}
</code></pre>

<p>то ваш код</p>

<pre><code>String s = "";
Console.WriteLine(s.GetType());
</code></pre>

<p>выдаст не <code>System.String</code>, а <code>HelloWorld.String</code>. Именно поэтому для правильного анализа нужен не текст, а весь проект.</p>
