---
title: "Answer 912842"
se.owner.user_id: 206435
se.owner.display_name: "ヒミコ"
se.owner.link: "https://ru.stackoverflow.com/users/206435/%e3%83%92%e3%83%9f%e3%82%b3"
se.answer_id: 912842
se.question_id: 911112
se.post_type: answer
se.score: 0
se.is_accepted: True
---
<p>Путем некоторых манипуляций удалось выяснить, в обязательном порядке стоит соблюдать следующие правила:</p>

<ol>
<li><p>Наследуемый объект должен переопределять декларацию интерфейса от которого наследуется, перед методами текущего метода, т.е. до их объявлений. (Спасибо за подсказку <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">@MSDN.WhiteKnight</a>).</p></li>
<li><p>Интерфейс наследник в обязательном порядке должен иметь атрибут <code>[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]</code>, иначе будем иметь проблемы с доступом к памяти.</p></li>
<li><p>Интерфейс наследник наследуется от интерфейса который для него является базовым лишь для удобства работы с данными интерфейсами.</p></li>
</ol>

<p>Таким образом, базовый интерфейс к примеру в данном случае это <code>IDXGIObject</code> выглядит так:</p>

<pre><code>/// &lt;summary&gt;
///     An IDXGIObject interface is a base interface for all DXGI objects; IDXGIObject supports associating caller-defined
///     (private data) with an object and retrieval of an interface to the parent object.
/// &lt;/summary&gt;
[Guid("aec22fb8-76f3-4639-9be0-28eb43a67a2e")]
[ComImport]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
public interface IDXGIObject
{
    /// &lt;summary&gt;
    ///     Sets an IUnknown interface as private data; this associates application-defined data with the object.
    /// &lt;/summary&gt;
    [PreserveSig]
    HResult SetPrivateData(ref Guid name, uint dataSize, IntPtr dataPtr);

    /// &lt;summary&gt;
    ///     Set an interface in the object's private data.
    /// &lt;/summary&gt;
    [PreserveSig]
    HResult SetPrivateDataInterface(ref Guid name,
        [MarshalAs(UnmanagedType.IUnknown)] object unknownInterfaceObject);

    /// &lt;summary&gt;
    ///     Get a pointer to the object's data.
    /// &lt;/summary&gt;
    [PreserveSig]
    HResult GetPrivateData(ref Guid name, out int dataSize, out IntPtr dataPtr);

    /// &lt;summary&gt;
    ///     Gets the parent of the object.
    /// &lt;/summary&gt;
    [PreserveSig]
    HResult GetParent(ref Guid rIId, out object pParent);
}
</code></pre>

<p>Далее от него к примеру наследуется <code>IDXGIFactory</code> определение необходимо задавать строго вот так:</p>

<pre><code>/// &lt;inheritdoc /&gt;
/// &lt;summary&gt;
///     An &lt;see cref="T:Himiko.DXGI.Interfaces.IDXGIFactory" /&gt; interface implements methods for generating DXGI objects (which handle fullscreen
///     transitions).
/// &lt;/summary&gt;
[Guid("7b7166ec-21c7-44ae-b21a-c9ae321ae369")]
[ComImport]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
public interface IDXGIFactory : IDXGIObject
{
    /// &lt;summary&gt;
    ///     Sets an IUnknown interface as private data; this associates application-defined data with the object.
    /// &lt;/summary&gt;
    [PreserveSig]
    new HResult SetPrivateData(ref Guid name, uint dataSize, IntPtr dataPtr);

    /// &lt;summary&gt;
    ///     Set an interface in the object's private data.
    /// &lt;/summary&gt;
    [PreserveSig]
    new HResult SetPrivateDataInterface(ref Guid name,
        [MarshalAs(UnmanagedType.IUnknown)] object unknownInterfaceObject);

    /// &lt;summary&gt;
    ///     Get a pointer to the object's data.
    /// &lt;/summary&gt;
    [PreserveSig]
    new HResult GetPrivateData(ref Guid name, out int dataSize, out IntPtr dataPtr);

    /// &lt;summary&gt;
    ///     Gets the parent of the object.
    /// &lt;/summary&gt;
    [PreserveSig]
    new HResult GetParent(ref Guid rIId, out object pParent);

    /// &lt;summary&gt;
    ///     Enumerates the adapters (video cards).
    /// &lt;/summary&gt;
    [PreserveSig]
    HResult EnumAdapters(uint numAdapter, [MarshalAs(UnmanagedType.IUnknown)] out object adapter);

    /// &lt;summary&gt;
    ///     Allows DXGI to monitor an application's message queue for the alt-enter key sequence (which causes the application
    ///     to switch from windowed to fullscreen or vice versa).
    /// &lt;/summary&gt;
    [PreserveSig]
    HResult MakeWindowAssociation(IntPtr windowHandle, uint flags);

    /// &lt;summary&gt;
    ///     Get the window through which the user controls the transition to and from fullscreen.
    /// &lt;/summary&gt;
    [PreserveSig]
    HResult GetWindowAssociation(out IntPtr outHandleWindow);

    /// &lt;summary&gt;
    ///     Creates a swap chain.
    /// &lt;/summary&gt;
    [PreserveSig]
    HResult CreateSwapChain(object iUnknown, ref DxgiSwapChainDesc swapChainDesc,
        [MarshalAs(UnmanagedType.IUnknown)] out object dxgiSwapChainObject);

    /// &lt;summary&gt;
    ///     Create an adapter interface that represents a software adapter.
    /// &lt;/summary&gt;
    [PreserveSig]
    HResult CreateSoftwareAdapter(IntPtr moduleHandle, out IntPtr outPtr);
}
</code></pre>

<p>Все проблемы себя исчерпали, и код стал работать так как должен.</p>
