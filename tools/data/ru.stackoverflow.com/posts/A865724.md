---
title: "Answer 865724"
se.owner.user_id: 10105
se.owner.display_name: "VladD"
se.owner.link: "https://ru.stackoverflow.com/users/10105/vladd"
se.answer_id: 865724
se.question_id: 865721
se.post_type: answer
se.score: 14
se.is_accepted: False
---
<p>Согласно <a href="https://docs.microsoft.com/ru-ru/dotnet/api/system.math.pow?view=netframework-4.7.1#remarks" rel="noreferrer">документации</a>, при конечном отрицательном основании и конечном нецелом показателе результат равен <code>NaN</code>. Это значит, что <code>Math.Pow</code> ведёт себя не совсем так, как стандартная математическая степень, и вам придётся самим обрабатывать случай отрицательного основания.</p>

<hr>

<p>Почему так сделано? Думаю, потому, что дроби наподобие 1/3 нельзя представить точно значением типа <code>double</code>. Поскольку в случае чётного знаменателя результат получается комплексным, мы видим, что малая ошибка в показатели степени ведёт к большой ошибке в результате. Поэтому разумным было бы просто не пытаться подсчитать результат для таких вот случаев.</p>

<hr>

<p>Хорошо, а как решать задачу по извлечению корня целой степени? Ну просто анализируйте знак.</p>

<pre><code>int rootpower = 3;
double value = -8;

int sign = Math.Sign(value);
double absRoot = Math.Pow(Math.Abs(value), 1.0/rootpower);

if (rootpower % 2 == 0 &amp;&amp; sign == -1)
{
    Complex root = Complex.ImaginaryOne * absRoot;
    // результат комплексный, работайте с ним
}
else
{
    double root = sign * absRoot;
    // результат действительный, работайте с ним
}
</code></pre>
