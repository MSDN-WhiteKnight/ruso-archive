---
title: "Наследование ComObject интерфейсов и назначение аттрибутов"
se.owner.user_id: 206435
se.owner.display_name: "ヒミコ"
se.owner.link: "https://ru.stackoverflow.com/users/206435/%e3%83%92%e3%83%9f%e3%82%b3"
se.link: "https://ru.stackoverflow.com/questions/911112/%d0%9d%d0%b0%d1%81%d0%bb%d0%b5%d0%b4%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-comobject-%d0%b8%d0%bd%d1%82%d0%b5%d1%80%d1%84%d0%b5%d0%b9%d1%81%d0%be%d0%b2-%d0%b8-%d0%bd%d0%b0%d0%b7%d0%bd%d0%b0%d1%87%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b0%d1%82%d1%82%d1%80%d0%b8%d0%b1%d1%83%d1%82%d0%be%d0%b2"
se.question_id: 911112
se.post_type: question
se.score: 4
---
<p>Есть ли необходимость повторно указывать аттрибут типа интерфейса <code>Com</code>, если он наследуется от другого <code>Com</code> интерфейса, в котором уже был задан тип?</p>

<p>Пример:</p>

<pre><code>[ComImport]
[Guid("aec22fb8-76f3-4639-9be0-28eb43a67a2e")]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
public interface IDXGIObject
{
    long SetPrivateData([In] ref Guid name, [In] uint dataSize, IntPtr dataPtr);

    long SetPrivateDataInterface([In] ref Guid name, [In] [MarshalAs(UnmanagedType.IUnknown)]
        object unknownInterfaceObject);

    long GetPrivateData([In] ref Guid name, out int dataSize, out IntPtr dataPtr);

    long GetParent([In] ref Guid rIId, [Out] out object pParent);
}
</code></pre>

<p>Далее, его наследником будет <code>IDXGIFactory</code>:</p>

<pre><code>/// &lt;inheritdoc cref="IDXGIObject"/&gt; /&gt;
/// &lt;summary&gt;
///     An IDXGIFactory interface implements methods for generating DXGI objects (which handle fullscreen transitions).
/// &lt;/summary&gt;
[ComImport]
[Guid("7b7166ec-21c7-44ae-b21a-c9ae321ae369")]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
public interface IDXGIFactory : IDXGIObject
{
    /// &lt;summary&gt;
    ///     Enumerates the adapters (video cards).
    /// &lt;/summary&gt;
    [PreserveSig]
    HResult EnumAdapters(uint numAdapter, [MarshalAs(UnmanagedType.IUnknown)] out object adapter);

    /// &lt;summary&gt;
    ///     Allows DXGI to monitor an application's message queue for the alt-enter key sequence (which causes the application
    ///     to switch from windowed to fullscreen or vice versa).
    /// &lt;/summary&gt;
    [PreserveSig]
    HResult MakeWindowAssociation(IntPtr windowHandle, uint flags);

    /// &lt;summary&gt;
    ///     Get the window through which the user controls the transition to and from fullscreen.
    /// &lt;/summary&gt;
    [PreserveSig]
    HResult GetWindowAssociation(out IntPtr outHandleWindow);

    /// &lt;summary&gt;
    ///     Creates a swap chain.
    /// &lt;/summary&gt;
    [PreserveSig]
    HResult CreateSwapChain(IntPtr lpIUnknown, IntPtr ptr, out IntPtr outPtr);

    /// &lt;summary&gt;
    ///     Create an adapter interface that represents a software adapter.
    /// &lt;/summary&gt;
    [PreserveSig]
    HResult CreateSoftwareAdapter(IntPtr moduleHandle, out IntPtr outPtr);
}
</code></pre>

<p>Есть ли необходимость вновь писать аттрибут</p>

<pre><code>[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
</code></pre>

<p>для интерфейса наследника, если он тоже по сути является <code>IUnknown</code>?</p>
