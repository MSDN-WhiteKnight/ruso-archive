---
title: "OpenALL С++ Запись и отдельно Проигрывание"
se.owner.user_id: 270698
se.owner.display_name: "Юрій Писанка"
se.owner.link: "https://ru.stackoverflow.com/users/270698/%d0%ae%d1%80%d1%96%d0%b9-%d0%9f%d0%b8%d1%81%d0%b0%d0%bd%d0%ba%d0%b0"
se.link: "https://ru.stackoverflow.com/questions/901703/openall-%d0%a1-%d0%97%d0%b0%d0%bf%d0%b8%d1%81%d1%8c-%d0%b8-%d0%be%d1%82%d0%b4%d0%b5%d0%bb%d1%8c%d0%bd%d0%be-%d0%9f%d1%80%d0%be%d0%b8%d0%b3%d1%80%d1%8b%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5"
se.question_id: 901703
se.post_type: question
se.score: 1
---
<p>Пытаюсь научиться обрабатывать записанный с микрофона звук, нашёл пример, но там всё склеено, и непонятно что за что отвечает.</p>

<p>Мне нужно </p>

<ol>
<li><p>Записать допустим 3 секунды</p></li>
<li><p>Получить доступ к массиву с записанными данными, проанализировать или даже изменить</p></li>
<li><p>Проиграть запись, сохранённую в  массиве</p></li>
</ol>

<p>Вот пример, о котором писал.</p>

<pre><code>    //#include &lt;unistd.h&gt;
#include &lt;AL/al.h&gt; 
#include &lt;AL/alc.h&gt; 
#include &lt;time.h&gt;
#include &lt;ctime&gt; 
#pragma comment (lib,"OpenAL32.lib")
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
//#include &lt;windows.h&gt;
//#include &lt;al.h&gt;
//#include &lt;alc.h&gt;


using namespace std;
int main()
{




ALCdevice *dev[2];
ALCcontext *ctx;
ALuint source, buffers[3];
char data[5000];
ALuint buf;
ALint val;

    float ttotal;
    unsigned int ccount;
    long int c1ount;
    c1ount =0;

dev[0] = alcOpenDevice(NULL);
ctx = alcCreateContext(dev[0], NULL);
alcMakeContextCurrent(ctx);

alGenSources(1, &amp;source);
alGenBuffers(3, buffers);

/* Setup some initial silent data to play out of the source */
alBufferData(buffers[0], AL_FORMAT_MONO16, data, sizeof(data), 22050);
alBufferData(buffers[1], AL_FORMAT_MONO16, data, sizeof(data), 22050);
alBufferData(buffers[2], AL_FORMAT_MONO16, data, sizeof(data), 22050);
alSourceQueueBuffers(source, 3, buffers);

/* If you don't need 3D spatialization, this should help processing time */
alDistanceModel(AL_NONE); 

dev[1] = alcCaptureOpenDevice(NULL, 22050, AL_FORMAT_MONO16, sizeof(data)/2); //22050 mean 22.050 samples per     second. or 44100 for 44.1 per second.

/* Start playback and capture, and enter the audio loop */
alSourcePlay(source);
alcCaptureStart(dev[1]);    //starts ring buffer

while(1) 
{
    /* Check if any queued buffers are finished */
    alGetSourcei(source, AL_BUFFERS_PROCESSED, &amp;val);
    if(val &lt;= 0)
        continue;

    /* Check how much audio data has been captured (note that 'val' is the
    * number of frames, not bytes) */
    alcGetIntegerv(dev[1], ALC_CAPTURE_SAMPLES, 1, &amp;val);

    /* Read the captured audio */
    alcCaptureSamples(dev[1], data, val);


        //***** Process/filter captured data here *****//


c1ount = c1ount +1;
if(c1ount &gt;= 33){
          break;
         }


        //for (int ii=0;ii&lt;val;++ii) {
        //  data[ii]*=0.1; // Make it quieter
        //}
    //***** end Process/filter captured data here *****//

    /* Pop the oldest finished buffer, fill it with the new capture data,
    then re-queue it to play on the source */
    alSourceUnqueueBuffers(source, 1, &amp;buf);
    alBufferData(buf, AL_FORMAT_MONO16, data, val*2 /* bytes here, not
    frames */, 22050);
    alSourceQueueBuffers(source, 1, &amp;buf);

    /* Make sure the source is still playing */
    alGetSourcei(source, AL_SOURCE_STATE, &amp;val);

    if(val != AL_PLAYING)
    {

        alSourcePlay(source);
    }
}

cout&lt;&lt; "fgggggggg\n";


/* Shutdown and cleanup */
alcCaptureStop(dev[1]);
alcCaptureCloseDevice(dev[1]);

alSourceStop(source);
alDeleteSources(1, &amp;source);
alDeleteBuffers(3, buffers);
alDeleteBuffers(1, &amp;buf);

alcMakeContextCurrent(NULL);
alcDestroyContext(ctx);
alcCloseDevice(dev[0]); 

return 0;
}
</code></pre>

<p>Вот тоже пример, который должен записывать, но почему тут вечный цикл?</p>

<pre><code>    #include &lt;AL/al.h&gt;
#include &lt;AL/alc.h&gt;
#include &lt;iostream&gt;
using namespace std;

#pragma comment(lib,"OpenAL32.lib")

const int SRATE = 44100;
const int SSIZE = 1024;

ALbyte buffer[22050];
ALint sample;

int main(int argc, char *argv[]) {
    alGetError();
    ALCdevice *device = alcCaptureOpenDevice(NULL, SRATE, AL_FORMAT_STEREO16, SSIZE);
    if (alGetError() != AL_NO_ERROR) {
        return 0;
    }
    alcCaptureStart(device);

    while (true) {
        alcGetIntegerv(device, ALC_CAPTURE_SAMPLES, (ALCsizei)sizeof(ALint), &amp;sample);
        alcCaptureSamples(device, (ALCvoid *)buffer, sample);

        // ... do something with the buffer 

        for(int i = 0; i&lt;80;i++)
        {
            cout&lt;&lt;(int)buffer[i]&lt;&lt;' ';
        }
        cout&lt;&lt;"loop s\n";
    }

    alcCaptureStop(device);
    alcCaptureCloseDevice(device);

    return 0;
}
</code></pre>
