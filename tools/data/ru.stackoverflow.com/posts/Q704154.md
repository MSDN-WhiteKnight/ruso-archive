---
title: "Использование Desktop Duplication API"
se.owner.user_id: 238013
se.owner.display_name: "D .Stark"
se.owner.link: "https://ru.stackoverflow.com/users/238013/d-stark"
se.link: "https://ru.stackoverflow.com/questions/704154/%d0%98%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-desktop-duplication-api"
se.question_id: 704154
se.post_type: question
se.score: 5
---
<pre><code>#include "stdafx.h"

#include "stdafx.h"
#include "iostream"

#include "D3D9.h"
#include &lt;Wincodec.h&gt;
#include &lt;chrono&gt;

#include &lt;shellapi.h&gt;
#include &lt;d3d11.h&gt;
#include &lt;dxgi1_2.h&gt;
#include &lt;Atlbase.h&gt;
#include &lt;comdef.h&gt;

#include &lt;windows.h&gt;
#include &lt;shlobj.h&gt;
#include &lt;shellapi.h&gt;
#include &lt;dxgi1_2.h&gt;
#include &lt;d3d11.h&gt;
#include &lt;memory&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

#pragma comment(lib, "D3D11.lib")
#pragma comment(lib, "D3d9.lib")
#pragma comment(lib, "dxgi.lib")

#pragma comment(lib, "gdi32.lib")

using namespace System;

#define EXIT(hr) { if (FAILED(hr)) \
                { Console::WriteLine("Error!"); \
                Console::ReadKey(); return -1; } }

HBITMAP ExtractBitmap(ID3D11Texture2D* d3dtex, ID3D11Device* pDevice) 
{
    HRESULT hr;

    HBITMAP hBitmapTexture = NULL;
    HGDIOBJ hBitmap;

    D3D11_TEXTURE2D_DESC desc;
    ID3D11Texture2D* pNewTexture = NULL;

    D3D11_TEXTURE2D_DESC description;

    d3dtex-&gt;GetDesc(&amp;desc);
    d3dtex-&gt;GetDesc(&amp;description);

    description.BindFlags = 0;
    description.CPUAccessFlags = D3D11_CPU_ACCESS_READ | D3D11_CPU_ACCESS_WRITE;
    description.Usage = D3D11_USAGE_STAGING;

    if (FAILED(pDevice-&gt;CreateTexture2D(&amp;description, NULL, &amp;pNewTexture)))
    {
        Console::WriteLine("CreateTexture2D failed!");
        return NULL;
    }

    ID3D11DeviceContext* ctx = NULL;
    pDevice-&gt;GetImmediateContext(&amp;ctx);

    ctx-&gt;CopyResource(pNewTexture, d3dtex);

    D3D11_MAPPED_SUBRESOURCE resource;
    UINT subresource = D3D11CalcSubresource(0, 0, 0);
    ctx-&gt;Map(pNewTexture, subresource, D3D11_MAP_READ_WRITE, 0, &amp;resource);

    // Copy from texture to bitmap buffer.
    uint8_t* sptr = reinterpret_cast&lt;uint8_t*&gt;(resource.pData);
    uint8_t* dptr = new uint8_t[desc.Width*desc.Height * 4];

    for (size_t h = 0; h &lt; desc.Height; ++h)
    {
        size_t msize = std::min&lt;size_t&gt;(desc.Width * 4, resource.RowPitch);
        memcpy_s(dptr, desc.Width * 4, sptr, msize);
        sptr += resource.RowPitch;
        dptr += desc.Width * 4;
    }

    dptr -= desc.Width*desc.Height * 4;

    // Swap BGR to RGB bitmap.
    uint32_t *dPtr = reinterpret_cast&lt;uint32_t*&gt;(dptr);
    for (size_t count = 0; count &lt; desc.Width*desc.Height * 4; count += 4)
    {
        uint32_t t = *dPtr;
        uint32_t t1 = (t &amp; 0x00ff0000) &gt;&gt; 16;
        uint32_t t2 = (t &amp; 0x000000ff) &lt;&lt; 16;
        uint32_t t3 = (t &amp; 0x0000ff00);
        uint32_t ta = (t &amp; 0xFF000000);
        *(dPtr++) = t1 | t2 | t3 | ta;
    }

    hBitmapTexture = CreateCompatibleBitmap(GetDC(NULL), desc.Width, desc.Height);
    SetBitmapBits(hBitmapTexture, desc.Width*desc.Height * 4, dptr);

    return (HBITMAP)CopyImage(hBitmapTexture, IMAGE_BITMAP, desc.Width, desc.Height, LR_CREATEDIBSECTION);
}


int main(array&lt;System::String^&gt; ^args)
{
    HRESULT hr;

    // Supported feature levels.
    D3D_FEATURE_LEVEL featureLevels[] =
    {
        D3D_FEATURE_LEVEL_11_0,
        D3D_FEATURE_LEVEL_10_1,
        D3D_FEATURE_LEVEL_10_0,
        D3D_FEATURE_LEVEL_9_1
    };

    D3D_FEATURE_LEVEL d3dFeatLvl;
    ID3D11Device* pDevice = nullptr;
    ID3D11DeviceContext* pImmediateContext = nullptr;

    // Get device object.
    hr = D3D11CreateDevice(NULL, D3D_DRIVER_TYPE_HARDWARE,
        NULL, 0, featureLevels,
        ARRAYSIZE(featureLevels),
        D3D11_SDK_VERSION,
        &amp;pDevice,
        &amp;d3dFeatLvl,
        &amp;pImmediateContext);
    EXIT(hr);

    // Get DXGI device.
    IDXGIDevice* DxgiDevice = nullptr;
    hr = pDevice-&gt;QueryInterface(__uuidof(IDXGIDevice), reinterpret_cast&lt;void**&gt;(&amp;DxgiDevice));
    EXIT(hr);

    // Get DXGI adapter.
    IDXGIAdapter* DxgiAdapter = nullptr;
    hr = DxgiDevice-&gt;GetParent(__uuidof(IDXGIAdapter), reinterpret_cast&lt;void**&gt;(&amp;DxgiAdapter));
    DxgiDevice-&gt;Release();
    DxgiDevice = nullptr;
    EXIT(hr);

    // Get DXGI output.
    IDXGIOutput* DxgiOutput = nullptr;
    hr = DxgiAdapter-&gt;EnumOutputs(0, &amp;DxgiOutput);
    DxgiAdapter-&gt;Release();
    DxgiAdapter = nullptr;
    EXIT(hr);

    DXGI_OUTPUT_DESC OutputDesc;
    DxgiOutput-&gt;GetDesc(&amp;OutputDesc);

    // Query interface for Output1.
    IDXGIOutput1* DxgiOutput1 = nullptr;
    hr = DxgiOutput-&gt;QueryInterface(__uuidof(DxgiOutput1), reinterpret_cast&lt;void**&gt;(&amp;DxgiOutput1));
    DxgiOutput-&gt;Release();
    DxgiOutput = nullptr;
    EXIT(hr);

    // Create desktop duplication.
    IDXGIOutputDuplication* DeskDupl = nullptr;
    hr = DxgiOutput1-&gt;DuplicateOutput(pDevice, &amp;DeskDupl);
    DxgiOutput1-&gt;Release();
    DxgiOutput1 = nullptr;
    EXIT(hr);

    DXGI_OUTDUPL_DESC OutputDuplDesc;
    DeskDupl-&gt;GetDesc(&amp;OutputDuplDesc);

    ///////////////////////////////////////////////////////////////////////////

    ID3D11Texture2D* AcquiredDesktopImage = nullptr;

    IDXGIResource* DesktopResource = nullptr;
    DXGI_OUTDUPL_FRAME_INFO FrameInfo;

    // Get new frame.
    hr = DeskDupl-&gt;AcquireNextFrame(500, &amp;FrameInfo, &amp;DesktopResource);
    EXIT(hr);

    // If still holding old frame, destroy it.
    if (AcquiredDesktopImage)
    {
        AcquiredDesktopImage-&gt;Release();
        AcquiredDesktopImage = nullptr;
    }

    // Query interface for IDXGIResource.
    hr = DesktopResource-&gt;QueryInterface(__uuidof(ID3D11Texture2D), reinterpret_cast&lt;void**&gt;(&amp;AcquiredDesktopImage));
    DesktopResource-&gt;Release();
    DesktopResource = nullptr;
    EXIT(hr);

    HBITMAP hBmp = (HBITMAP)ExtractBitmap(AcquiredDesktopImage, pDevice);

    ///////////////////////////////////////////////////////////////////////////

    System::Drawing::Bitmap::FromHbitmap(IntPtr(hBmp))-&gt;Save("Screenshot.bmp");

    Console::WriteLine("END!");
    Console::ReadKey();
    return 0;
}
</code></pre>

<p>Привожу пример своего исходника по работе с Desktop Duplication API (на C++/CLI).
К сожалению, не могу добиться от него результата - картинка получается пустая.
Каким образом можно поправить этот код, чтобы он работал; +добавить цикл, чтобы можно было получать скрины не вызывая функцию целиком.</p>
