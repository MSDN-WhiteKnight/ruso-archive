{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1525449880,"last_edit_date":1525449880,"creation_date":1525415192,"answer_id":822994,"question_id":822875,"body":"<p>Чтобы проверить подлинность сборки, нужно сделать две вещи: проверить корректность цифровой подписи, и проверить соответствие ее открытого ключа (т.е., что подпись действительно ваша). Для проверки подписи можно использовать интерфейс IClrStrongName. Для проверки открытого ключа нужно просто побайтово сравнить <em>AsssemblyName.PublicKeyToken</em> с ожидаемым ключом.</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Text;\nusing System.IO;\nusing System.Windows.Forms;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\n\nnamespace WindowsFormsTest1\n{\n    public partial class Form1 : Form\n    {        \n        public Form1()\n        {\n            InitializeComponent();            \n        }     \n\n        private void button1_Click(object sender, EventArgs e)\n        {\n            string path=\"c:\\\\lib\\\\my.dll\";\n            byte[] myToken = new byte[]    { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x0A, 0xFF };\n\n            if( CheckSignature(path) &amp;&amp; CheckPublicKey(path, myToken)) MessageBox.Show(\"Valid\");\n            else MessageBox.Show(\"Invalid\");            \n        }\n\n        //проверка корректности цифровой подписи\n        bool CheckSignature(string path)\n        {              \n\n            var clrStrongName = (IClrStrongName)RuntimeEnvironment.GetRuntimeInterfaceAsObject(\n                new Guid(\"B79B0ACD-F5CD-409b-B5A5-A16244610B92\"), new Guid(\"9FD93CCF-3280-4391-B3A9-96E1CDE77C8D\")\n            );\n            bool verificationForced;\n            try\n            {\n                int result = clrStrongName.StrongNameSignatureVerificationEx(path, true, out verificationForced);\n\n                if (result == 0)\n                {\n                    return true;\n                }\n                else return false;\n            }\n            finally\n            {\n                Marshal.ReleaseComObject(clrStrongName);\n            }\n        }\n\n        //проверка корректности цифровой подписи (для сборки, размещенной в памяти)\n        bool CheckSignature(byte[] bytes)\n        { \n            IntPtr p = Marshal.AllocHGlobal(bytes.Length);\n            Marshal.Copy(bytes, 0, p, bytes.Length);                        \n\n            var clrStrongName = (IClrStrongName)RuntimeEnvironment.GetRuntimeInterfaceAsObject(\n                new Guid(\"B79B0ACD-F5CD-409b-B5A5-A16244610B92\"), new Guid(\"9FD93CCF-3280-4391-B3A9-96E1CDE77C8D\")\n            );\n\n            int outFlags;\n            try\n            {\n                int result = clrStrongName.StrongNameSignatureVerificationFromImage(\n                    p, bytes.Length, 0x00000001 /*SN_INFLAG_FORCE_VER*/, out outFlags\n                    );\n\n                if (result == 0)\n                {\n                    return true;\n                }\n                else return false;\n            }\n            finally\n            {\n                Marshal.ReleaseComObject(clrStrongName);\n                Marshal.FreeHGlobal(p);\n            }\n        }           \n\n\n        //проверка соответствия ключа\n        bool CheckPublicKey(string path,byte[] expectedToken)\n        {\n            AssemblyName an = AssemblyName.GetAssemblyName(path);\n            byte[] assToken = an.GetPublicKeyToken();\n            if (assToken == null || assToken.Length == 0) return false;\n\n            if (assToken.Length != expectedToken.Length)\n            {\n                return false; \n            }\n            else\n            {                \n                for (int i = 0; i &lt; assToken.Length; i++)\n                    if (assToken[i] != expectedToken[i]) { return false; }                \n            }\n\n            return true;\n        }    \n\n    }\n\n    [ComConversionLoss, Guid(\"9FD93CCF-3280-4391-B3A9-96E1CDE77C8D\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n    [ComImport]\n    internal interface IClrStrongName\n    {\n        [PreserveSig]\n        int GetHashFromAssemblyFile([MarshalAs(UnmanagedType.LPStr)] [In] string pszFilePath, [MarshalAs(UnmanagedType.U4)] [In] [Out] ref int piHashAlg, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] [Out] byte[] pbHash, [MarshalAs(UnmanagedType.U4)] [In] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);\n\n        [PreserveSig]\n        int GetHashFromAssemblyFileW([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzFilePath, [MarshalAs(UnmanagedType.U4)] [In] [Out] ref int piHashAlg, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] [Out] byte[] pbHash, [MarshalAs(UnmanagedType.U4)] [In] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);\n\n        [PreserveSig]\n        int GetHashFromBlob([In] IntPtr pbBlob, [MarshalAs(UnmanagedType.U4)] [In] int cchBlob, [MarshalAs(UnmanagedType.U4)] [In] [Out] ref int piHashAlg, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] [Out] byte[] pbHash, [MarshalAs(UnmanagedType.U4)] [In] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);\n\n        [PreserveSig]\n        int GetHashFromFile([MarshalAs(UnmanagedType.LPStr)] [In] string pszFilePath, [MarshalAs(UnmanagedType.U4)] [In] [Out] ref int piHashAlg, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] [Out] byte[] pbHash, [MarshalAs(UnmanagedType.U4)] [In] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);\n\n        [PreserveSig]\n        int GetHashFromFileW([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzFilePath, [MarshalAs(UnmanagedType.U4)] [In] [Out] ref int piHashAlg, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] [Out] byte[] pbHash, [MarshalAs(UnmanagedType.U4)] [In] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);\n\n        [PreserveSig]\n        int GetHashFromHandle([In] IntPtr hFile, [MarshalAs(UnmanagedType.U4)] [In] [Out] ref int piHashAlg, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] [Out] byte[] pbHash, [MarshalAs(UnmanagedType.U4)] [In] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);\n\n        [PreserveSig]\n        [return: MarshalAs(UnmanagedType.U4)]\n        int StrongNameCompareAssemblies([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzAssembly1, [MarshalAs(UnmanagedType.LPWStr)] [In] string pwzAssembly2, [MarshalAs(UnmanagedType.U4)] out int dwResult);\n\n        [PreserveSig]\n        int StrongNameFreeBuffer([In] IntPtr pbMemory);\n\n        [PreserveSig]\n        int StrongNameGetBlob([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzFilePath, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] [Out] byte[] pbBlob, [MarshalAs(UnmanagedType.U4)] [In] [Out] ref int pcbBlob);\n\n        [PreserveSig]\n        int StrongNameGetBlobFromImage([In] IntPtr pbBase, [MarshalAs(UnmanagedType.U4)] [In] int dwLength, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] [Out] byte[] pbBlob, [MarshalAs(UnmanagedType.U4)] [In] [Out] ref int pcbBlob);\n\n        [PreserveSig]\n        int StrongNameGetPublicKey([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzKeyContainer, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] [In] byte[] pbKeyBlob, [MarshalAs(UnmanagedType.U4)] [In] int cbKeyBlob, out IntPtr ppbPublicKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbPublicKeyBlob);\n\n        [PreserveSig]\n        [return: MarshalAs(UnmanagedType.U4)]\n        int StrongNameHashSize([MarshalAs(UnmanagedType.U4)] [In] int ulHashAlg, [MarshalAs(UnmanagedType.U4)] out int cbSize);\n\n        [PreserveSig]\n        int StrongNameKeyDelete([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzKeyContainer);\n\n        [PreserveSig]\n        int StrongNameKeyGen([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzKeyContainer, [MarshalAs(UnmanagedType.U4)] [In] int dwFlags, out IntPtr ppbKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbKeyBlob);\n\n        [PreserveSig]\n        int StrongNameKeyGenEx([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzKeyContainer, [MarshalAs(UnmanagedType.U4)] [In] int dwFlags, [MarshalAs(UnmanagedType.U4)] [In] int dwKeySize, out IntPtr ppbKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbKeyBlob);\n\n        [PreserveSig]\n        int StrongNameKeyInstall([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzKeyContainer, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] [In] byte[] pbKeyBlob, [MarshalAs(UnmanagedType.U4)] [In] int cbKeyBlob);\n\n        [PreserveSig]\n        int StrongNameSignatureGeneration([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzFilePath, [MarshalAs(UnmanagedType.LPWStr)] [In] string pwzKeyContainer, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] [In] byte[] pbKeyBlob, [MarshalAs(UnmanagedType.U4)] [In] int cbKeyBlob, [In] [Out] IntPtr ppbSignatureBlob, [MarshalAs(UnmanagedType.U4)] out int pcbSignatureBlob);\n\n        [PreserveSig]\n        int StrongNameSignatureGenerationEx([MarshalAs(UnmanagedType.LPWStr)] [In] string wszFilePath, [MarshalAs(UnmanagedType.LPWStr)] [In] string wszKeyContainer, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] [In] byte[] pbKeyBlob, [MarshalAs(UnmanagedType.U4)] [In] int cbKeyBlob, [In] [Out] IntPtr ppbSignatureBlob, [MarshalAs(UnmanagedType.U4)] out int pcbSignatureBlob, [MarshalAs(UnmanagedType.U4)] [In] int dwFlags);\n\n        [PreserveSig]\n        int StrongNameSignatureSize([MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] [In] byte[] pbPublicKeyBlob, [MarshalAs(UnmanagedType.U4)] [In] int cbPublicKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbSize);\n\n        [PreserveSig]\n        [return: MarshalAs(UnmanagedType.U4)]\n        int StrongNameSignatureVerification([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzFilePath, [MarshalAs(UnmanagedType.U4)] [In] int dwInFlags, [MarshalAs(UnmanagedType.U4)] out int dwOutFlags);\n\n        [PreserveSig]\n        [return: MarshalAs(UnmanagedType.U4)]\n        int StrongNameSignatureVerificationEx([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzFilePath, [MarshalAs(UnmanagedType.I1)] [In] bool fForceVerification, [MarshalAs(UnmanagedType.I1)] out bool fWasVerified);\n\n        [PreserveSig]\n        [return: MarshalAs(UnmanagedType.U4)]\n        int StrongNameSignatureVerificationFromImage([In] IntPtr pbBase, [MarshalAs(UnmanagedType.U4)] [In] int dwLength, [MarshalAs(UnmanagedType.U4)] [In] int dwInFlags, [MarshalAs(UnmanagedType.U4)] out int dwOutFlags);\n\n        [PreserveSig]\n        int StrongNameTokenFromAssembly([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzFilePath, out IntPtr ppbStrongNameToken, [MarshalAs(UnmanagedType.U4)] out int pcbStrongNameToken);\n\n        [PreserveSig]\n        int StrongNameTokenFromAssemblyEx([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzFilePath, out IntPtr ppbStrongNameToken, [MarshalAs(UnmanagedType.U4)] out int pcbStrongNameToken, out IntPtr ppbPublicKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbPublicKeyBlob);\n\n\n        int StrongNameTokenFromPublicKey([MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] [In] byte[] pbPublicKeyBlob, [MarshalAs(UnmanagedType.U4)] [In] int cbPublicKeyBlob, out IntPtr ppbStrongNameToken, [MarshalAs(UnmanagedType.U4)] out int pcbStrongNameToken);\n    }  \n\n}\n</code></pre>\n\n<p><strong>Ссылки:</strong></p>\n\n<p><a href=\"https://blogs.msdn.microsoft.com/shawnfa/2004/06/07/checking-for-a-valid-strong-name-signature/\" rel=\"nofollow noreferrer\">Checking For A Valid Strong Name Signature</a>  </p>\n\n<p><a href=\"https://stackoverflow.com/a/27527384/8674428\">Checking an assembly for a strong name</a></p>\n"}