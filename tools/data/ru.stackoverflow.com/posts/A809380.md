---
title: "Answer 809380"
se.owner.user_id: 17974
se.owner.display_name: "nick_n_a"
se.owner.link: "https://ru.stackoverflow.com/users/17974/nick-n-a"
se.answer_id: 809380
se.question_id: 805934
se.post_type: answer
se.score: 2
se.is_accepted: False
---
<p>Получим xml с docx это не сложно <a href="https://ru.stackoverflow.com/a/677294/17974">вот</a></p>

<p>Давайте рассмотрим такую таблицу</p>

<blockquote>
<pre><code>1 4 &lt; 5
2 - - ^  
</code></pre>
</blockquote>

<p>Где &lt; и ^ - направление обьединения ячеек.
Тогда получим следующее (оставляю только значащие теги)</p>

<pre><code>&lt;w:document&gt;
 &lt;w:body&gt;
  &lt;w:tbl&gt;
      &lt;w:tr&gt;
         &lt;w:tc&gt;(1)&lt;/w:tc&gt;
         &lt;w:tc&gt;&lt;w:rcPr&gt;&lt;w:gridSpan w:val="2"/&gt;&lt;/w:rcPr&gt;(4)&lt;/w:tc&gt;
         &lt;!-- отсутствует колонка --&gt;
         &lt;w:tc&gt;&lt;w:rcPr&gt;&lt;w:vMerge w:val="restart"/&gt;&lt;/w:rcPr&gt;(5)&lt;/w:tc&gt;
      &lt;/w:tr&gt;
      &lt;w:tr&gt;
         &lt;w:tc&gt;(2)&lt;/w:tc&gt;
         &lt;w:tc&gt;-&lt;/w:tc&gt;
         &lt;w:tc&gt;-&lt;/w:tc&gt;
         &lt;w:tc&gt;&lt;w:rcPr&gt;&lt;w:vMerge/&gt;&lt;/w:rcPr&gt;&lt;/w:tc&gt;
      &lt;/w:tr&gt; 
</code></pre>

<p>Текст хранится в тегах <code>&lt;w:t&gt;текст&lt;/w:t&gt;</code>.  Вычислить обьеденённый столбец этим способом легче - по тегу gridSpan. Обьеденённые строки прийдется перелистывать <code>vMerge</code> тег.</p>

<p>Вот пример как получить доступ к тегам внутри docx</p>

<pre><code>using System;
using System.IO;
using System.Xml;
public class Demo {
 public static void docx2process(Stream file) {
        int isTable = 0; /*Для парсинга xml*/
        int  col = 0;
        int  row = 0;
        int colSpan = 1;
        /*Парсинг архива*/
        int ready = 0; while (ready++ &lt; 10){ /*защита от повисания, обход архива*/
            byte[] head = new byte[30]; file.Read(head, 0, 30); if (head[0] != 'P') break;  //zip-header
            int i = (head[27] + head[29]) * 256 + head[28]; //  extra len
            long paked = BitConverter.ToInt32(head,18);
            byte[] nam = new byte[255];
            file.Read(nam, 0, head[26]);
            if (i != 0) file.Seek(i, SeekOrigin.Current);
            String aname = System.Text.Encoding.ASCII.GetString(nam, 0, head[26]);
            if (aname == "word/document.xml"){
                long lastpos = file.Position;
                using (System.IO.Compression.DeflateStream deflate = new System.IO.Compression.DeflateStream(file, System.IO.Compression.CompressionMode.Decompress)){                        
                    System.Xml.XmlReader rd = System.Xml.XmlReader.Create(deflate);
                    // Тут парсинг документа
                    while (rd.Read()){
                       if (rd.NodeType == XmlNodeType.Element) 
                          switch (rd.Name){
                              case "w:gridSpan":  colSpan = int.Parse(rd.GetAttribute("w:val"));break;
                              case "w:vMerge":; /*Тут нужно допилить обьединение строк*/  break;
                              case "w:tbl": row=0; isTable = rd.Depth ; break;
                              case "w:tr": col=0; row++; break;
                              case "w:tc": col+= colSpan; colSpan=1; break;
                              case "w:t":/*Теги с текстом*/
                                 if (rd.Read() &amp;&amp; rd.NodeType == XmlNodeType.Text)
                                     /*Тут нужно написать свой вывод куда-либо*/
                                     if (isTable&gt;0) 
                                         Console.WriteLine(string.Format("c={0}.{3} r={1} t={2}",col,row,rd.Value, colSpan)); 
                                      else Console.WriteLine(rd.Value);
                                 break;                                    
                              case "w:p": /*Параграф*/ if (isTable == rd.Depth) isTable = 0; break;
                              }
                       }
                    return;
                }                                        
               file.Position = lastpos + paked;
            }else file.Seek(paked, SeekOrigin.Current);
        };                
       }


   public static void docx2process(string filename) {
        using (Stream f = File.OpenRead(filename))  docx2process(f);
       }

    public static void Main(string[] args) {
       docx2process("1.docx");    
      }
 }
</code></pre>

<p>этот пример почти решает поставленую задачу. Обьедененные столбцы - видно. Обьеденённые строки - ещё нужно доработать.</p>
