{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1529308998,"last_edit_date":1529308998,"creation_date":1529302804,"answer_id":843385,"question_id":843018,"body":"<p>Зависит от того, что такое \"подключенные IP адреса с локальной сети\". Если имеются в виду адреса компьютеров в текущем домене / рабочей группе NetBIOS, их можно получить с помощью функции <em>NetServerEnum</em>:</p>\n\n<pre><code>using System;\nusing System.Text;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Net;\nusing System.Windows.Forms;\n\nnamespace WindowsFormsTest1\n{    \n    public partial class Form1 : Form\n    {\n        /*Source: https://stackoverflow.com/questions/20512242/find-all-computers-on-network-using-netserverenum */\n\n        [DllImport(\"Netapi32\", CharSet = CharSet.Auto, SetLastError = true)]\n        public static extern int NetServerEnum(\n            string serverName,\n            int dwLevel,\n            ref IntPtr pBuf,\n            int dwPrefMaxLen,\n            out int dwEntriesRead,\n            out int dwTotalEntries,\n            int dwServerType,\n            string domain,\n            out int dwResumeHandle\n            );\n\n        [DllImport(\"Netapi32\", SetLastError = true)]\n        public static extern int NetApiBufferFree(IntPtr pBuf);\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct ServerInfo100\n        {\n            internal int sv100_platform_id;\n            [MarshalAs(UnmanagedType.LPWStr)]\n            internal string sv100_name;\n        }        \n\n        public static List&lt;string&gt; GetNetworkComputers(string domain = null) \n        {\n            List&lt;string&gt; networkComputers = new List&lt;string&gt;();\n            const int MAX_PREFERRED_LENGTH = -1;\n            int SV_TYPE_WORKSTATION = 1;\n            int SV_TYPE_SERVER = 2;\n            IntPtr buffer = IntPtr.Zero;\n            IntPtr tmpBuffer = IntPtr.Zero;\n            int entriesRead;\n            int totalEntries;\n            int resHandle;\n            int sizeofInfo = Marshal.SizeOf(typeof(ServerInfo100));\n            string elem;\n\n            try\n            {\n                int ret = NetServerEnum(null, 100, ref buffer,\n                                        MAX_PREFERRED_LENGTH, out entriesRead, out totalEntries,\n                                        SV_TYPE_WORKSTATION | SV_TYPE_SERVER, domain, out resHandle);\n\n                if (ret == 0)\n                {\n                    for (int i = 0; i &lt; totalEntries; i++)\n                    {\n                        tmpBuffer = new IntPtr((long)buffer + (i * sizeofInfo));\n\n                        ServerInfo100 svrInfo = (ServerInfo100)\n                                                   Marshal.PtrToStructure(tmpBuffer,\n                                                                          typeof(ServerInfo100));\n\n                        elem = svrInfo.sv100_name;\n\n                        try\n                        {\n                            IPAddress[] ips = Dns.GetHostAddresses(svrInfo.sv100_name);\n                            IPAddress ip = ips.First();\n\n                            if (ip != null) elem += \": \" + ip.ToString();\n                        }\n                        catch (Exception ex)\n                        {\n                            elem += \" \" + ex.Message;\n                        }\n\n                        networkComputers.Add(elem);\n                    }\n                }\n            }            \n            finally\n            {\n                NetApiBufferFree(buffer);\n            }\n            return networkComputers;\n        }\n\n        public Form1()\n        {\n            InitializeComponent();                        \n        }       \n\n        private void button1_Click(object sender, EventArgs e)\n        {\n            var list = GetNetworkComputers();\n            textBox1.Text = \"\";\n            foreach (var s in list)\n            {\n                textBox1.Text += s + Environment.NewLine;\n            }    \n        }\n    }\n}\n</code></pre>\n\n<p>IP-адреса для компьютеров, с которыми недавно взаимодействовал текущий компьютер, можно получить из ARP-кэша, как в <a href=\"https://ru.stackoverflow.com/a/642646/240512\">этом ответе</a>.</p>\n\n<p>Если подразумеваются все адреса в пределах какой-либо IP-подсети, можно сделать это только сканированием всех адресов. Для этого нужно сначала определить условие существование адреса: это может быть наличие для него имени в обратном DNS, прохождение пинга, наличие на каком-либо порту сервера, принимающего входящие соединения и т.п. (выберите то условие, которое имеет смысл в вашем окружении). Например, определим метод для проверки наличия информации по IP-адресу в обратном DNS:</p>\n\n<pre><code>//метод проверки существования IP-адреса\nstatic async Task&lt;bool&gt; CheckIp(IPAddress x)\n{ \n    var task = Task.Run&lt;bool&gt;(() =&gt;\n    {\n        string res = \"\";\n        try\n        {\n            var entry = Dns.GetHostEntry(x); //получаем информацию из обратного DNS\n            if (entry.HostName != null &amp;&amp; entry.HostName != \"\") res = (entry.HostName);\n        }\n        catch (Exception ex)\n        {\n            System.Diagnostics.Debug.WriteLine(ex.Message);\n            res = \"\";\n        }\n        return res != \"\";\n    });\n    return await task;            \n}\n</code></pre>\n\n<p>Тогда просканировать все адреса в IPv4-cети можно как-то так:</p>\n\n<pre><code>using System;\nusing System.Text;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Windows.Forms;\n\nnamespace WindowsFormsTest1\n{    \n    public partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();                        \n        }\n\n        static void IncrementIp(ref uint x)\n        {\n            byte[] bytes = BitConverter.GetBytes(x);\n            uint y = BitConverter.ToUInt32(new byte[] { bytes[3], bytes[2], bytes[1], bytes[0] },0);\n            y++;\n            bytes = BitConverter.GetBytes(y);\n            x = BitConverter.ToUInt32(new byte[] { bytes[3], bytes[2], bytes[1], bytes[0] }, 0);\n        }\n\n        static int IpCompare(uint x, uint y)\n        {\n            if (x == y) return 0;\n\n            byte[] bytes = BitConverter.GetBytes(x);\n            uint xx = BitConverter.ToUInt32(new byte[] { bytes[3], bytes[2], bytes[1], bytes[0] }, 0);\n\n            bytes = BitConverter.GetBytes(y);\n            uint yy = BitConverter.ToUInt32(new byte[] { bytes[3], bytes[2], bytes[1], bytes[0] }, 0);\n\n            if (xx &lt; yy) return -1;\n            else return 1;\n        }                \n\n        private async void button1_Click(object sender, EventArgs e)\n        {            \n            IPAddress net = IPAddress.Parse(\"192.168.100.0\"); //адрес подсети\n            IPAddress mask = IPAddress.Parse(\"255.255.255.0\"); //маска подсети\n\n            uint x1 = (uint)net.Address; //начальный адрес подсети           \n            uint x2 = (uint)(~mask.Address | net.Address); //конечный адрес подсети\n\n            textBox1.Text = \"\";\n\n            //сканирование IP-адресов\n            IncrementIp(ref x1);\n            for(uint i = x1; IpCompare(i,x2)&lt;0; IncrementIp(ref i))\n            {\n                IPAddress ip = new IPAddress((long)i);\n\n                bool res = await CheckIp(ip);\n\n                if (res)\n                {\n                    textBox1.Text += ip.ToString() + Environment.NewLine;\n                }\n            } \n        }\n    }      \n}\n</code></pre>\n\n<p>Определить время подключения и отключения компьютеров можно только периодическим сканированием с сохранением результатов и сравнением их с предыдущими сканированиями.</p>\n"}