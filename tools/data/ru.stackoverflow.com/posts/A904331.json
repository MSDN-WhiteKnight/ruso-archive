{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":0,"last_activity_date":1541758343,"creation_date":1541758343,"answer_id":904331,"question_id":902725,"body":"<p>Процесс парсинга, в простейшем случае, можно представить в виде трех этапов:</p>\n\n<ol>\n<li><p>Разделение XML на список элементов (элементами являются теги и текстовые фрагменты).</p></li>\n<li><p>Преобразование списка элементов в дерево узлов XML.</p></li>\n<li><p>Выделение отдельных свойств (атрибутов) для каждого узла и разэкранирование спецсимволов.</p></li>\n</ol>\n\n<p>Первый этап достаточно просто делается с помощью find_first_of и substr (ну, или регулярок, для их любителей). То, что внутри скобок - теги, то, что снаружи - текстовые фрагменты. </p>\n\n<p>Второй этап осуществляется путем последовательного обхода списка элементов с сохранением всех открытых на данный момент тегов в коллекцию. По мере появления закрывающих тегов, теги достаются из коллекции и добавляются в дерево узлов. На данном этапе также осуществляется контроль корректности (если что-то отклоняется от правил структуры XML, парсер должен просто упасть).</p>\n\n<p>Третий этап, аналогично первому, может использовать обычные методы обработки строк.</p>\n\n<p>Вот пример кода для 1 и 2 этапов:</p>\n\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#include &lt;exception&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;list&gt;\n\nenum TokenType { \n    TT_TAG = 1, \n    TT_TEXT = 2 \n};\n\nenum TagType { \n    TAG_OPEN = 1, \n    TAG_CLOSE = 2, \n    TAG_SELFCLOSING = 3\n};\n\n//Представляет элемент XML (тэг или текстовый фрагмент)\nstruct XmlToken {\n    std::string text;\n    TokenType type;\n};\n\n//Представляет узел в дереве XML\nstruct XmlNode {\n    std::string name; //имя тега\n    std::string properties; //свойства\n    std::string value; //значение узла\n\n    std::list&lt;XmlNode*&gt; children; //дочерние узлы\n};\n\n\n//Преобразует строку XML в последовательность элементов\nstd::list&lt;XmlToken&gt; XmlToTokens(const std::string&amp; xml) {\n\n    std::list&lt;XmlToken&gt; tokens;\n    XmlNode result;\n\n    size_t pos=0;\n    size_t startindex, endindex;\n    std::string token_text;\n    XmlToken token;\n\n    while (true) {\n        startindex = xml.find_first_of('&lt;', pos);\n        endindex = xml.find_first_of('&gt;', startindex);\n\n        if (startindex == std::string::npos || endindex == std::string::npos) {\n            break;\n        }\n\n        if (startindex &gt; pos) {\n            token.text = xml.substr(pos, startindex - pos);\n            token.type = TT_TEXT;\n            tokens.push_back(token);\n        }\n\n        token.text = xml.substr(startindex+1, endindex - (startindex+1));\n        token.type = TT_TAG;\n        tokens.push_back(token);\n\n        pos = endindex + 1;\n        if (pos &gt;= xml.length())break;\n    }   \n\n    return tokens;\n}\n\n//возвращает тип тега\nTagType GetTagType(const XmlToken&amp; token) {\n    if (token.type != TT_TAG || token.text.length()==0) return (TagType)0;\n\n\n    char first = token.text.at(0);\n    char last = token.text.at(token.text.length() - 1);\n\n    if (first == '/' &amp;&amp; last != '/') return TAG_CLOSE;\n\n    if (first != '/' &amp;&amp; last == '/') return TAG_SELFCLOSING;\n\n    if (first != '/' &amp;&amp; last != '/') return TAG_OPEN;\n    else return (TagType)0;\n\n}\n\n//возвращает имя тега\nstd::string GetTagName(const XmlToken&amp; token) {\n\n    std::string res;\n    if (token.type != TT_TAG || token.text.length() == 0) return res;\n\n    size_t pos = 0;\n    char first = token.text.at(0);\n    if (first == '/')pos = 1;\n\n    size_t index = token.text.find_first_of(\" /\", pos);\n    if (index == std::string::npos) index = token.text.length();\n    return token.text.substr(pos, index - pos);\n}\n\n//возвращает свойства тега\nstd::string GetTagProperties(const XmlToken&amp; token) {\n\n    std::string res;\n    if (token.type != TT_TAG || token.text.length() == 0) return res;\n\n    size_t pos = 0;\n    size_t len = token.text.length();\n\n    char first = token.text.at(0);\n    if (first == '/')pos = 1;\n\n    char last = token.text.at(len-1);\n    if (last == '/')len--;\n\n    size_t index = token.text.find_first_of(\" \", pos);\n    if (index == std::string::npos) index = len - 1;\n    return token.text.substr(index+1, len - (index + 1));\n}\n\n//возвращает текст элемента без пробелов\nstd::string GetTrimmedText(const XmlToken&amp; token) {\n\n    std::string res;\n    if (token.type != TT_TEXT || token.text.length() == 0) return res;\n\n    for (size_t i = 0; i &lt; token.text.length(); i++) {\n        char c = token.text.at(i);\n        if (iswspace(c) == 0 &amp;&amp; c!='\\n' &amp;&amp; c!='\\r') res += c;\n    }\n\n    return res;\n}\n\n//выводит дерево XML на экран\nvoid PrintXml(const XmlNode&amp; node, int depth = 0) {\n\n    for (int i = 0; i &lt; depth;i++) putc('-', stdout);\n\n    printf(\"%s Properties: [%s]; Value: [%s]; Children: [%d]\\n\", \n        node.name.c_str(), node.properties.c_str(),node.value.c_str(),(int)node.children.size()\n    );\n\n    for (auto x : node.children) PrintXml(*x, depth + 1);\n}\n\n//**********************************\n\nint main(int argc, char **argv)\n{   \n\n    try {\n\n        std::string xml = \"&lt;rectangle left=\\\"100\\\" top=\\\"100\\\" width=\\\"200\\\" height=\\\"200\\\"&gt;\\\n&lt;rectangle left = \\\"100\\\" top = \\\"100\\\" width = \\\"200\\\" height = \\\"200\\\"&gt;&lt;/rectangle&gt;\\\n&lt;rectangle left = \\\"100\\\" top = \\\"100\\\" width = \\\"200\\\" height = \\\"200\\\"&gt;&lt;/rectangle&gt;\\\n&lt;/rectangle&gt;\";      \n\n        printf(\"\\n****** Source XML: ****** \\n\");\n        puts(xml.c_str());\n        printf(\"*********************** \\n\");\n\n        //разбивка на элементы\n        std::list&lt;XmlToken&gt; tokens = XmlToTokens(xml);\n\n        printf(\"\\n****** Tokens: ****** \\n\");\n        for (XmlToken&amp; x : tokens) {\n            printf(\"%s\\n\", x.text.c_str());\n        }\n        printf(\"*********************** \\n\");\n\n        //создаем корневой узел\n        XmlNode root;\n        root.name = std::string(\"(XML root)\");\n        root.properties = std::string(\"\");\n        root.value = std::string(\"\");\n\n        std::list&lt;XmlNode*&gt; currentpath; //текущий путь в иерархии XML\n\n        bool between_tags = false;\n        std::string tagname;\n        std::string trimmed;\n        TagType type;\n\n        XmlNode* node = &amp;root;\n        XmlNode* new_node;\n\n        //строим дерево XML...\n\n        for (XmlToken&amp; x : tokens) {\n\n            switch (x.type) {\n            case TT_TEXT: //текстовый фрагмент\n\n                trimmed = GetTrimmedText(x);\n                if (trimmed.length() == 0) { continue; }\n\n                if (!between_tags) {\n                    printf(\"Parse error: Unexpected text outside of XML tags.\\n\");\n                    throw std::exception();\n                }\n\n                new_node = currentpath.back();\n\n                if (new_node-&gt;children.size() &gt; 0) {\n                    printf(\"Parse error: Element cannot contain both text and child elements\\n\");\n                    throw std::exception();\n                }\n\n                new_node-&gt;value = x.text; //устанавливаем значение узла                             \n\n                break;\n\n            case TT_TAG: //тег\n\n                type = GetTagType(x);\n                tagname = GetTagName(x);\n\n                if (tagname.length() == 0) { \n                    printf(\"Parse error: Tag name empty\\n\");\n                    throw std::exception();\n                }\n\n                switch (type) {\n                case TAG_OPEN: //открывающий тег\n\n                    //создаем новый узел\n                    new_node = new XmlNode();\n                    new_node-&gt;name = tagname;\n                    new_node-&gt;properties = GetTagProperties(x);\n                    new_node-&gt;value = std::string(\"\");\n\n                    //добавляем узел в текущий путь\n                    between_tags = true;\n                    currentpath.push_back(new_node);\n\n                    break;\n\n                case TAG_CLOSE: //закрывающий тег\n\n                    if (currentpath.size() == 0) {\n                        printf(\"Parse error: Unexpected closing tag\\n\");\n                        throw std::exception();\n                    }\n\n                    new_node = currentpath.back();\n                    if (tagname != new_node-&gt;name) {\n                        printf(\"Parse error: Closing tag does not match opening tag.\\n\");\n                        throw std::exception();\n                    }\n\n                    between_tags = false;\n                    currentpath.pop_back();\n\n                    //находим родительский узел\n                    if (currentpath.size() &gt; 0)\n                        node = currentpath.back();\n                    else\n                        node = &amp;root;\n\n                    //добавляем дочерний узел\n                    if (node-&gt;value.length() &gt; 0) {\n                        printf(\"Parse error: Element cannot contain both text and child elements\\n\");\n                        throw std::exception();\n                    }\n                    node-&gt;children.push_back(new_node);\n\n                    break;\n\n                case TAG_SELFCLOSING: //самозакрывающийся\n\n                    //создаем новый узел\n                    new_node = new XmlNode();\n                    new_node-&gt;name = tagname;\n                    new_node-&gt;properties = GetTagProperties(x);\n                    new_node-&gt;value = std::string(\"\");\n\n                    //находим родительский узел\n                    if (currentpath.size() &gt; 0)\n                        node = currentpath.back();\n                    else\n                        node = &amp;root;\n\n                    //добавляем дочерний узел\n                    if (node-&gt;value.length() &gt; 0) {\n                        printf(\"Parse error: Element cannot contain both text and child elements\\n\");\n                        throw std::exception();\n                    }\n                    node-&gt;children.push_back(new_node);\n                    break;\n                }\n\n                break;\n            }//end switch\n\n        }//end for\n\n        if (currentpath.size() &gt; 0) {\n            printf(\"Parse error: Not all tags are closed\\n\");\n            throw std::exception();\n        }\n\n        //выводим результат\n        printf(\"\\n****** XML Tree: ****** \\n\");\n        PrintXml(root, 0);\n        printf(\"*********************** \\n\");\n    }\n    catch (std::exception) {\n        printf(\"Parsing failed!\\n\");\n    }\n\n    getchar();\n    return 0;\n}\n\n/* Вывод:\n\n****** Source XML: ******\n&lt;rectangle left=\"100\" top=\"100\" width=\"200\" height=\"200\"&gt;&lt;rectangle left = \"100\" top = \"100\" width = \"200\" height = \"200\"&gt;&lt;/rectangle&gt;&lt;rectangle left = \"100\" top = \"100\" width = \"200\" height = \"200\"&gt;&lt;/rectangle&gt;&lt;/rectangle&gt;\n***********************\n\n****** Tokens: ******\nrectangle left=\"100\" top=\"100\" width=\"200\" height=\"200\"\nrectangle left = \"100\" top = \"100\" width = \"200\" height = \"200\"\n/rectangle\nrectangle left = \"100\" top = \"100\" width = \"200\" height = \"200\"\n/rectangle\n/rectangle\n***********************\n\n****** XML Tree: ******\n(XML root) Properties: []; Value: []; Children: [1]\n-rectangle Properties: [left=\"100\" top=\"100\" width=\"200\" height=\"200\"]; Value: []; Children: [2]\n--rectangle Properties: [left = \"100\" top = \"100\" width = \"200\" height = \"200\"]; Value: []; Children: [0]\n--rectangle Properties: [left = \"100\" top = \"100\" width = \"200\" height = \"200\"]; Value: []; Children: [0]\n***********************\n*/\n</code></pre>\n"}