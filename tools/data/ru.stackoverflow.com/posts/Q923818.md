---
title: "Почему buffer при использовании ReadProcessMemory заполняется нулями?"
se.owner.user_id: 321096
se.owner.display_name: "Sergesama Channel"
se.owner.link: "https://ru.stackoverflow.com/users/321096/sergesama-channel"
se.link: "https://ru.stackoverflow.com/questions/923818/%d0%9f%d0%be%d1%87%d0%b5%d0%bc%d1%83-buffer-%d0%bf%d1%80%d0%b8-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b8-readprocessmemory-%d0%b7%d0%b0%d0%bf%d0%be%d0%bb%d0%bd%d1%8f%d0%b5%d1%82%d1%81%d1%8f-%d0%bd%d1%83%d0%bb%d1%8f%d0%bc%d0%b8"
se.question_id: 923818
se.post_type: question
se.score: 1
---
<p>Есть программа которая получает значение ячейки памяти занятой процессом "notepad++", в буфер должно заносится содержание этой ячейки, но почему-то он заполнен нулями.Почему?</p>

<pre><code>class Program
{

    public enum DesiredAccessProcess : uint
    {
        PROCESS_TERMINATE = 0x0001,
        PROCESS_CREATE_THREAD = 0x0002,
        PROCESS_VM_OPERATION = 0x0008,
        PROCESS_VM_READ = 0x0010,
        PROCESS_VM_WRITE = 0x0020,
        PROCESS_DUP_HANDLE = 0x0040,
        PROCESS_CREATE_PROCESS = 0x0080,
        PROCESS_SET_QUOTA = 0x0100,
        PROCESS_SET_INFORMATION = 0x0200,
        PROCESS_QUERY_INFORMATION = 0x0400,
        SYNCHRONIZE = 0x00100000,
        PROCESS_ALL_ACCESS = SYNCHRONIZE | 0xF0FFF
    }

    [DllImport("Kernel32")]
    public static extern IntPtr OpenProcess(DesiredAccessProcess dwDesiredAccess, bool bInheritHandle, uint dwProcessId);

    [DllImport("Kernel32")]
    public static extern void ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out uint lpNumberOfBytesRead);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern int ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [In, Out] byte[] buffer, uint size, out IntPtr lpNumberOfBytesRead);
    public byte[] ReadProcessMemory(IntPtr MemoryAddress, uint bytesToRead, out int bytesRead, IntPtr handle)
    {
        byte[] buffer = new byte[bytesToRead];
        IntPtr ptrBytesRead;
        ReadProcessMemory(handle, MemoryAddress, buffer, bytesToRead, out ptrBytesRead);
        int result = Marshal.GetLastWin32Error();
        bytesRead = ptrBytesRead.ToInt32();
        return buffer;
    }

    static void Main(string[] args)
    {
        uint m_startAddress = 0, // Адрес, с которого начинается сканирование
         m_scanLength = 1000000000, // Длина сканируемой области в байтах
         m_bytesRead; // Количество прочитанных байт
        byte[] buffer = new byte[m_scanLength];
        int[] nums = new int[1000];
        for (int i = 0; i &lt; 1000; i++)
        {
            nums[i] = 1;
        }
        Process m_process=new Process();
        Process[] processes = Process.GetProcesses();
        foreach (Process process in processes)
            if (process.ProcessName == "notepad++")
                m_process = process;
        if (m_process != null)
        {
            while (1 == 1)
            {
                IntPtr m_intptrProcess = OpenProcess(DesiredAccessProcess.PROCESS_TERMINATE, false, (uint)m_process.Id); 
                ReadProcessMemory(m_intptrProcess, (IntPtr)m_startAddress, buffer, m_scanLength, out m_bytesRead);
                for (int i = 0; i &lt; m_scanLength; i++)
                {
                    Console.Write(buffer[i]);
                }
                Console.ReadLine();
            }
        }

    }

}
</code></pre>
