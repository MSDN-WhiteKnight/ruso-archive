{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":3,"last_activity_date":1539062791,"creation_date":1539062791,"answer_id":890779,"question_id":890473,"body":"<p>На самом деле консольный вывод, разумеется, никак не привязан к версии студии. Но многие методы класса Console, несмотря на название, выводят не в консоль, а в стандартный поток вывода, и никто не обещал, что он не будет перенаправлен. Так вот, в Visual Studio 2017 причина как будто именно в этом - при запуске под отладчиком стандартный вывод студия перенаправляет для каких-то своих целей. </p>\n\n<p>Можно пересоздать stdout, так чтобы он выводил напрямую в консоль:</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Windows;\nusing System.Windows.Controls;\n\n#pragma warning disable CS0618\n\nnamespace WpfApp1\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n        }\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        static extern bool AllocConsole();\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        internal static extern uint GetConsoleCP();\n\n        const uint GENERIC_READ = 0x80000000;\n        const uint GENERIC_WRITE = 0x40000000;\n        const uint FILE_SHARE_READ = 0x00000001;\n        const uint FILE_SHARE_WRITE = 0x00000002;\n        const uint OPEN_EXISTING = 3;\n        const uint FILE_ATTRIBUTE_NORMAL = 0x00000080;\n\n        [DllImport(\"kernel32.dll\", SetLastError = true, CharSet = CharSet.Auto)]\n        public static extern IntPtr CreateFile(\n             [MarshalAs(UnmanagedType.LPTStr)] string filename,\n             [MarshalAs(UnmanagedType.U4)] uint access,\n             [MarshalAs(UnmanagedType.U4)] uint share,\n             IntPtr securityAttributes,\n             [MarshalAs(UnmanagedType.U4)] uint creationDisposition,\n             [MarshalAs(UnmanagedType.U4)] uint flagsAndAttributes,\n             IntPtr templateFile);\n\n        public static bool CreateConsole()\n        {\n            bool res = AllocConsole(); //создаем консоль\n            if (res == false) return false;\n\n            uint cp = GetConsoleCP(); //получаем кодировку консоли\n\n            //получаем дескриптор консоли\n            var handle = CreateFile(\"CONOUT$\", GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,\n            IntPtr.Zero, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, IntPtr.Zero);\n            if (handle.ToInt64() == -1)\n            {\n                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());\n            }\n\n            //Пересоздаем stdout\n            Stream s = new FileStream(handle, FileAccess.Write);\n            StreamWriter wr = new StreamWriter( s, Encoding.GetEncoding((int)cp));\n            wr.AutoFlush = true;\n            System.Console.SetOut(wr);                        \n\n            return true;\n        }        \n\n        private void Button_Click(object sender, RoutedEventArgs e)\n        {\n            bool res = CreateConsole();\n            if (res == false) MessageBox.Show(\"Failed to create console\");\n\n            Console.WriteLine(\"Hello from WPF!\");\n        }\n    }    \n}\n</code></pre>\n\n<p>Используйте на свой страх и риск, я понятия не имею, что может сломаться от подобных извращений. Вообще, непонятно зачем тут вообще нужна именно консоль: в ней нет ничего особенно удобного для целей отладки. Вы могли бы вместо этого использовать вывод в System.Diagnostics.Debug в отладочной конфигурации (<code>#if DEBUG</code>) и обычное окно с TextBox в релизной.</p>\n"}