{"owner":{"reputation":187478,"user_id":10105,"user_type":"registered","accept_rate":73,"profile_image":"https://i.stack.imgur.com/d8Z7F.png?s=128&g=1","display_name":"VladD","link":"https://ru.stackoverflow.com/users/10105/vladd"},"is_accepted":false,"score":8,"last_activity_date":1492628949,"last_edit_date":1492628949,"creation_date":1492553143,"answer_id":655453,"question_id":654754,"body":"<p>Ну вот вам пример реализации. Сразу предупреждаю, кода будет много.</p>\n\n<p>Возьмём в качестве основы вот такую ненадёжную функцию:</p>\n\n<pre><code>class EvilComputation\n{\n    static Random random = new Random();\n\n    public static async Task&lt;double&gt; Compute(\n                int numberOfSeconds, double x, CancellationToken ct)\n    {\n        bool wellBehaved = random.Next(2) == 0;\n        var y = x * x;\n        var delay = TimeSpan.FromSeconds(numberOfSeconds);\n        await Task.Delay(delay, wellBehaved ? ct : CancellationToken.None);\n        return y;\n    }\n}\n</code></pre>\n\n<p>Вы видим, что функция плохая: она может в зависимости от случайных условий не реагировать на отмену.</p>\n\n<p>Что делать в этом случае? Вынесем функцию в отдельный процесс. Этот процесс можно будет убить без особого вреда для исходного процесса.</p>\n\n<p>Для того, чтобы вызвать функцию в другом процессе, нужно передать данные о вызове функции туда. Для связи используем, например, анонимные пайпы (можно использовать по сути что угодно). Я основываю код на этом примере: <a href=\"https://msdn.microsoft.com/en-us/library/bb546102(v=vs.110).aspx\" rel=\"noreferrer\">How to: Use Anonymous Pipes for Local Interprocess Communication</a>.</p>\n\n<p>Для передачи данных будем использовать стандартное бинарное форматирование, раз уж мы не пошли через WCF. Нам нужны DTO-объекты, которые будут перебрасываться между процессами. Их нужно использовать в двух процессах — главном и вспомогательном (назовём его <em>плагином</em>), поэтому для DTO-типов понадобится отдельная сборка.</p>\n\n<p>Заводим сборку <code>OutProcCommonData</code>, кладём в неё следующие классы:</p>\n\n<pre><code>namespace OutProcCommonData\n{\n    [Serializable]\n    public class Command // общий класс-предок для посылаемой команды\n    {\n    }\n\n    [Serializable]\n    public class Evaluate : Command // команда на вычисление\n    {\n        public int NumberOfSecondsToProcess;\n        public double X;\n    }\n\n    [Serializable]\n    public class Cancel : Command // команда на отмену\n    {\n    }\n}\n</code></pre>\n\n<p>Далее, возвращаемый результат:</p>\n\n<pre><code>namespace OutProcCommonData\n{\n    [Serializable]\n    public class Response // общий класс-предок для возвращаемого результата\n    {\n    }\n\n    [Serializable]\n    public class Result : Response // готовый результат вычислений\n    {\n        public double Y;\n    }\n\n    [Serializable]\n    public class Error : Response // ошибка с текстом\n    {\n        public string Text;\n    }\n\n    [Serializable]\n    public class Cancelled : Response // подтверждение отмены\n    {\n    }\n}\n</code></pre>\n\n<hr>\n\n<p>Далее, наш плагин. Это отдельное консольное приложение (хотя, если мы не хотим видеть консоль и отладочный вывод, можно сделать его неконсольным).</p>\n\n<p>Протокол общения таков. Главная программа посылает <code>Evaluate</code>, а после него, возможно, <code>Cancel</code>. Плагин возвращает <code>Result</code> в случае успешного вычисления, <code>Cancelled</code> в случае полученного сигнала отмены и успешно отменённого вычисления, и <code>Error</code> в случае ошибки (например, нарушения протокола коммуникации).</p>\n\n<p>Вот обвязочный код:</p>\n\n<pre><code>class Plugin\n{\n    static int Main(string[] args)\n    {\n        // нам должны быть переданы два аргумента: хендл входящего и исходящего пайпов\n        if (args.Length != 2)\n        {\n            Console.Error.WriteLine(\"Shouldn't be started directly\");\n            return 1;\n        }\n\n        return new Plugin().Run(args[0], args[1]).Result;\n    }\n\n    BinaryFormatter serializer = new BinaryFormatter(); // для сериализации\n\n    async Task&lt;int&gt; Run(string hIn, string hOut)\n    {\n        Console.WriteLine(\"[Plugin] Running\");\n        // открывем переданные пайпы\n        using (var inStream = new AnonymousPipeClientStream(PipeDirection.In, hIn))\n        using (var outStream = new AnonymousPipeClientStream(PipeDirection.Out, hOut))\n        {\n            try\n            {\n                var cts = new CancellationTokenSource(); // токен для отмены\n                Console.WriteLine(\"[Plugin] Reading args\");\n                // пытаемся десериализовать аргументы\n                var args = SafeGet&lt;OutProcCommonData.Evaluate&gt;(inStream);\n                if (args == null)\n                {\n                    Console.WriteLine(\"[Plugin] Didn't get args\");\n                    // отправляем ошибку, если не удалось\n                    serializer.Serialize(\n                        outStream,\n                        new OutProcCommonData.Error() { Text = \"Unrecognized input\" });\n                    // и выходим\n                    return 3;\n                }\n                Console.WriteLine(\"[Plugin] Got args, start compute and waiting cancel\");\n                // запускаем вычисление\n                var computeTask =\n                        EvilComputation.Compute(\n                            args.NumberOfSecondsToProcess,\n                            args.X,\n                            cts.Token);\n                // параллельно запускаем чтение возможной отмены\n                var waitForCancelTask = Task.Run(() =&gt;\n                        (OutProcCommonData.Cancel)serializer.Deserialize(inStream));\n                // дожидаемся одного из двух\n                var winner = await Task.WhenAny(computeTask, waitForCancelTask);\n                // если первой пришла отмена...\n                if (winner == waitForCancelTask)\n                {\n                    Console.WriteLine(\"[Plugin] Got cancel, cancelling computation\");\n                    // просим вычисление завершиться\n                    cts.Cancel();\n                }\n                // окончания вычисления всё равно нужно дождаться\n                Console.WriteLine(\"[Plugin] Awaiting computation\");\n                // если вычисление отменится, здесь будет исключение\n                var result = await computeTask;\n                Console.WriteLine(\"[Plugin] Sending back result\");\n                // отсылаем результат в пайп\n                serializer.Serialize(\n                    outStream,\n                    new OutProcCommonData.Result() { Y = result });\n                // нормальный выход\n                return 0;\n            }\n            catch (OperationCanceledException)\n            {\n                // мы успешно отменили задание, рапортуем\n                Console.WriteLine(\"[Plugin] Sending cancellation\");\n                serializer.Serialize(\n                    outStream,\n                    new OutProcCommonData.Cancelled());\n                return 2;\n            }\n            catch (Exception ex)\n            {\n                // возникла непредвиденная ошибка, рапортуем\n                Console.WriteLine($\"[Plugin] Sending error {ex.Message}\");\n                serializer.Serialize(\n                    outStream,\n                    new OutProcCommonData.Error() { Text = ex.Message });\n                return 3;\n            }\n        }\n    }\n\n    // ну и вспомогательная функция, которая пытается читать данные из пайпа\n    T SafeGet&lt;T&gt;(Stream s) where T : class\n    {\n        try\n        {\n            return (T)serializer.Deserialize(s);\n        }\n        catch\n        {\n            return null;\n        }\n    }\n}\n</code></pre>\n\n<p>Я не отлавливаю ошибки при записи в пайп, добавьте сами по вкусу.</p>\n\n<hr>\n\n<p>Теперь, главная программа. Она будет у нас отдельно от плагина (то есть, у нас получаются <em>три</em> сборки).</p>\n\n<pre><code>class Program\n{\n    static void Main(string[] args) =&gt; new Program().Run().Wait();\n\n    async Task Run()\n    {\n        var cts = new CancellationTokenSource();\n        try\n        {\n            var y = await ComputeOutProc(2, cts.Token);\n            Console.WriteLine($\"[Main] Result: {y}\");\n        }\n        catch (TimeoutException)\n        {\n            Console.WriteLine(\"[Main] Timed out\");\n        }\n        catch (OperationCanceledException)\n        {\n            Console.WriteLine(\"[Main] Cancelled\");\n        }\n    }\n\n    const int SecondsToSend = 3;\n    const int TimeoutSeconds = 5;\n    const int CancelSeconds = 2;\n\n    BinaryFormatter serializer = new BinaryFormatter();\n    async Task&lt;double&gt; ComputeOutProc(double x, CancellationToken ct)\n    {\n        Process plugin = null;\n        bool pluginStarted = false;\n        try\n        {\n            // создаём исходящий и входящий пайпы\n            using (var commandStream = new AnonymousPipeServerStream(\n                            PipeDirection.Out, HandleInheritability.Inheritable))\n            using (var responseStream = new AnonymousPipeServerStream(\n                            PipeDirection.In, HandleInheritability.Inheritable))\n            {\n                Console.WriteLine(\"[Main] Starting plugin\");\n                plugin = new Process()\n                {\n                    StartInfo =\n                    {\n                        FileName = \"OutProcPlugin.exe\",\n                        Arguments = commandStream.GetClientHandleAsString() + \" \" +\n                                    responseStream.GetClientHandleAsString(),\n                        UseShellExecute = false\n                    }\n                };\n                // запускаем плагин с параметрами\n                plugin.Start();\n                pluginStarted = true;\n                Console.WriteLine(\"[Main] Started plugin\");\n\n                commandStream.DisposeLocalCopyOfClientHandle();\n                responseStream.DisposeLocalCopyOfClientHandle();\n\n                void Send(Command c)\n                {\n                    serializer.Serialize(commandStream, c);\n                    commandStream.Flush();\n                }\n\n                try\n                {\n                    // отсылаем плагину команду на вычисление\n                    Console.WriteLine(\"[Main] Sending evaluate request\");\n                    Send(new OutProcCommonData.Evaluate()\n                    {\n                        NumberOfSecondsToProcess = SecondsToSend,\n                        X = x\n                    });\n\n                    Task&lt;Response&gt; responseTask;\n                    bool readyInTime;\n                    bool cancellationSent = false;\n                    // внутри этого блока при отмене будем отсылать команду плагину\n                    using (ct.Register(() =&gt;\n                        {\n                            Send(new OutProcCommonData.Cancel());\n                            Console.WriteLine(\"[Main] Requested cancellation\");\n                            cancellationSent = true;\n                        }))\n                    {\n                        Console.WriteLine(\"[Main] Starting getting response\");\n                        // ожидаем получение ответа\n                        responseTask = Task.Run(() =&gt;\n                                (Response)serializer.Deserialize(responseStream));\n                        // или таймаута\n                        var timeoutTask = Task.Delay(TimeSpan.FromSeconds(TimeoutSeconds));\n                        var winner = await Task.WhenAny(responseTask, timeoutTask);\n                        readyInTime = winner == responseTask;\n                    }\n\n                    // если наступил таймаут, просим процесс вежливо завершить вычисления\n                    if (!readyInTime)\n                    {\n                        if (!cancellationSent)\n                        {\n                            Console.WriteLine(\"[Main] Not ready in time, sending cancel\");\n                            Send(new OutProcCommonData.Cancel());\n                        }\n                        else\n                        {\n                            Console.WriteLine(\"[Main] Not ready in time, cancel sent\");\n                        }\n                        // и ждём ещё немного, ну или прихода ответа\n                        var timeoutTask = Task.Delay(TimeSpan.FromSeconds(CancelSeconds));\n                        await Task.WhenAny(responseTask, timeoutTask);\n                    }\n\n                    // если до сих пор ничего не пришло, плагин завис, убиваем его\n                    if (!responseTask.IsCompleted)\n                    {\n                        Console.WriteLine(\"[Main] No response, killing plugin\");\n                        plugin.Kill(); // это завершит ожидание с исключением, по идее\n                                       // в ранних версиях .NET нужно было бы поймать\n                                       // это исключение\n                                       // и уходим с исключением-таймаутом\n                        ct.ThrowIfCancellationRequested();\n                        throw new TimeoutException();\n                    }\n\n                    // здесь мы уверены, что ожидание завершилось\n                    Console.WriteLine(\"[Main] Obtaining response\");\n                    var response = await responseTask; // тут может быть брошено исключение\n\n                    // если была затребована отмена, выходим\n                    ct.ThrowIfCancellationRequested();\n                    // проверяем тип результата:\n                    switch (response)\n                    {\n                    case Result r:\n                        // нормальный результат, возвращаем его\n                        Console.WriteLine(\"[Main] Got result, returning\");\n                        return r.Y;\n                    case Cancelled _:\n                        // отмена не по ct = таймаут\n                        Console.WriteLine(\"[Main] Got cancellation\");\n                        throw new TimeoutException();\n                    case Error err:\n                        // пришла ошибка, бросаем исключение\n                        // лучше, конечно, определить собственный тип здесь\n                        Console.WriteLine(\"[Main] Got error\");\n                        throw new Exception(err.Text);\n                    default:\n                        // сюда мы вообще не должны попасть, если плагин работает нормально\n                        Console.WriteLine(\"[Main] Unexpected error\");\n                        throw new Exception(\"Unexpected response type\");\n                    }\n                }\n                catch (IOException e)\n                {\n                    Console.WriteLine(\"[Main] IO error occured\");\n                    throw new Exception(\"IO Error\", e);\n                }\n            }\n        }\n        finally\n        {\n            if (pluginStarted)\n            {\n                plugin.WaitForExit();\n                plugin.Close();\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>Результат пробега:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>[Main] Starting plugin\n[Main] Started plugin\n[Main] Sending evaluate request\n[Main] Starting getting response\n[Plugin] Running\n[Plugin] Reading args\n[Plugin] Got args, start compute and waiting cancel\n[Plugin] Awaiting computation\n[Plugin] Sending back result\n[Main] Obtaining response\n[Main] Got result, returning\n[Main] Result: 4\n</code></pre>\n\n<p>Если поменять константу <code>SecondsToSend</code> на 10, чтобы был таймаут, получаем такой результат двух пробегов:</p>\n\n<p>Для штатного завершения:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>[Main] Starting plugin\n[Main] Started plugin\n[Main] Sending evaluate request\n[Main] Starting getting response\n[Plugin] Running\n[Plugin] Reading args\n[Plugin] Got args, start compute and waiting cancel\n[Main] Not ready in time, sending cancel\n[Plugin] Got cancel, cancelling computation\n[Plugin] Awaiting computation\n[Plugin] Sending cancellation\n[Main] Obtaining response\n[Main] Got cancellation\n[Main] Timed out\n</code></pre>\n\n<p>Для принудительного завершения:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>[Main] Starting plugin\n[Main] Started plugin\n[Main] Sending evaluate request\n[Main] Starting getting response\n[Plugin] Running\n[Plugin] Reading args\n[Plugin] Got args, start compute and waiting cancel\n[Main] Not ready in time, sending cancel\n[Plugin] Got cancel, cancelling computation\n[Plugin] Awaiting computation\n[Main] No response, killing plugin\n[Main] Timed out\n</code></pre>\n\n<p>Если добавить перед </p>\n\n<pre><code>var y = await ComputeOutProc(2, cts.Token);\n</code></pre>\n\n<p>преждевременную отмену:</p>\n\n<pre><code>cts.CancelAfter(TimeSpan.FromSeconds(1));\n</code></pre>\n\n<p>получим такой результат: для штатного завершения</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>[Main] Starting plugin\n[Main] Started plugin\n[Main] Sending evaluate request\n[Main] Starting getting response\n[Plugin] Running\n[Plugin] Reading args\n[Plugin] Got args, start compute and waiting cancel\n[Main] Requested cancellation\n[Plugin] Got cancel, cancelling computation\n[Plugin] Awaiting computation\n[Plugin] Sending cancellation\n[Main] Obtaining response\n[Main] Cancelled\n</code></pre>\n\n<p>и для принудительного завершения</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>[Main] Starting plugin\n[Main] Started plugin\n[Main] Sending evaluate request\n[Main] Starting getting response\n[Plugin] Running\n[Plugin] Reading args\n[Plugin] Got args, start compute and waiting cancel\n[Main] Requested cancellation\n[Plugin] Got cancel, cancelling computation\n[Plugin] Awaiting computation\n[Main] Not ready in time, cancel sent\n[Main] No response, killing plugin\n[Main] Cancelled\n</code></pre>\n\n<p>Наверняка кое-где недостаточно контролируются ошибки, так что проверяйте, не нужно ли ловить какие-то ещё исключения.</p>\n\n<hr>\n\n<p>На эту заготовку можно добавлять сверху свою логику. Например, можно аналогично пулу потоков завести пул плагинов, и доставлять задания свободному в данный момент плагину.</p>\n"}