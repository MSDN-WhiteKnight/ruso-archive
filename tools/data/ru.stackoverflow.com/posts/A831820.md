---
title: "Answer 831820"
se.owner.user_id: 269374
se.owner.display_name: "John"
se.owner.link: "https://ru.stackoverflow.com/users/269374/john"
se.answer_id: 831820
se.question_id: 831776
se.post_type: answer
se.score: 1
se.is_accepted: False
---
<p>Странно. Activate() у меня отрабатывает. Сейчас приведу свой пример программы.</p>

<p>Вот PipeManager, который я использовал. Писал не я, сам нашёл где-то (уже не помню где).
<div class="snippet" data-lang="js" data-hide="true" data-console="false" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>    public class NamedPipeManager
    {
        public static string NamedPipeName { get; } = "MyApplicationName";
        public event Action&lt;string&gt; ReceiveString;

        private const string EXIT_STRING = "__EXIT__";
        private BackgroundWorker backgroundWorker;

        public void Start()
        {
            backgroundWorker = new BackgroundWorker();
            backgroundWorker.WorkerReportsProgress = true;
            backgroundWorker.DoWork += BackgroundWorker_DoWork;
            backgroundWorker.ProgressChanged += BackgroundWorker_ProgressChanged;
            backgroundWorker.RunWorkerCompleted += BackgroundWorker_RunWorkerCompleted;
            backgroundWorker.RunWorkerAsync();
        }

        public void Stop()
        {
            Write(EXIT_STRING);
        }

        private void BackgroundWorker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            backgroundWorker.Dispose();
        }

        private void BackgroundWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            ReceiveString?.Invoke(e.UserState as string);
        }

        private void BackgroundWorker_DoWork(object sender, DoWorkEventArgs e)
        {
            while (true)
            {
                string result;
                using (var server = new NamedPipeServerStream(NamedPipeName))
                {
                    server.WaitForConnection();

                    using (StreamReader reader = new StreamReader(server))
                        result = reader.ReadToEnd();
                }

                if (result == EXIT_STRING)
                    break;

                backgroundWorker.ReportProgress(0, result);
            }
        }

        public static bool Write(string[] text, int connectTimeout = 300)
        {
            using (var client = new NamedPipeClientStream(NamedPipeName))
            {
                try
                {
                    client.Connect(connectTimeout);
                }
                catch
                {
                    return false;
                }

                if (!client.IsConnected)
                    return false;

                using (StreamWriter writer = new StreamWriter(client))
                {
                    foreach (var a in text)
                        writer.Write(a + '\n');
                    writer.Flush();
                }
            }
            return true;
        }

        public static bool Write(string text, int connectTimeout = 300)
        {
            using (var client = new NamedPipeClientStream(NamedPipeName))
            {
                try
                {
                    client.Connect(connectTimeout);
                }
                catch
                {
                    return false;
                }

                if (!client.IsConnected)
                    return false;

                using (StreamWriter writer = new StreamWriter(client))
                {
                    writer.Write(text);
                    writer.Flush();
                }
            }
            return true;
        }
    }</code></pre>
</div>
</div>
</p>

<p>В Program.cs я добавляю 3 статичных поля:</p>

<pre><code> static Mutex Mutex;
 static NamedPipeManager NamedPipeManager;
 static Form1 main;
</code></pre>

<p>В Main() я в начало добавляю это:</p>

<pre><code> Mutex = new Mutex(true, "MyApplicationName", out bool Is);
 if (!Is)
 {
     NamedPipeManager.Write("1");
     Application.Exit();
     return;
 }
 NamedPipeManager = new NamedPipeManager();
 NamedPipeManager.ReceiveString += NamedPipeManager_ReceiveString;
 NamedPipeManager.Start();
</code></pre>

<p>Естественно в поле main я храню свою основную форму. А событием ReceiveString вызываю этот метод:</p>

<pre><code> private static void NamedPipeManager_ReceiveString(string obj)
 {
     if (main.WindowState == FormWindowState.Minimized)
         main.WindowState = FormWindowState.Normal;
     main.Activate();
 }
</code></pre>

<p>Специально сейчас попробовал по быстрому написать этот пример. Запускаю один раз приложение - появляется окно. Потом фокусируюсь обратно на проводник, запускаю - опять открывается первое окно. Если сверну и запускаю с проводника, то опять же первоначальное окно запускается.</p>

<p><a href="https://i.stack.imgur.com/MDZnv.gif" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/MDZnv.gif" alt="Как работет"></a></p>
