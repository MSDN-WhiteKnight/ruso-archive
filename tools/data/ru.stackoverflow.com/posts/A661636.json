{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":5,"last_activity_date":1493919428,"last_edit_date":1493919428,"creation_date":1493838847,"answer_id":661636,"question_id":661585,"body":"<p>Проблема в неверном подходе. Во-первых, забудьте про функцию <em>BeginPaint</em> (вне обработки сообщения <em>WM_PAINT</em>), во-вторых, рисовать надо не в контексте целевого окна, а в контексте его родительского окна (контекст окна позволяет рисовать только в его клиентской области, а рамка-то нам нужна снаружи).</p>\n\n<p>Я предлагаю сделать как-то так:</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Text;\nusing System.Windows.Forms;\nusing System.Runtime.InteropServices;\n\nnamespace DrawingTest\n{\n    public partial class Form1 : Form\n    {\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        static extern bool GetCursorPos(out POINT lpPoint);\n\n        [DllImport(\"user32.dll\")]\n        static extern IntPtr WindowFromPoint(POINT p);                \n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        static extern bool GetWindowRect(IntPtr hwnd, out RECT lpRect);\n\n        [DllImport(\"user32.dll\")]\n        static extern bool ScreenToClient(IntPtr hWnd, ref POINT lpPoint);        \n\n        [DllImport(\"user32.dll\", ExactSpelling = true, CharSet = CharSet.Auto)]\n        public static extern IntPtr GetParent(IntPtr hWnd);\n\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        private void timer1_Tick(object sender, EventArgs e)\n        {\n            //получаем окно в текущей позиции курсора  \n            POINT pt;\n            GetCursorPos(out pt);\n            IntPtr hwnd = WindowFromPoint(pt);\n\n            //получаем родительское окно\n            IntPtr hwnd_p = GetParent(hwnd);\n\n            //получаем границы окна   \n            RECT rc;\n            GetWindowRect(hwnd, out rc);\n\n            //перевод из экранных координат в клиентские\n            POINT pt1=new POINT(rc.Left,rc.Top), pt2=new POINT(rc.Right,rc.Bottom);\n            ScreenToClient(hwnd_p, ref pt1);\n            ScreenToClient(hwnd_p, ref pt2);\n            RECT rc_client = new RECT();\n            rc_client.Left = pt1.X-1; rc_client.Top = pt1.Y-1;\n            rc_client.Right = pt2.X; rc_client.Bottom = pt2.Y;\n\n            //формируем структуру для GDI+\n            Rectangle rect = new Rectangle(rc_client.Left, rc_client.Top, rc_client.Right - rc_client.Left, rc_client.Bottom - rc_client.Top);\n\n            //получаем контекст окна            \n            Graphics g = System.Drawing.Graphics.FromHwnd(hwnd_p);\n            using (g)\n            {\n                //рисуем прямоугольник\n                g.DrawRectangle(Pens.Red, rect);\n            }\n\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct POINT\n    {\n        public int X;\n        public int Y;\n\n        public POINT(int x, int y)\n        {\n            this.X = x;\n            this.Y = y;\n        }\n\n        public POINT(System.Drawing.Point pt) : this(pt.X, pt.Y) { }\n\n        public static implicit operator System.Drawing.Point(POINT p)\n        {\n            return new System.Drawing.Point(p.X, p.Y);\n        }\n\n        public static implicit operator POINT(System.Drawing.Point p)\n        {\n            return new POINT(p.X, p.Y);\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct RECT\n    {\n        public int Left;        // x position of upper-left corner\n        public int Top;         // y position of upper-left corner\n        public int Right;       // x position of lower-right corner\n        public int Bottom;      // y position of lower-right corner\n    }\n}\n</code></pre>\n\n<hr>\n\n<p>Если целевое окно перекрывается другими окнами, соответствующая часть рамки будет скрыта. Чтобы рисовать рамку поверх всех окон, код рисования нужно изменить, используя контекст рабочего стола:</p>\n\n<pre><code>        //получаем окно в текущей позиции курсора  \n        POINT pt;\n        GetCursorPos(out pt);\n        IntPtr hwnd = WindowFromPoint(pt);\n\n        //получаем границы окна   \n        RECT rc;\n        GetWindowRect(hwnd, out rc);\n\n        //формируем структуру для GDI+\n        Rectangle rect = new Rectangle(rc.Left, rc.Top, rc.Right - rc.Left, rc.Bottom - rc.Top);\n\n        //получаем контекст рабочего стола\n        Graphics g = System.Drawing.Graphics.FromHwnd((IntPtr)0);\n        using (g)\n        {\n            //рисуем прямоугольник\n            g.DrawRectangle(Pens.Red, rect);\n        }\n</code></pre>\n\n<p>Иллюстрация различия между этими двумя методами:</p>\n\n<p><a href=\"https://i.stack.imgur.com/oWvhv.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/oWvhv.png\" alt=\"введите сюда описание изображения\"></a></p>\n"}