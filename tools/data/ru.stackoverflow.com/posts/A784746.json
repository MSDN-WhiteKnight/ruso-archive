{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":3,"last_activity_date":1518545269,"last_edit_date":1518545269,"creation_date":1518544871,"answer_id":784746,"question_id":759022,"body":"<p>Функциональность просмотра информации о работе GPU в диспетчере - новинка Windows 10 (<a href=\"https://blogs.msdn.microsoft.com/directx/2017/07/21/gpus-in-the-task-manager/\" rel=\"nofollow noreferrer\">подробнее</a>). Для того, чтобы она работала, необходим графический адаптер с поддержкой WDDM 2.0. Информация берется, по-видимому, из специального счетчика производительности \"<em>GPU Engine</em>\", который имеет для каждого процесса, использующего графику, несколько экземпляров с именем вида:</p>\n\n<blockquote>\n  <p>pid_5036_luid_0x00000000_0x00009F54_phys_0_eng_3_engtype_3D</p>\n</blockquote>\n\n<p>Из этой строки можно извлечь информацию о том, к какому процессу и графическому движку он относится. У счетчика два значения, <em>Utilization Percentage</em> и <em>Running time</em>. <em>Utilization Percentage</em> у меня почему-то всегда нулевое, наверное, самый простой способ найти процессы, использующие 3D-графику - это отфильтровать те, у которых <em>Running time</em> больше нуля.</p>\n\n<p>Для работы со счетчиками производительности можно использовать WMI или <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/aa373214(v=vs.85).aspx\" rel=\"nofollow noreferrer\">PDH-функции</a>. Пример вывода процессов, использующих 3D Engine, с помощью PDH-функций:</p>\n\n<pre><code>#define WIN32_LEAN_AND_MEAN 1\n#include &lt;stdlib.h&gt;\n#include &lt;windows.h&gt;\n#include &lt;strsafe.h&gt;\n#include &lt;malloc.h&gt;\n#include &lt;stdio.h&gt;\n\n//для работы со счетчиками производительности:\n#include &lt;pdh.h&gt;\n#include &lt;pdhmsg.h&gt;\n#pragma comment(lib, \"pdh.lib\")\n\n//для получения информации о процессах:\n#include \"psapi.h\"\n#include \"Shlwapi.h\"\n#pragma comment(lib, \"Shlwapi.lib\")\n\nconst PWSTR COUNTER_OBJECT = L\"GPU Engine\"; //Имя счетчика производительности\n\n/*Вывод имени процесса по его PID*/\nvoid PrintProcessName(int pid){\n\n    HANDLE hProcess;\n    DWORD charsCarried=0;\n    TCHAR PrName[MAX_PATH]=L\"\";\n\n    hProcess= OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,FALSE,pid);\n    if (hProcess) \n    {\n        charsCarried=MAX_PATH;                          \n        if (QueryFullProcessImageName(hProcess,0,PrName,&amp;charsCarried)==0){\n            StringCchCopy(PrName,MAX_PATH,L\"Unknown process\");\n        }\n\n        CloseHandle(hProcess);\n    }\n    else StringCchCopy(PrName,MAX_PATH,L\"Unknown process\");\n\n    PathStripPath(PrName);\n    wprintf(L\"%s\",PrName);\n}\n\nvoid main(void)\n{\n    PDH_STATUS status = ERROR_SUCCESS;\n    LPWSTR pwsCounterListBuffer = NULL;\n    DWORD dwCounterListSize = 0;\n    LPWSTR pwsInstanceListBuffer = NULL;\n    DWORD dwInstanceListSize = 0;\n    LPWSTR pTemp = NULL;\n\n    HQUERY hQuery = NULL;\n    HCOUNTER hCounter = NULL;\n\n    DWORD dwFormat = PDH_FMT_LONG; \n    PDH_FMT_COUNTERVALUE ItemBuffer;\n    wchar_t buffer[1000];\n    wchar_t * p;\n\n    // Determine the required buffer size for the data. \n    status = PdhEnumObjectItems(\n        NULL,                   // real-time source\n        NULL,                   // local machine\n        COUNTER_OBJECT,         // object to enumerate\n        pwsCounterListBuffer,   // pass NULL and 0\n        &amp;dwCounterListSize,     // to get required buffer size\n        pwsInstanceListBuffer, \n        &amp;dwInstanceListSize, \n        PERF_DETAIL_WIZARD,     // counter detail level\n        0); \n\n    if (status == PDH_MORE_DATA) \n    {\n        // Allocate the buffers and try the call again.\n        pwsCounterListBuffer = (LPWSTR)malloc(dwCounterListSize * sizeof(WCHAR));\n        pwsInstanceListBuffer = (LPWSTR)malloc(dwInstanceListSize * sizeof(WCHAR));\n\n        if (NULL != pwsCounterListBuffer &amp;&amp; NULL != pwsInstanceListBuffer) \n        {\n            status = PdhEnumObjectItems(\n                NULL,                   // real-time source\n                NULL,                   // local machine\n                COUNTER_OBJECT,         // object to enumerate\n                pwsCounterListBuffer, \n                &amp;dwCounterListSize,\n                pwsInstanceListBuffer, \n                &amp;dwInstanceListSize, \n                PERF_DETAIL_WIZARD,     // counter detail level\n                0); \n\n            if (status == ERROR_SUCCESS) \n            {                \n\n                wprintf(L\"\\nProcesses using 3D engine:\\n\\n\");\n\n                // Walk the instance list. The list can contain one\n                // or more null-terminated strings. The list is terminated\n                // using two null-terminator characters.\n                for (pTemp = pwsInstanceListBuffer; *pTemp != 0; pTemp += wcslen(pTemp) + 1) \n                {\n                    p = wcsstr(pTemp,L\"engtype_3D\");\n                    if(p==NULL)continue;//отфильтровать записи, не относящиеся к 3D Engine\n\n                    //построим путь к запрашиваемому значению счетчика...\n                    StringCchCopy(buffer,1000,L\"\\\\GPU Engine(\");\n                    StringCchCat(buffer,1000,pTemp);\n                    StringCchCat(buffer,1000,L\")\\\\Running time\");\n\n                    //создадим запрос...\n                    status = PdhOpenQuery(NULL, 0, &amp;hQuery);\n                    if (ERROR_SUCCESS != status)\n                    {\n                        wprintf(L\"PdhOpenQuery failed with 0x%x\\n\", status);\n                        continue;\n                    }\n\n                    //добавим счетчик в запрос...\n                    status = PdhAddCounter(hQuery, buffer, 0, &amp;hCounter);\n                    if (ERROR_SUCCESS != status)\n                    {\n                        wprintf(L\"PdhAddCounter failed with 0x%x\\n\", status);\n                        continue;\n                    }\n\n                    //получаем данные...\n                    status = PdhCollectQueryData(hQuery);\n                    if (ERROR_SUCCESS != status)\n                    {\n                        wprintf(L\"PdhCollectQueryData failed with 0x%x\\n\", status);\n                        continue;\n                    }\n\n                    status = PdhCollectQueryData(hQuery);\n                    if (ERROR_SUCCESS != status)\n                    {\n                        wprintf(L\"PdhCollectQueryData failed with 0x%x\\n\", status);\n                        continue;\n                    }\n\n                    // Format the performance data record.\n                    status = PdhGetFormattedCounterValue(hCounter,\n                        dwFormat,(LPDWORD)NULL,&amp;ItemBuffer);\n\n                    if (ERROR_SUCCESS != status)\n                    {\n                        wprintf(L\"PdhGetFormattedCounterValue failed with 0x%x\\n\", status);\n                        continue;\n                    }                                       \n\n                    int pid=0;  \n\n                    //выведем информацию о процессе, если Running time &gt; 0\n                    if(ItemBuffer.longValue &gt; 0){                       \n\n                        swscanf(pTemp,L\"pid_%d\",&amp;pid);  //парсим PID из имени счетчика                                              \n                        PrintProcessName(pid);\n                        wprintf(L\", PID: %d - \", pid);\n                        wprintf(L\"Usage time: %d\\n\",(int)ItemBuffer.longValue);                     \n                    }\n                    PdhCloseQuery(hQuery);\n\n                }\n            }\n            else \n            {\n                wprintf(L\"Second PdhEnumObjectItems failed with %0x%x.\\n\", status);\n            }\n        } \n        else \n        {\n            wprintf(L\"Unable to allocate buffers.\\n\");\n            status = ERROR_OUTOFMEMORY;\n        }\n    } \n    else \n    {\n        wprintf(L\"\\nPdhEnumObjectItems failed with 0x%x.\\n\", status);\n    }\n\n    if (pwsCounterListBuffer != NULL) \n        free (pwsCounterListBuffer);\n\n    if (pwsInstanceListBuffer != NULL) \n        free (pwsInstanceListBuffer);\n\n    system(\"PAUSE\");\n}\n</code></pre>\n\n<p><a href=\"https://i.stack.imgur.com/6DjY7.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/6DjY7.png\" alt=\"Пример вывода\"></a></p>\n\n<hr>\n\n<p>На системах до Windows 10 (или если нет поддержки данной функциональности у адаптера, и, как следствие - нет этого счетчика), можно использовать функцию <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms682631(v=vs.85).aspx\" rel=\"nofollow noreferrer\">EnumProcessModules</a> для получения загруженных DLL процесса. Если среди них есть библиотеки Direct 3D - <strong>d3d9.dll</strong>, <strong>d3d10.dll</strong>, <strong>d3d11.dll</strong> и т.п., можно считать, что процесс использует 3D-графику.</p>\n"}