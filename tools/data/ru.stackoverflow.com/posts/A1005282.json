{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":4,"last_activity_date":1563735736,"creation_date":1563735736,"answer_id":1005282,"question_id":1004704,"body":"<p>С помощью рефлексии нельзя получить исходный код метода, так как рефлексия возвращает только ту информацию, которая есть в скомпилированной сборке. Рефлексия может дать IL-байткод метода, но не исходный код, ей неоткуда взять его. Исходный код нужно получать из каких-то других источников:</p>\n\n<p><strong>1) Отладочные символы</strong> </p>\n\n<p>Если получение исходного кода необходимо только на машине, где ведется разработка, можно воспользоваться отладочными символами. В PDB-файлах, генерируемых компилятором, хранится информация о соответствии строк файлов исходного кода инструкциям в IL-байткоде (именно благодаря этому отладчик может при возникновении исключения может указать на конкретную строку). Определив положение начала и конца метода, считать его код из исходников - дело техники. В символах присутствует каждый метод, который физически есть в сборке, в том числе и анонимные, поэтому решение вполне применимо и для условий из лямбда-выражений.   </p>\n\n<p>Так как символы ссылаются на исходники по абсолютным путям, чтобы он сработал на других машинах, проект понадобится перенести на них в точности по такому же пути, как он был расположен на машине разработчика. Естественно, необязательно распространять проект целиком - главное, чтобы файл с нужным методом был доступен.  </p>\n\n<p>Формат PDB не документирован, однако существует несколько библиотек с открытым исходным кодом от Microsoft для работы с ним, например <a href=\"https://github.com/microsoft/clrmd\" rel=\"nofollow noreferrer\">Microsoft.Diagnostics.Runtime</a>.</p>\n\n<p><strong>2) Декомпиляция</strong></p>\n\n<p>Если исходники недоступны или нет символов, можно воспользоваться одним из декомпиляторов, чтобы восстановить их из байткода на лету. Например, библиотека <a href=\"https://www.nuget.org/packages/ICSharpCode.Decompiler\" rel=\"nofollow noreferrer\">ICSharpCode.Decompiler</a>, движок декомпилятора <a href=\"https://github.com/icsharpcode/ILSpy\" rel=\"nofollow noreferrer\">ILSpy</a>, поддерживает декомпиляцию типа в синтаксическое дерево, которое можно обойти и найти нужный метод. В том числе, с помощью нее программа можно спокойно декомпилировать саму себя! Правда, чтобы корректно обрабатывать лямбды, придется отключить подстановку кода анонимных методов - в противном случае мы их в синтаксическом дереве не найдем.</p>\n\n<p>Пример получения исходного кода метода двумя данными способами:</p>\n\n<pre class=\"lang-cs prettyprint-override\"><code>using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Diagnostics;\nusing System.Reflection;\nusing Microsoft.Diagnostics.Runtime;\nusing Microsoft.Diagnostics.Runtime.Utilities.Pdb;\nusing ICSharpCode.Decompiler;\nusing ICSharpCode.Decompiler.CSharp;\nusing ICSharpCode.Decompiler.CSharp.Syntax;\n\nnamespace ConsoleTest1\n{\n    class Program\n    {       \n        public static string GetSourceFromPdb&lt;T&gt;(Predicate&lt;T&gt; match)\n        {            \n            int token = match.Method.MetadataToken;\n\n            //построим путь к файлу символов\n            string module_path = match.Method.Module.FullyQualifiedName;\n            string pdb_path = Path.Combine(\n                Path.GetDirectoryName(module_path),\n                Path.GetFileNameWithoutExtension(module_path) + \".pdb\"\n                );            \n\n            StringBuilder sb = new StringBuilder();\n            PdbReader reader = new PdbReader(pdb_path);\n\n            using (reader)\n            {\n                //найдем метод в символах\n                var func = reader.GetFunctionFromToken((uint)token);                \n\n                foreach (PdbSequencePointCollection coll in func.SequencePoints)\n                {\n                    //считываем файл исходников\n                    string[] lines = File.ReadAllLines(coll.File.Name, System.Text.Encoding.UTF8);                    \n\n                    //найдем номера строк в файле, соответствующие началу и концу метода\n                    var points_sorted = coll.Lines.\n                        Where&lt;PdbSequencePoint&gt;((x)=&gt; x.LineBegin &lt;= lines.Length &amp;&amp; x.LineEnd&lt;=lines.Length).\n                        OrderBy&lt;PdbSequencePoint, uint&gt;((x) =&gt; x.Offset);\n                    PdbSequencePoint start = points_sorted.First();\n                    PdbSequencePoint end = points_sorted.Last();   \n\n                    bool reading = false;\n                    int index_start;                    \n                    int index_end;\n\n                    //считаем код метода из исходников\n                    for(int i=1; i&lt;=lines.Length;i++)\n                    {\n                        string line = lines[i-1];\n                        index_start = 0;\n                        index_end = line.Length;\n\n                        if (!reading)\n                        {\n                            if (i &gt;= start.LineBegin)\n                            {\n                                //первая строка\n                                reading = true;\n                                index_start = start.ColBegin - 1;\n                                if (index_start &lt; 0) index_start = 0;                    \n                            }\n                        }                        \n\n                        if (reading)\n                        {\n                            if (i &gt;= end.LineEnd)\n                            {\n                                //последняя строка\n                                index_end = end.ColEnd - 1;\n                                if (index_end &gt; line.Length) index_end = line.Length;\n\n                                sb.AppendLine(line.Substring(index_start, index_end - index_start));\n                                break;\n                            }\n\n                            //считывание текущей строки\n                            sb.AppendLine(line.Substring(index_start, index_end - index_start));\n                        }  \n                    }      \n                }\n\n            }\n\n            return sb.ToString();\n        }\n\n        public static AstNode FindNode(AstNode root,string match)\n        {            \n            //поиск метода в синтаксическом дереве\n            var children = root.Children;\n\n            foreach (AstNode x in children)\n            {\n                var s = x.ToString();\n                if (s == match &amp;&amp; x.Parent.NodeType == NodeType.Member)\n                {\n                    return x.Parent;\n                }\n\n                AstNode res = FindNode(x, match);\n                if (res != null) return res;\n            }\n            return null;\n        }\n\n        public static string GetSourceDecompiled&lt;T&gt;(Predicate&lt;T&gt; match)\n        {        \n            string module_path = match.Method.Module.FullyQualifiedName;            \n\n            var settings = new DecompilerSettings();\n            settings.AnonymousMethods = false; //отключим подстановку кода анонимных методов         \n\n            var decompiler = new CSharpDecompiler( module_path, settings );            \n\n            //декомпилируем тип, содержащий метод\n            SyntaxTree tree = decompiler.DecompileType(\n                new ICSharpCode.Decompiler.TypeSystem.FullTypeName(match.Method.DeclaringType.FullName)\n                );\n\n            //найдем метод в синтаксическом дереве\n            var children = tree.Children.ToList();\n            AstNode res = null;\n            foreach (var x in children)\n            {\n                res = FindNode(x, match.Method.Name);\n                if (res != null) break;\n            }\n\n            string s = \"\";\n            if (res != null) s = res.ToString();\n            return s;\n        }        \n\n        static void Main(string[] args)\n        {\n            string source;\n            Console.WriteLine(\"*** Source from PDB: ***\");\n            source = GetSourceFromPdb&lt;string&gt;( (s) =&gt;  s == \"Test\"  ||  s.Length==0);            \n            Console.WriteLine(source);            \n\n            Console.WriteLine(\"*** Decompiled source: ***\");\n            source = GetSourceDecompiled&lt;string&gt;((s) =&gt; s == \"Test\" || s.Length==0);            \n            Console.WriteLine(source);            \n\n            Console.ReadKey();\n        }\n    }    \n}\n</code></pre>\n\n<p>Результат:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>*** Source from PDB: ***\ns == \"Test\"  ||  s.Length==0\n\n*** Decompiled source: ***\n[CompilerGenerated]\nprivate static bool &lt;Main&gt;b__6 (string s)\n{\n        return s == \"Test\" || s.Length == 0;\n}\n</code></pre>\n"}