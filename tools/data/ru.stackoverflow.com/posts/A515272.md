---
title: "Answer 515272"
se.owner.user_id: 17836
se.owner.display_name: "LXA"
se.owner.link: "https://ru.stackoverflow.com/users/17836/lxa"
se.answer_id: 515272
se.question_id: 513736
se.post_type: answer
se.score: 1
se.is_accepted: False
---
<p>Попробую резюмировать: легче избежать проблемы (продумав детально арифметику), чем потом ее (неприятно) обнаруживать и обрабатывать.</p>

<p>Решения с перехватом либо зависят от компилятора, либо представляют собой отказ от непосредственно встроенных типов. Полагаю, подходящим решением (кроме работы с памятью и коллекциями, разрешающими индексацию) может стать использование чисел с плавающей запятой, т.к. они более приближены к естественной арифметике (в плане бесконечностей, деления на 0).</p>

<p>В книге "24 смертных греха компьютерной безопасности" Ховарда, Лебланка, Вьеги встретил такое решение:</p>

<ul>
<li>учет размеров типов (см. другие ответы);</li>
<li>простота кода;</li>
<li>явное преобразование типов;</li>
<li>использование <a href="http://safeint.codeplex.com/" rel="nofollow">SafeInt</a> (by Дэвид Лебланк)</li>
<li>при использовании <code>gcc</code>, компилировать с флагом <code>-ftrapv</code> (при переполнении знаковых целочисленных вызывается <code>abort()</code>);</li>
<li>использование беззнаковых целых для работы с памятью и индексами массивов (слегка облегчает последствия);</li>
</ul>
