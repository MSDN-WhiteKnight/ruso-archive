{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1516771490,"creation_date":1516771490,"answer_id":774866,"question_id":654400,"body":"<p>Нужно использовать функцию <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms684919(v=vs.85).aspx\" rel=\"nofollow noreferrer\">QueryFullProcessImageName</a>. Она позволяет получить расположение файла для всех процессов, в том числе системных или другого пользователя (при наличии привилегий администратора), а также 64-разрядных процессов из 32-разрядного приложения. </p>\n\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;locale.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;tchar.h&gt;\n#include &lt;windows.h&gt;\n#include &lt;tlhelp32.h&gt;\n#include &lt;psapi.h&gt;    \n\nvoid ErrorMes(LPTSTR lpszFunction) \n{ \n    // Retrieve the system error message for the last-error code\n\n    LPVOID lpMsgBuf;\n    LPVOID lpDisplayBuf;\n    DWORD dw = GetLastError(); \n\n    FormatMessage(\n        FORMAT_MESSAGE_ALLOCATE_BUFFER | \n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,\n        dw,\n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n        (LPTSTR) &amp;lpMsgBuf,\n        0, NULL );\n\n    // Display the error message \n\n    lpDisplayBuf = (LPVOID)LocalAlloc(LMEM_ZEROINIT, \n        (lstrlen((LPCTSTR)lpMsgBuf) + lstrlen((LPCTSTR)lpszFunction) + 40) * sizeof(TCHAR)); \n    wprintf(L\"%s failed with error %d: %s\", \n        lpszFunction, dw, lpMsgBuf);     \n\n    LocalFree(lpMsgBuf);\n    LocalFree(lpDisplayBuf);\n\n}\n\n\nint main()\n{\n    HANDLE hProcess=NULL;\n    HANDLE hToken;\n    HANDLE snapshot;\n    TCHAR filename[MAX_PATH];\n    DWORD charsCarried = MAX_PATH;\n    PROCESSENTRY32 process;\n    int count = 0;\n\n    setlocale(LC_ALL,\"Russian\");\n\n    snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    process.dwSize = sizeof(PROCESSENTRY32);\n\n    if (snapshot != INVALID_HANDLE_VALUE)\n    {\n        if (Process32First(snapshot, &amp;process))\n        {\n            do\n            {\n                wprintf(L\"PID: %d, Name: %s, CountThreads: %d\\n\",                    \n                    process.th32ProcessID,\n                    process.szExeFile,\n                    process.cntThreads);                                \n\n                /*get process handle*/\n                hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, process.th32ProcessID);\n                if(hProcess==NULL){\n                    ErrorMes(L\"OpenProcess\");\n                    wprintf(L\"\\n\");\n                    continue;\n                }\n\n                charsCarried=MAX_PATH;\n\n                /* get executable name*/\n                if(QueryFullProcessImageName(hProcess,0,filename,&amp;charsCarried)!=FALSE)\n                {\n                    wprintf(L\"%s\\n\",                    \n                    filename);\n                }\n                else\n                {\n                    ErrorMes(L\"QueryFullProcessImageName\");\n                    wprintf(L\"\\n\");\n                }\n                wprintf(L\"\\n\");\n\n                CloseHandle(hProcess);  \n                hProcess = NULL;\n            } \n            while (Process32Next(snapshot, &amp;process));\n        }\n    }\n    else\n    {\n        ErrorMes(L\"CreateToolhelp32Snapshot\");\n    }\n\n    if(hProcess!=NULL)CloseHandle(hProcess);\n    CloseHandle(snapshot);\n    system(\"PAUSE\");\n    return 0;\n}\n</code></pre>\n"}