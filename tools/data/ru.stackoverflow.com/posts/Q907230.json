{"tags":["c#",".net","исключения"],"owner":{"reputation":22878,"user_id":32793,"user_type":"registered","accept_rate":48,"profile_image":"https://i.stack.imgur.com/6Vktl.jpg?s=128&g=1","display_name":"iluxa1810","link":"https://ru.stackoverflow.com/users/32793/iluxa1810"},"is_answered":true,"view_count":203,"accepted_answer_id":907269,"answer_count":2,"score":10,"last_activity_date":1547542573,"creation_date":1542357390,"last_edit_date":1542441794,"question_id":907230,"link":"https://ru.stackoverflow.com/questions/907230/%d0%9f%d0%be%d1%87%d0%b5%d0%bc%d1%83-%d0%bf%d0%b5%d1%80%d0%b5%d0%bf%d0%be%d0%bb%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5-%d1%81%d1%82%d0%b5%d0%ba%d0%b0-%d0%b2-%d0%b4%d0%be%d1%87%d0%b5%d1%80%d0%bd%d0%b5%d0%bc-%d0%bf%d0%be%d1%82%d0%be%d0%ba%d0%b5-%d1%83%d0%b1%d0%b8%d0%b2%d0%b0%d0%b5%d1%82-%d0%b2%d0%b5%d1%81%d1%8c-%d0%bf%d1%80%d0%be%d1%86%d0%b5%d1%81%d1%81","title":"Почему переполнение стека в дочернем потоке убивает весь процесс?","body":"<p>Отвечая на этот <a href=\"https://ru.stackoverflow.com/questions/907181/%D0%92%D0%BE%D0%B7%D0%BD%D0%B8%D0%BA%D0%BD%D0%BE%D0%B2%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA-%D0%B2-%D0%B4%D1%80%D1%83%D0%B3%D0%BE%D0%BC-%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%B5-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-c\">вопрос</a> был удивлен, что переполнение стека в дочернем потоке убивает процесс целиком.</p>\n\n<p>Собственно, вопрос:</p>\n\n<p>А почему так происходит? Ведь каждый поток имеет собственный стек, даже, на сколько я помню, Рихтер писал об этом.</p>\n\n<p>Даже <code>StackTrace().FrameCount</code> показывает различное кол-во фреймов в основном потоке и дочернем.</p>\n\n<p>В С++- это обрабатываемое исключение, если верить комментариям из предыдущего вопроса, а в <code>.NET</code> нет, так как возможно, как я понимаю, что СLR, которой нужно что-то сделать, может повредится из-за не хватки стека.</p>\n\n<p><code>CLR</code>, по идее, одна на все приложение и она точно не крутится в дочернем потоке.</p>\n\n<p>Получается, что запуская чужой код, к исходникам которого мы не имеем доступа, хоть в отдельном потоке, хоть в отдельном домене, то мы все равно падаем и в .NET никак нельзя предотвратить это при таком типе исключения?</p>\n\n<p><strong>UPD</strong></p>\n\n<p>Есть какие-то \"Области с ограничением выполнения\" CER, где можно указать, что метод может поверить процесс. Это никак не оказывает влияния на CLR, что бы она подготовилась и не умерла?</p>\n"}