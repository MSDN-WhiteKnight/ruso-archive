{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":1,"last_activity_date":1534314739,"last_edit_date":1534314739,"creation_date":1534159607,"answer_id":868062,"question_id":866956,"body":"<p>Объект ImageSource обычно может использоваться только из потока, в котором он был создан. Необходимо вызвать <code>image.Freeze()</code> после завершения загрузки изображения (т.е., вызова <code>image.EndInit()</code>), если вы хотите использовать его в других потоках (после этого он станет неизменяемым). См. <a href=\"https://docs.microsoft.com/ru-ru/dotnet/framework/wpf/advanced/freezable-objects-overview\" rel=\"nofollow noreferrer\">Freezable Objects Overview</a></p>\n\n<hr>\n\n<p>Также, если ImageSource указывает на HTTP URL, его загрузка осуществляется асинхронно. Поэтому перед вызовом Freeze нужно дождаться его загрузки, при этом выполняя обработку событий WPF в потоке. Для этого понадобится вспомогательный метод:</p>\n\n<pre><code>using System.Windows.Threading;\n\npublic static void DoWpfEvents()\n{\n      DispatcherFrame frame = new DispatcherFrame();\n      Dispatcher.CurrentDispatcher.BeginInvoke(DispatcherPriority.Background,\n           new DispatcherOperationCallback((f) =&gt;\n           {\n               ((DispatcherFrame)f).Continue = false; return null;\n           }), frame);\n      Dispatcher.PushFrame(frame);\n } \n</code></pre>\n\n<p>Ожидание можно выполнить так:</p>\n\n<pre><code>BitmapImage image = new BitmapImage();\nimage.BeginInit();\nimage.UriSource = new Uri(\"http://example.com/image_\" + slideId.ToString() + \".png\");\nimage.CacheOption = BitmapCacheOption.OnLoad;\nimage.EndInit();\n\nwhile (image.IsDownloading) { DoWpfEvents(); Thread.Sleep(100); }                     \n\nimage.Freeze();\n</code></pre>\n\n<p>Но лучше воспользоваться советом из <a href=\"https://ru.stackoverflow.com/a/867086/240512\">соседнего ответа</a> и создать изображение в основном потоке (он на самом деле работает, если все сделать правильно):</p>\n\n<pre><code>BitmapImage image=null;\n\nApplication.Current.Dispatcher.Invoke(() =&gt; {\n    image = new BitmapImage();\n    image.BeginInit();\n    image.UriSource = new Uri(\"http://example.com/image_\" + slideId.ToString() + \".png\");        \n    image.EndInit();\n\n});\n</code></pre>\n"}