{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":3,"last_activity_date":1536858503,"last_edit_date":1536858503,"creation_date":1536838354,"answer_id":880893,"question_id":880745,"body":"<p>Несовместимость бинарных модулей (далее, для краткости, просто \"модулей\"), произведенных разными компиляторами, определяется в основном следующими тремя аспектами:</p>\n\n<ol>\n<li><p>Разные правила декорирования имен экспортируемых символов</p></li>\n<li><p>Разное устройство объектов стандартной библиотеки</p></li>\n<li><p>Разные правила расположения полей структур в памяти</p></li>\n</ol>\n\n<p>Первый пункт характерен фактически только для С++: в Си существует набор характерных для конкретной аппаратной платформы соглашений о вызове (например, stdcall, fastcall и cdecl для x86), которые довольно четко прописывают правила декорирования имен. Второй пункт относится и к Си и к С++, но в Си не очень много \"объектов стандартной библиотеки\" - в голову приходит только FILE*, и экспортировать его через границы модулей нет никакого смысла. </p>\n\n<p>Таким образом да, действительно можно сказать, что С++ \"хуже\" чем Си в плане бинарной совместимости. Это разумеется не значит, что не нужно на нем писать, это лишь значит, что на границе модулей нужно использовать интерфейс в стиле Си (либо использовать стандартизированный объектно-ориентированный интерфейс, например Component Object Model в Windows). </p>\n\n<blockquote>\n  <p>Есть ли способы делать двоичные библиотеки максимально совместимыми? Чтобы написанная однажды библиотека dll могла быть подключена в самых разных языках без боли и страданий?</p>\n</blockquote>\n\n<p>Использование DLL на С/С++ в других языках это больше чем вопрос бинарного интерфейса (например, в них может просто не быть концепции заголовочных файлов, указателей и т.п.), но обычно да, библиотека с интерфейсом в стиле Си может быть использована и из других языков с тем или иным количеством дополнительных телодвижений. </p>\n\n<p>Рекомендации для обеспечения максимальной бинарной совместимости: </p>\n\n<ul>\n<li><p>Экспортируйте через границы бинарного модуля только простые функции с припиской <code>extern \"C\"</code> (т.е, никаких классов, шаблонов, перегруженных функций, пространств имен и т.п.)</p></li>\n<li><p>Передавайте через границы модулей только простые типы, указатели на них и указатели на функции.</p></li>\n<li><p>Если все же передаете структуры, сделайте первым членом структуры ее размер. Это позволит, если вы натолкнетесь на различия по выравниванию полей, обнаружить несоответствие в общем размере структуры и хотя бы нормально вернуть ошибку. </p></li>\n<li><p>Не передавайте через границы модулей объекты стандартной библиотеки, например указатели FILE*.</p></li>\n<li><p>Блоки динамической памяти должны освобождаться всегда в том же модуле, в котором были выделены. Т.е., если библиотека возвращает программе-клиенту указатель на блок памяти, выделенный malloc внутри себя, она должна предоставлять специальную функцию для его освобождения (вызывающую внутри себя free), вместо того, чтобы полагаться на вызов free в программе-клиенте.</p></li>\n</ul>\n"}