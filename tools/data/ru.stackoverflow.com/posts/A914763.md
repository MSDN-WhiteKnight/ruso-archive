---
title: "Answer 914763"
se.owner.user_id: 267609
se.owner.display_name: "ffk"
se.owner.link: "https://ru.stackoverflow.com/users/267609/ffk"
se.answer_id: 914763
se.question_id: 914740
se.post_type: answer
se.score: 2
se.is_accepted: False
---
<p>Чтоб работать с бинарной сереализацией надо гарантировать, что C++, будет генерить одинаковую структуру при любых опциях компиляции. По умолчанию, размер структуры не обязан совпадать с суммой размеров всех полей, т.к. все поля структуры выравниваются по своему размеру. Например, <code>int16_t</code> поле должно лежать по смещению кратному 2, <code>int32_t</code> - кратно 4 и т.д.</p>

<p>В твоем примере поля engine_enabled и trailer_attached имеют тип bool, что занимает по байту каждое, а вот поле speed имеет размер 4 байта и компилятор попытается его разместить со смещение 4 от начала структуры <code>tel_rev1</code>, т.е между двумя булами и флоатом будет дополнительная дырка в 2 байта.</p>

<p>Далее, типа int и long в разных архитектурах могут иметь разный размер, что нормально сериализоваться, замени их типы фиксированного размера, например, <code>int32_t</code></p>

<p>Далее, чтоб быть уверенным что структура "не поплыла", надо вставить <code>static_assert</code> с проверкой размеров и смещений. Типа такого:</p>

<pre><code>typedef struct ets2TelemetryMap_s
{
    ...
};
static_assert(sizeof(ets2TelemetryMap_s) == 1024, "error"); // И сколько там должно быть?
static_assert(sizeof(ets2TelemetryMap_s::tel_revId) == 12, "error");
..
static_assert(sizeof(ets2TelemetryMap_s::tel_rev4) == 152, "error");
static_assert(offsetof(ets2TelemetryMap_s::tel_revId) == 8, "error") // &lt;-- проверяем что ключевые поля лежат по правильным смещениям
...
static_assert(offsetof(ets2TelemetryMap_s, tel_rev5.jobFinished) == 1021, "error")
</code></pre>

<p>После это, можно использовать бинарную сереализацию, про big-endian и litle-endian не забываем.</p>

<p>P.S. #pragma pack(1) не советую, дурная практика для данной затеии. IMHO</p>
