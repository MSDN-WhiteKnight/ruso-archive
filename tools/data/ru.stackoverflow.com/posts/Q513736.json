{"tags":["c++","c","ассемблер","x86","integer-overflow"],"owner":{"reputation":1294,"user_id":17836,"user_type":"registered","accept_rate":100,"profile_image":"https://i.stack.imgur.com/6WwHZ.jpg?s=128&g=1","display_name":"LXA","link":"https://ru.stackoverflow.com/users/17836/lxa"},"is_answered":true,"view_count":5601,"accepted_answer_id":513775,"answer_count":5,"score":22,"last_activity_date":1561875261,"creation_date":1460839549,"question_id":513736,"link":"https://ru.stackoverflow.com/questions/513736/%d0%9c%d0%be%d0%b6%d0%bd%d0%be-%d0%bb%d0%b8-%d0%bd%d0%b0-%d1%8f%d0%b7%d1%8b%d0%ba%d0%b0%d1%85-c-c-%d0%be%d0%bf%d1%80%d0%b5%d0%b4%d0%b5%d0%bb%d0%b8%d1%82%d1%8c-%d1%86%d0%b5%d0%bb%d0%be%d1%87%d0%b8%d1%81%d0%bb%d0%b5%d0%bd%d0%bd%d0%be%d0%b5-%d0%bf%d0%b5%d1%80%d0%b5%d0%bf%d0%be%d0%bb%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5","title":"Можно ли на языках C/C++ определить целочисленное переполнение?","body":"<p>Часто в контексте безопасного программирования упоминают проблему целочисленного переполнения (<strong>integer overflow</strong>). А возможно ли отловить эту ситуацию в C/C++ коде? Ведь процессоры (по крайней мере x86) имеют среди <code>EFLAGS</code> флаг <code>Overflow Flag</code>, получается, что чисто технически такая возможность имеется, да и оверхэд на проверку флага в регистре не должен быть большим (думается так). Либо проблема в постановке вопроса и переполнение нужно не отлавливать, а не допускать никогда? Значит ли последнее, что целочисленные типы принципиально не подходят для любых вычислений?</p>\n\n<p>P.S. Вопрос возник в связи с тем, что в существующем коде (наблюдаемом мной) широко используется <code>int</code> для арифметических расчетов и ничто не защищает от переполнений, гипотетически они могут остаться незамеченными (логикой). И в большинстве случаев с большой вероятностью все в норме (реальные значения невелики), но иногда...</p>\n"}