---
title: "Answer 785790"
se.owner.user_id: 10105
se.owner.display_name: "VladD"
se.owner.link: "https://ru.stackoverflow.com/users/10105/vladd"
se.answer_id: 785790
se.question_id: 785708
se.post_type: answer
se.score: 2
se.is_accepted: False
---
<p>Нет, то, что вы хотите, невозможно.</p>

<p>Вы собираетесь вернуть <em>ссылку</em> на поле <code>m_hide_ptr_</code>. Это поле, вместе со всем объектом, находится в управляемой куче, и, следовательно, может быть перемещено вместе с объектом. Хотя сборщик мусора при этом и обновляет <em>управляемые</em> ссылки, вашу неуправляемую ссылку он не обновит, поэтому взятие такой ссылки запрещено.</p>

<p>Без ссылки код компилируется:</p>

<pre><code>static void* operator &amp;(const SomePtr^ value)
{
    return value-&gt;m_hide_ptr_;
}
</code></pre>

<p>(ну и ещё вам следует объявить его открытым, а то им никто не сможет воспользоваться).</p>

<p>Но при этом ваша цель — получить адрес поля/ссылку на поле — не достигается. Повторюсь, адрес переменной в управляемой куче вам взять не дадут, а если вы каким-то извращённым способом и исхитритесь, первый же пробег сборщика мусора превратит ваш указатель/ссылку в висящий.</p>

<hr>

<p>На уровне C# вы не можете вызвать ваш перегруженный оператор <code>&amp;</code> потому, что с точки зрения C# перегружать унарный <code>&amp;</code> нельзя. Поэтому C# трактует <code>&amp;</code> как взятие адреса, а брать адрес управляемого объекта <a href="https://docs.microsoft.com/en-us/dotnet/csharp/misc/cs0208" rel="nofollow noreferrer">нельзя</a>.</p>

<p>Вы можете, по идее, выкрутится, вызвав операцию напрямую:</p>

<pre><code>SomePtr obj = new SomePtr();
unsafe
{
    void* p = SomePtr.op_AddressOf(obj);
}
</code></pre>

<p>В этом случае, вероятно, имеет смысл назвать использовать обыкновенную функцию-член. Но это, снова-таки, для случая, если ваш оператор возвращает чистый указатель, а не ссылку.</p>
