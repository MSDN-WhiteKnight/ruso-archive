{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":1,"last_activity_date":1515647275,"creation_date":1515647275,"answer_id":769179,"question_id":767263,"body":"<p>Один из тех случаев, когда ответ - \"Пожалуйста, не делайте этого\". Изменять ассоциации для EXE файлов - плохая идея.</p>\n\n<p>Во-первых, это работает только для запуска путем открытия файла в проводнике. Это не распространяется на другие способы запуска программ - через ярлыки, функцию \"Открыть с помощью\", командную строку и т.п. Во-вторых, если что-то пойдет не так, пользователь не сможет открыть в проводнике ни один EXE-файл.</p>\n\n<p>Также антивирусные программы могут воспринимать это как подозрительное поведение (так как некоторые вирусы используют эту методику) и заблокировать или удалить вашу программу. </p>\n\n<hr>\n\n<p>Не понимаю также, зачем вам устанавливать свойство <code>RedirectStandardOutput</code>. Оно создает связь между дочерним и родительским процессами, которая может привести к возможным проблемам. Если приложение консольное, текст в консоли не будет выводиться. </p>\n\n<p>Далее, передача в <code>ProcessStartInfo</code> строки <code>\"%1 %*\"</code> не имеет никакого смысла. Запись с процентами - это не настоящие параметры, а подстановочный знак, который проводник меняет на конкретные параметры при вызове ассоциированной программы (%* означает все параметры). Вероятно, больший смысл бы имело в реестр запихать команду <code>\"MyApp.exe %*\"</code>, чтобы вашей программе передавались все параметры, и потом соответственно, все содержимое args объединять и передавать в <code>ProcessStartInfo</code>. Но все равно, я не думаю, что это рабочий способ.</p>\n\n<hr>\n\n<p>Если вам нужно отслеживать запуск программ и выполнять определенные действия, можно найти лучшее решение:</p>\n\n<ul>\n<li><p>Отслеживание события WMI <a href=\"https://msdn.microsoft.com/en-us/library/aa394649(v=vs.85).aspx\" rel=\"nofollow noreferrer\">InstanceCreationEvent</a> для Win32_Process (уведомление приходит с задержкой минимум в 1 секунду).</p></li>\n<li><p>Использование библиотеки <a href=\"https://blogs.msdn.microsoft.com/vancem/2013/03/09/using-traceevent-to-mine-information-in-os-registered-etw-providers/\" rel=\"nofollow noreferrer\">TraceEvent</a> (также имеется некоторая задержка уведомления)</p></li>\n<li><p>Разработать драйвер уровня ядра, и использовать функцию <a href=\"https://msdn.microsoft.com/en-us/library/windows/hardware/ff559951(v=vs.85).aspx\" rel=\"nofollow noreferrer\">PsSetCreateProcessNotifyRoutine</a> для подписки на глобальное событие создания процесса </p></li>\n<li><p>Перехват функции kernel32.dll CreateProcessInternal, как предлагает ответ пользователя Максим.</p></li>\n</ul>\n\n<p>Пример для отслеживания запуска процесса через WMI:</p>\n\n<pre><code>using System;\nusing System.Management;\n\n//https://msdn.microsoft.com/en-us/library/system.management.managementeventwatcher(v=vs.110).aspx\n\npublic class EventWatcherPolling\n{\n    public static int Main(string[] args)\n    {\n        // Create event query to be notified within 1 second of \n        // a change in a service\n        WqlEventQuery query =\n            new WqlEventQuery(\"__InstanceCreationEvent\",\n            TimeSpan.FromSeconds(1),\n            \"TargetInstance isa \\\"Win32_Process\\\"\");\n\n        // Initialize an event watcher and subscribe to events \n        // that match this query\n        ManagementEventWatcher watcher =\n            new ManagementEventWatcher();\n        watcher.Query = query;        \n\n        // Block until the next event occurs         \n        Console.WriteLine(\n            \"Waiting for events...\");\n\n        ManagementBaseObject e;\n\n        while (true)\n        {\n            try\n            {\n                e = watcher.WaitForNextEvent();\n\n                //Display information from the event\n                Console.WriteLine(\n                    \"Process {0} has been created, path is: {1}, id is {2}\",\n                    ((ManagementBaseObject)e[\"TargetInstance\"])[\"Name\"],\n                    ((ManagementBaseObject)e[\"TargetInstance\"])[\"ExecutablePath\"],\n                    ((ManagementBaseObject)e[\"TargetInstance\"])[\"ProcessId\"]\n                    );\n\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.ToString());\n                Console.ReadKey();\n            }\n        }        \n\n        return 0;\n    }\n}\n</code></pre>\n"}