{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":0,"last_activity_date":1571724693,"last_edit_date":1571724693,"creation_date":1571641256,"answer_id":1036837,"question_id":1036663,"body":"<blockquote>\n  <p>История: исполнение WriteConsoleOutputW занимает с каждым последующим обновлением занимает все больше времени, при чем размер буфера не меняется. Изначально была идея вынести вывод в отдельный поток, но оно все еще занимает 74-76 мс, что невероятно долго. </p>\n</blockquote>\n\n<p>Хотелось бы увидеть, на каком размере буфера и в какой ОС вывод занимает так долго. У меня на Windows 10 при буфере 100х50 среднее время 0.1 - 0.2 мс, вот код для тестирования:</p>\n\n<pre><code>#include &lt;windows.h&gt; \n#include &lt;stdio.h&gt;\n\nconst int W = 100; //ширина области рисования\nconst int H = 50; //высота области рисования\nCHAR_INFO chiBuffer[W*H] = { 0 };\nCOORD coordBufSize;\nCOORD coordBufCoord;\nHANDLE hStdout;\nSMALL_RECT srctWriteRect;\n\nvoid Render(int pos) {\n\n    //рисуем звездочку в заданной позиции\n    for (int i = 0; i &lt; sizeof(chiBuffer) / sizeof(CHAR_INFO); i++) {\n        chiBuffer[i].Attributes = FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_GREEN | BACKGROUND_BLUE;\n\n        if (i == pos) chiBuffer[i].Char.UnicodeChar = L'*';\n        else chiBuffer[i].Char.UnicodeChar = L' ';\n    }\n\n    srctWriteRect.Top = 0;\n    srctWriteRect.Left = 0;\n    srctWriteRect.Bottom = H;\n    srctWriteRect.Right = W;\n\n    BOOL fSuccess = WriteConsoleOutputW(\n        hStdout, // screen buffer to write to \n        chiBuffer,        // buffer to copy from \n        coordBufSize,     // col-row size of chiBuffer \n        coordBufCoord,    // top left src cell in chiBuffer \n        &amp;srctWriteRect);  // dest. screen buffer rectangle  \n\n    if (!fSuccess)\n    {\n        printf(\"WriteConsoleOutput failed - (%d)\\n\", GetLastError());       \n    }   \n}\n\nint main(void)\n{   \n    BOOL fSuccess;  \n\n    hStdout = GetStdHandle(STD_OUTPUT_HANDLE);\n    coordBufSize.Y = H;\n    coordBufSize.X = W;\n    coordBufCoord.X = 0;\n    coordBufCoord.Y = 0;\n\n    // Set the destination rectangle. \n\n    srctWriteRect.Top = 0;\n    srctWriteRect.Left = 0;\n    srctWriteRect.Bottom = H;\n    srctWriteRect.Right = W;        \n\n    const int N_RUNS = 50; //число запусков в пределах одного теста\n    const int N_TESTS = 50; //число тестов\n    float tsum = 0;\n    DWORD t1;\n    DWORD t2;\n\n    Render(0);\n    int pos = 1;\n\n    for (int i = 0; i &lt; N_TESTS; i++) {\n\n        t1 = GetTickCount();\n        for (int j = 0; j &lt; N_RUNS; j++) {\n\n            Render(pos);\n            pos++;\n            if (pos &gt;= W * H)pos = 0;\n        }\n        t2 = GetTickCount();\n        tsum += (t2 - t1)/(float)N_RUNS; //определим длительность отрисовки в пределах одного теста     \n    }\n\n    //выведем среднее время отрисовки   \n    wchar_t s[100] = L\"\";       \n    swprintf(s,100,L\"Render time = %.3f ms\\n\", tsum / (float)N_TESTS);\n    MessageBoxW(GetConsoleWindow(), s, L\"Results\", MB_OK);\n    getchar();\n\n    return 0;\n}\n</code></pre>\n\n<p>Но я слышал, что на Windows 7 и ранее консоль рисует медленнее.</p>\n\n<blockquote>\n  <p>Последнее что пришло в голову - разделить буфер на несколько частей и выводить их в нескольких потоках.</p>\n</blockquote>\n\n<p>Идея распараллелить что-то с целью его ускорения редко является хорошей. Начать с того, что код может выполняться на компьютере с одним процессорным ядром, тогда \"ускорение\" в реальности обернется замедлением. Но даже если ядер несколько, реальный эффект от параллельности проявится только когда потоки не конкурируют за общие ресурсы. В случае консоли, я подозреваю, что там внутренне работает свой механизм синхронизации, и эффекта не будет.</p>\n\n<blockquote>\n  <p>Однако как я выяснил CreateThread запускает функции сразу после создания</p>\n</blockquote>\n\n<p>Это не совсем так. Есть флаг <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread\" rel=\"nofollow noreferrer\">CREATE_SUSPENDED</a>:</p>\n\n<blockquote>\n  <p>The thread is created in a suspended state, and does not run until the ResumeThread function is called.</p>\n</blockquote>\n\n<p>Но для вашей задачи это никак не поможет.</p>\n\n<hr>\n\n<p>Реальная оптимизация, которая здесь могла бы помочь - это вместо вывода всего буфера проверять, какие области изменились, и выводить только их. Если на каждом шаге не весь экран изменяется, это может дать серьезное ускорение.</p>\n\n<hr>\n\n<h2>Дополнение</h2>\n\n<p>Если попробовать на большом буфере и распараллелить вот так с синхронизацией через события:</p>\n\n<pre><code>#include &lt;windows.h&gt; \n#include &lt;stdio.h&gt;\n\nvoid Render1();\nvoid Render2();\n\nconst int W = 640; //ширина области рисования\nconst int H = 320; //высота области рисования\nCHAR_INFO chiBuffer[W*H] = { 0 };\nHANDLE hStdout;\n\n//первая часть\nCOORD coordBufSize1;\nCOORD coordBufCoord1;\nSMALL_RECT srctWriteRect1;\n\n//вторая часть\nCOORD coordBufSize2;\nCOORD coordBufCoord2;\nSMALL_RECT srctWriteRect2;\n\n//события для синхронизации\nHANDLE evtRendering1;\nHANDLE evtRendering2;\nHANDLE evtRendered1;\nHANDLE evtRendered2;\n\nDWORD WINAPI ThreadProc1(LPVOID lpThreadParameter) {\n    while (1) {\n        WaitForSingleObject(evtRendering1, INFINITE); //ждем сигнала\n        ResetEvent(evtRendering1);\n\n        //выводим первую половину\n        Render1();\n\n        //сообщаем о завершении\n        SetEvent(evtRendered1);\n    }\n}\n\nDWORD WINAPI ThreadProc2(LPVOID lpThreadParameter) {\n    while (1) {\n        WaitForSingleObject(evtRendering2, INFINITE); //ждем сигнала\n        ResetEvent(evtRendering2);\n\n        //выводим первую половину\n        Render2();\n\n        //сообщаем о завершении\n        SetEvent(evtRendered2);\n    }\n}\n\nvoid FillBuffer(int pos) {\n    //рисуем звездочку в заданной позиции\n    for (int i = 0; i &lt; sizeof(chiBuffer) / sizeof(CHAR_INFO); i++) {\n        chiBuffer[i].Attributes = FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_GREEN | BACKGROUND_BLUE;\n\n        if (i == pos) chiBuffer[i].Char.UnicodeChar = L'*';\n        else chiBuffer[i].Char.UnicodeChar = L' ';\n    }\n}\n\nvoid Render1() {            \n\n    srctWriteRect1.Top = 0;\n    srctWriteRect1.Left = 0;\n    srctWriteRect1.Bottom = H/2;\n    srctWriteRect1.Right = W;\n\n    BOOL fSuccess = WriteConsoleOutputW(\n        hStdout, // screen buffer to write to \n        chiBuffer,        // buffer to copy from \n        coordBufSize1,     // col-row size of chiBuffer \n        coordBufCoord1,    // top left src cell in chiBuffer \n        &amp;srctWriteRect1);  // dest. screen buffer rectangle     \n\n    if (!fSuccess)\n    {\n        printf(\"Render1: WriteConsoleOutput failed - (%d)\\n\", GetLastError());      \n    }   \n}\n\nvoid Render2() {\n\n    srctWriteRect2.Top = H / 2;\n    srctWriteRect2.Left = 0;\n    srctWriteRect2.Bottom = H;\n    srctWriteRect2.Right = W;\n\n    BOOL fSuccess = WriteConsoleOutputW(\n        hStdout, // screen buffer to write to \n        &amp;(chiBuffer[W*H/2]),        // buffer to copy from \n        coordBufSize2,     // col-row size of chiBuffer \n        coordBufCoord2,    // top left src cell in chiBuffer \n        &amp;srctWriteRect2);  // dest. screen buffer rectangle     \n\n    if (!fSuccess)\n    {\n        printf(\"Render2: WriteConsoleOutput failed - (%d)\\n\", GetLastError());\n    }\n}\n\nvoid Render(BOOL parallel) {\n\n    if (parallel != FALSE) {\n        //запускаем оба потока\n        SetEvent(evtRendering1);\n        SetEvent(evtRendering2);\n\n        HANDLE ha[2] = { evtRendered1,evtRendered2 };\n\n        //ждем завершения вывода\n\n        DWORD dwWaitResult = WaitForMultipleObjects(\n            2,   // number of handles in array\n            ha,     // array of handles\n            TRUE,          // wait until all are signaled\n            INFINITE);\n\n        switch (dwWaitResult)\n        {\n            // All objects were signaled\n            case WAIT_OBJECT_0: break;\n\n            // An error occurred\n            default:\n            printf(\"WaitForMultipleObjects failed (%d)\\n\", GetLastError());\n            break;\n        }\n\n        ResetEvent(evtRendered1);\n        ResetEvent(evtRendered2);\n    }\n    else {\n        Render1();\n        Render2();\n    }\n}\n\nint main(void)\n{   \n    BOOL fSuccess;  \n\n    hStdout = GetStdHandle(STD_OUTPUT_HANDLE);\n    coordBufSize1.Y = H/2;\n    coordBufSize1.X = W;\n    coordBufCoord1.X = 0;\n    coordBufCoord1.Y = 0;\n\n    coordBufSize2.Y = H / 2;\n    coordBufSize2.X = W;\n    coordBufCoord2.X = 0;\n    coordBufCoord2.Y = 0/*H / 2*/;\n\n    // Set the destination rectangle. \n\n    srctWriteRect1.Top = 0;\n    srctWriteRect1.Left = 0;\n    srctWriteRect1.Bottom = H/2;\n    srctWriteRect1.Right = W;   \n\n    srctWriteRect2.Top = H / 2;\n    srctWriteRect2.Left = 0;\n    srctWriteRect2.Bottom = H;\n    srctWriteRect2.Right = W;\n\n    const int N_TESTS = 500; //число тестов\n    DWORD tsum = 0;\n    DWORD t1;\n    DWORD t2;\n\n    evtRendering1 = CreateEvent(\n        NULL,               // default security attributes\n        TRUE,               // manual-reset event\n        FALSE,              // initial state is nonsignaled\n        TEXT(\"evtRendering1\")  // object name\n    );\n\n    evtRendering2 = CreateEvent(\n        NULL,               // default security attributes\n        TRUE,               // manual-reset event\n        FALSE,              // initial state is nonsignaled\n        TEXT(\"evtRendering2\")  // object name\n    );\n\n    evtRendered1 = CreateEvent(\n        NULL,               // default security attributes\n        TRUE,               // manual-reset event\n        FALSE,              // initial state is nonsignaled\n        TEXT(\"evtRendered1\")  // object name\n    );\n\n    evtRendered2 = CreateEvent(\n        NULL,               // default security attributes\n        TRUE,               // manual-reset event\n        FALSE,              // initial state is nonsignaled\n        TEXT(\"evtRendered2\")  // object name\n    );\n\n    HANDLE hThread = CreateThread(\n        NULL,              // default security\n        0,                 // default stack size\n        ThreadProc1,        // name of the thread function\n        NULL,              // no thread parameters\n        0,                 // default startup flags\n        NULL);\n\n    if (hThread == NULL)\n    {\n        printf(\"CreateThread failed (%d)\\n\", GetLastError());\n        return 1;\n    }\n\n    hThread = CreateThread(\n        NULL,              // default security\n        0,                 // default stack size\n        ThreadProc2,        // name of the thread function\n        NULL,              // no thread parameters\n        0,                 // default startup flags\n        NULL);\n\n    if (hThread == NULL)\n    {\n        printf(\"CreateThread failed (%d)\\n\", GetLastError());\n        return 1;\n    }\n\n    /* *** Начало теста *** */\n    BOOL parallel = TRUE;\n    FillBuffer(0);\n    Render(parallel);\n    int pos = 1;\n\n    for (int i = 0; i &lt; N_TESTS; i++) {\n\n        FillBuffer(pos);\n        t1 = GetTickCount();                                \n        Render(parallel);\n        t2 = GetTickCount();\n        pos++;\n        if (pos &gt;= W * H)pos = 0;\n\n        tsum += (t2 - t1); //определим длительность отрисовки в пределах одного теста       \n    }\n\n    //выведем среднее время отрисовки   \n    wchar_t s[100] = L\"\";       \n    swprintf(s,100,L\"Render time = %.3f ms\\n\", tsum / (float)N_TESTS);\n    MessageBoxW(GetConsoleWindow(), s, L\"Results\", MB_OK);\n    getchar();\n\n    return 0;\n}\n</code></pre>\n\n<p>То получается</p>\n\n<ul>\n<li>без параллельности: 1.2 мс</li>\n<li>с параллельностью: 1.6 мс</li>\n</ul>\n\n<p>То есть вроде как пользы от распараллеливания нет, даже наоборот, получается медленнее за счет накладных расходов на ожидание.</p>\n"}