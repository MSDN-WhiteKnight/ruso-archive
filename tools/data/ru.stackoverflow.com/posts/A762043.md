---
title: "Answer 762043"
se.owner.user_id: 222542
se.owner.display_name: "Bulson"
se.owner.link: "https://ru.stackoverflow.com/users/222542/bulson"
se.answer_id: 762043
se.question_id: 753484
se.post_type: answer
se.score: 2
se.is_accepted: False
---
<p>Как я понял вам важно сохранять видеокадры в файлы, причем желательно обрабатывать несколько видеофайлов одновременно. Потому, в данном случае, пришлось отказаться от <code>VideoSourcePlayer</code>, он ведь может работать только с одним файлом за раз. </p>

<p>У меня получилась такая программулина</p>

<p><a href="https://i.stack.imgur.com/l0jUn.gif" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/l0jUn.gif" alt="Пример работы программы"></a></p>

<p>Вот такой класс для работы с этой библиотекой пришлось написать</p>

<pre><code>public class AFService
{
    private readonly IVideoSource _fileVideoSource;
    private readonly string _savingDirectory;
    private readonly string _fileName;

    private int _skipFrames;
    private int _numberPassedFrames;
    private int _numberSavedFrames;

    //ctor
    public AFService(string pathToFile) : this(pathToFile, Path.GetDirectoryName(pathToFile))
    {}
    public AFService(string pathToFile, string dirToSave)
    {
        if (String.IsNullOrEmpty(pathToFile)) throw new ArgumentException(nameof(pathToFile));
        if (String.IsNullOrEmpty(dirToSave)) throw new ArgumentException(nameof(dirToSave));
        if (!File.Exists(pathToFile)) throw new FileNotFoundException(pathToFile);

        _savingDirectory = dirToSave;
        _fileName = Path.GetFileNameWithoutExtension(pathToFile);

        string extension = Path.GetExtension(pathToFile);
        if (extension.Contains("avi"))
        {
            _fileVideoSource = new AVIFileVideoSource(pathToFile);
        }
        else
        {
            _fileVideoSource = new FileVideoSource(pathToFile);
        }
    }

    /// &lt;summary&gt;
    /// Кадр захвачен и сохранен
    /// &lt;/summary&gt;
    public event EventHandler&lt;AFServiceEventArgs&gt; FrameCaptured;

    /// &lt;summary&gt;
    /// Захват кадров закончен
    /// &lt;/summary&gt;
    public event EventHandler&lt;AFServiceEventArgs&gt; CaptureFinished;

    /// &lt;summary&gt;
    /// Захват кадров видео файла в jpg файлы
    /// &lt;/summary&gt;
    /// &lt;param name="cancellationToken"&gt;токен отмены&lt;/param&gt;
    /// &lt;param name="skipFrames"&gt;шаг пропуска кадров, по-умолчанию равно 30&lt;/param&gt;
    /// &lt;returns&gt;количество сохраненных кадров&lt;/returns&gt;
    public async Task&lt;int&gt; CaptureFramesAsync(CancellationToken cancellationToken, int skipFrames = 30)
    {
        //запоминаем шаг пропуска
        _skipFrames = skipFrames;

        //готовимся
        AsyncVideoSource source = new AsyncVideoSource(_fileVideoSource, true);
        source.PlayingFinished += Source_PlayingFinished;
        source.NewFrame += Source_NewFrame;
        source.VideoSourceError += Source_VideoSourceError;

        //начинаем процесс
        await Task.Run(() =&gt;
        {
            source.Start();
            //ждем окончания прохода по всему видеофайлу
            while (source.IsRunning)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    source.Stop();
                    //выброс исключения в случае отмены задачи
                    cancellationToken.ThrowIfCancellationRequested();
                    break;
                }

                //Debug.WriteLine($"FramesReceived-{source.FramesReceived}");
                //Debug.WriteLine($"FramesProcessed-{source.FramesProcessed}");
                //Debug.WriteLine($"BytesReceived-{source.BytesReceived}");
            }
        });

        //отдаем результат
        return _numberSavedFrames;
    }

    private void Source_NewFrame(object sender, NewFrameEventArgs eventArgs)
    {
        AsyncVideoSource source = sender as AsyncVideoSource;
        _numberPassedFrames += source.FramesProcessed;
        Debug.WriteLine($"Поступил кадр: {_numberPassedFrames}");

        //пропускаем ненужные кадры
        if (_numberPassedFrames % _skipFrames != 0) return;

        Debug.WriteLine($"!&lt;-- Взят в обработку: {_numberPassedFrames}");

        //увеличиваем счетчик запоминаемых кадров
        _numberSavedFrames++;
        //формируем имя файла
        var file = Path.Combine(_savingDirectory, $"{_fileName}-{_numberSavedFrames}.jpg");

        //сохраняем кадр в файл
        Image img = eventArgs.Frame;
        img.Save(file, ImageFormat.Jpeg);
        Debug.WriteLine($"!&lt;-- cохраненен под именем: {file}");

        //вызываем событие сохранения кадра
        var evArg = new AFServiceEventArgs(String.Empty, file, _numberSavedFrames, _numberPassedFrames);
        FrameCaptured?.Invoke(this, evArg);
    }

    private void Source_PlayingFinished(object sender, ReasonToFinishPlaying reason)
    {
        Debug.WriteLine($"Захват отработал у файла: {_fileName}");

        //вызываем событие окончания работы над файлом
        var evArg = new AFServiceEventArgs(reason.ToString(), String.Empty, _numberSavedFrames, _numberPassedFrames);
        CaptureFinished?.Invoke(this, evArg);
    }

    private void Source_VideoSourceError(object sender, VideoSourceErrorEventArgs eventArgs)
    {
        //вызываем событие окончания работы над файлом
        var evArg = new AFServiceEventArgs(eventArgs.Description, String.Empty, 0, 0);
        CaptureFinished?.Invoke(this, evArg);
    }
}
</code></pre>

<p>Работа протестирована на файлах <code>wmv</code>, на <code>avi</code> почему-то вылезает ошибка, но я надеюсь, что вы далее сами поработайте и все наладите. Весь проект целиком можно скачать <a href="https://yadi.sk/d/M_T-37ZJ3QwVmA" rel="nofollow noreferrer">здесь</a>.</p>
