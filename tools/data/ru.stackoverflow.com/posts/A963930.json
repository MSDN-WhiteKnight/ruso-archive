{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":3,"last_activity_date":1554090169,"creation_date":1554090169,"answer_id":963930,"question_id":963904,"body":"<p>Во первых, неправильно реализована проверка результата GetAsyncKeyState. Правильно должно быть как-то так:</p>\n\n<pre><code>if ((GetAsyncKeyState(i) &amp; 0x8000) != 0){\n    //...\n}\n</code></pre>\n\n<p>Во вторых, вызывать в цикле GetAsyncKeyState только для отлова нажатия клавиш - так себе идея, вместо этого нужно использовать специальное средство, клавиатурный хук. То же самое можно сказать про гигантский switch с проверкой все возможных кодов спецсимволов, для этого есть специальные функции, MapVirtualKey и ToUnicodeEx. Все это уже <a href=\"https://ru.stackoverflow.com/questions/926187/%D0%92%D1%8B%D1%81%D0%BE%D0%BA%D0%B0%D1%8F-%D0%BD%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0-%D0%BD%D0%B0-%D0%A6%D0%9F-%D0%BF%D1%80%D0%B8-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B8-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B\">многократно</a> <a href=\"https://ru.stackoverflow.com/questions/767999/getkeyboardstate-%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F-%D0%BA%D0%BB%D0%B0%D0%B2%D0%B8%D1%88%D0%B8?noredirect=1&amp;lq=1\">обсуждалось</a>. </p>\n\n<p>Пример:</p>\n\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;Windows.h&gt;\n\nwchar_t VKCodeToUnicode(UINT vkCode)\n{\n    BYTE keyboardState[255]=\"\";\n    wchar_t buf[5] = L\"\";\n\n    short x;\n    byte y;\n\n    for (int i = 0; i &lt; 255; i++)\n    {\n        if (i == VK_CAPITAL)\n        {\n            x = GetKeyState(i);\n        }\n        else\n        {\n            x = GetAsyncKeyState(i);\n        }\n        y = 0;\n        if ((x &amp; 0x8000) != 0) y = (BYTE)(y | 0x80);\n        if ((x &amp; 0x0001) != 0) y = (BYTE)(y | 0x01);\n        keyboardState[i] = y;\n    }\n\n    ToUnicodeEx(vkCode, MapVirtualKey(vkCode, 0), keyboardState, buf, 5, 0,\n        GetKeyboardLayout(GetWindowThreadProcessId(GetForegroundWindow(), nullptr)));\n    return buf[0];\n}\n\nLRESULT CALLBACK LowLevelKeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)\n{\n\n    if (nCode == HC_ACTION)\n    {\n        switch (wParam)\n        {\n        case WM_KEYDOWN:\n            PKBDLLHOOKSTRUCT p = (PKBDLLHOOKSTRUCT)lParam;\n            wchar_t c = VKCodeToUnicode(p-&gt;vkCode);\n            wprintf(L\"%lc\\n\",c);\n            break;\n        }\n    }\n    return CallNextHookEx(NULL, nCode, wParam, lParam);\n}\n\nint main(int argc, char* argv[])\n{\n\n    HHOOK hook = SetWindowsHookEx(WH_KEYBOARD_LL, LowLevelKeyboardProc, 0, 0);\n    if (hook == NULL) {\n        printf(\"Failed to install keyboard hook!\\n\");\n        getchar();\n        return 1;\n    }   \n\n    MSG msg;\n    while (!GetMessage(&amp;msg, NULL, NULL, NULL)) {\n        TranslateMessage(&amp;msg);\n        DispatchMessage(&amp;msg);\n    }\n\n    return 0;\n} \n</code></pre>\n"}