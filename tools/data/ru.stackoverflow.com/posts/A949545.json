{"owner":{"reputation":16137,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":1,"last_activity_date":1551171878,"creation_date":1551171878,"answer_id":949545,"question_id":948354,"body":"<p>Метод Read может считывать данные как из промежуточного буфера в памяти, так и напрямую из файла. Конкретные детали определяются используемой СУБД. Так как OLE DB чаще всего используют для работы с MS Access, имеет смысл рассмотреть именно его.</p>\n\n<p>Для отслеживания обращений к файлу можно использовать механизм Event Tracing for Windows: Kernel tracing provider предоставляет событие <a href=\"https://docs.microsoft.com/en-us/windows/desktop/etw/fileio-readwrite\" rel=\"nofollow noreferrer\">FileIo_ReadWrite</a>. Для использования ETW в C# подключим библиотеку <a href=\"https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent/\" rel=\"nofollow noreferrer\">Microsoft.Diagnostics.Tracing.TraceEvent</a>. Напишем такой код для считывания 10 строк из БД и логирования событий чтения из файла (так как ETW выдает события с задержкой около секунды, между отдельными этапами работы с БД добавлены паузы, чтобы можно было отличить, какие события к чему относятся):</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Diagnostics;\nusing System.Threading;\nusing Microsoft.Diagnostics.Tracing.Parsers;\nusing Microsoft.Diagnostics.Tracing.Session;\nusing System.Data.OleDb;\n\nnamespace ConsoleApp1\n{    \n    class Program\n    {\n        struct Timestamp : IComparable\n        {\n            public Timestamp(long t, string s)\n            {\n                tvalue = t;\n                descr = s;\n            }\n\n            public long tvalue { get; set; }\n            public string descr { get; set; }\n\n            public int CompareTo(object obj)\n            {\n                return (int)(this.tvalue - ((Timestamp)obj).tvalue );\n            }\n\n            public override string ToString()\n            {\n                return tvalue.ToString()+\": \"+descr;\n            }\n        }    \n\n        static string filename = \"C:\\\\Test\\\\Database1.mdb\";        \n        static TraceEventSession m_EtwSession;\n\n        static Stopwatch sw;\n        static List&lt;Timestamp&gt; timestamps = new List&lt;Timestamp&gt;(100000);\n        static object sync = new object();\n        static ManualResetEvent mre = new ManualResetEvent(false);\n\n        static void AddTimestamp(long t, string s)\n        {\n            lock (sync)\n            {\n                timestamps.Add(new Timestamp( t,s) );\n            }\n        }\n\n        static void AddTimestamp( string s)\n        {\n            lock (sync)\n            {\n                timestamps.Add(new Timestamp(sw.ElapsedMilliseconds, s));\n            }\n        }\n\n        static void ThreadProc()\n        {\n            int pid = Process.GetCurrentProcess().Id;\n\n            //Создаем сессию ETW и подписываемся на события чтения файлов\n\n            using (m_EtwSession = new TraceEventSession(KernelTraceEventParser.KernelSessionName))\n            {\n                m_EtwSession.StopOnDispose = true;\n                m_EtwSession.EnableKernelProvider(KernelTraceEventParser.Keywords.FileIOInit |\n                    KernelTraceEventParser.Keywords.DiskFileIO);\n\n                m_EtwSession.Source.Kernel.FileIORead += data =&gt;\n                {\n                    //сохраняем все события чтения файла БД текущим процессом\n\n                    if (data.ProcessID == pid &amp;&amp; data.FileName.ToLower().Trim() == filename.ToLower())  \n                    {\n                        AddTimestamp((long)data.TimeStampRelativeMSec,\n                            \"Bytes read: \" + data.IoSize.ToString());                        \n                    }  \n                };\n\n                lock (sync)\n                {\n                    sw = new Stopwatch();\n                    sw.Start();\n                }\n\n                //сигнализируем основному потоку о готовности\n                mre.Set();\n\n                //запускаем Event Tracing\n                m_EtwSession.Source.Process();\n            }\n\n        }\n\n        public static void Main(string[] argv)\n        {\n            //создаем поток для Event Tracing\n            Thread th = new Thread(ThreadProc);\n            th.IsBackground = true;\n            th.Start();\n\n            //ждем готовности второго потока\n            mre.WaitOne();\n\n            string constr = \"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=\"+ filename+\"; \";   \n            string sql = \"SELECT * FROM Table1\";\n\n            //подключаемся к БД\n            OleDbConnection conn = new OleDbConnection(constr);\n\n            AddTimestamp( \"Start\");\n            Console.Write(\"Connecting...\\r\");\n            conn.Open();\n            AddTimestamp( \"Connection.Open\");\n            Thread.Sleep(1000);\n\n            //выполняем запрос и читаем первые 10 строк\n            using (conn)\n            {\n                OleDbCommand cmd = new OleDbCommand(sql, conn);\n\n                Console.Write(\"Executing SQL...\\r\");\n                OleDbDataReader reader = cmd.ExecuteReader();\n                AddTimestamp( \"OleDbCommand.ExecuteReader\");\n                Thread.Sleep(1000);\n\n                int i = 0;\n                int n = 10;\n                using (reader)\n                    while (reader.Read())\n                    {\n                        AddTimestamp( \"OleDbDataReader.Read \");\n                        string s = reader[0].ToString();\n\n                        Console.Write(\"Reading data... \"+\n                            s.PadLeft(5)+\" (\"+\n                            i.ToString().PadLeft(4)+\"/\"+n.ToString()+\") rows\\r\");\n\n                        i++;\n                        if (i &gt; n) break;\n                        Thread.Sleep(1000);\n                    }                \n            }\n\n            AddTimestamp( \"End\");                       \n\n            //завершаем сессию ETW\n            m_EtwSession.Dispose();\n\n            //выводим результаты\n            Console.Clear();\n\n            lock (sync)\n            {\n                timestamps.Sort();\n\n                foreach (var ts in timestamps)\n                {\n                    Console.WriteLine(ts.ToString());\n                }\n            }\n\n            Console.WriteLine(\"Press any key to exit ...\");\n            Console.ReadKey();            \n        }    \n    }    \n}\n</code></pre>\n\n<p>Результат выглядит так:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>7: Start\n34: Connection.Open\n154: Bytes read: 65536\n154: Bytes read: 4096\n154: Bytes read: 4096\n154: Bytes read: 4096\n1037: OleDbCommand.ExecuteReader\n1170: Bytes read: 4096\n1170: Bytes read: 4096\n1170: Bytes read: 4096\n1170: Bytes read: 4096\n2038: OleDbDataReader.Read\n2172: Bytes read: 4096\n3040: OleDbDataReader.Read\n4041: OleDbDataReader.Read\n5042: OleDbDataReader.Read\n5153: Bytes read: 512\n5175: Bytes read: 4096\n5175: Bytes read: 4096\n6042: OleDbDataReader.Read\n7043: OleDbDataReader.Read\n8044: OleDbDataReader.Read\n9044: OleDbDataReader.Read\n10045: OleDbDataReader.Read\n10153: Bytes read: 512\n11045: OleDbDataReader.Read\n12081: End\n</code></pre>\n\n<p>По результатам видно, что Jet считывает данные блоками по 4096 байт (размер страницы в Access) и помещает в промежуточный буфер в памяти. Если требуемая строка находится в буфере, она берется из него, в противном случае осуществляется чтение следующего блока. События считывания по 512 байт являются, по видимому, периодическим опросом какой-то служебной информации (возможно, состояния блокировки записей), так как они наблюдаются постоянно, пока открыто соединение с БД (даже если ничего не считывать).</p>\n"}