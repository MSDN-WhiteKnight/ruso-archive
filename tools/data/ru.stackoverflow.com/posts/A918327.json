{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":3,"last_activity_date":1554111910,"last_edit_date":1554111910,"creation_date":1544502635,"answer_id":918327,"question_id":918122,"body":"<p>Assembly.Load, тем более из массива байт - очень плохая идея, ведь она не дает возможности впоследствии выгрузить сборку из памяти, т.е. при работе в серверном приложении память рано или поздно исчерпается и сервер придется перезапускать. Кроме того, как ограничить права для запускаемого кода, чтобы он не разрушил вам систему? Если вы ориентируетесь под .NET Core, то домены приложений недоступны. Правильнее скомпилировать код в файл и запускать его в новом процессе под пользователем с ограниченными правами и перехватывать его вывод:</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Diagnostics;\nusing System.Reflection;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CSharp;\n\nnamespace RoslynTest\n{\n    class Program\n    {\n        static void RunScript()\n        {\n            var script = @\"using System;\n                public static class Program\n                {\n                    public static int Main(string[] args)\n                    {\n                        var x = 7 * 8;\n                        Console.WriteLine(x.ToString());\n                        return x;\n                    }\n                }\";\n\n            var assemblyPath = Path.GetDirectoryName(typeof(object).Assembly.Location);\n            var refs = new List&lt;PortableExecutableReference&gt;\n            {\n                 MetadataReference.CreateFromFile(typeof(object).Assembly.Location),\n                 MetadataReference.CreateFromFile(Path.Combine(assemblyPath, \"mscorlib.dll\")),\n                 MetadataReference.CreateFromFile(Path.Combine(assemblyPath, \"System.dll\")),\n                MetadataReference.CreateFromFile(Path.Combine(assemblyPath, \"System.Core.dll\")),\n                MetadataReference.CreateFromFile(Path.Combine(assemblyPath, \"System.Runtime.dll\")),\n                MetadataReference.CreateFromFile(Assembly.GetEntryAssembly().Location)\n            };\n\n\n            // Parse the script to a SyntaxTree\n            var syntaxTree = CSharpSyntaxTree.ParseText(script);\n            var options = new CSharpCompilationOptions(OutputKind.ConsoleApplication);\n            // Compile the SyntaxTree to a CSharpCompilation\n            var compilation = CSharpCompilation.Create(\"Script\",\n                new[] { syntaxTree },\n                refs,\n                new CSharpCompilationOptions(\n                    OutputKind.ConsoleApplication,\n                    optimizationLevel: OptimizationLevel.Release,                    \n                    assemblyIdentityComparer: DesktopAssemblyIdentityComparer.Default)\n                    );\n\n            var result = compilation.Emit(\"script.exe\");\n            if (!result.Success)\n            {\n                throw new ApplicationException(\"Cannot compile script\");\n            }            \n\n            ProcessStartInfo psi = new ProcessStartInfo();\n            psi.FileName = \"script.exe\";\n            psi.UseShellExecute = false;\n            psi.RedirectStandardOutput = true;\n            psi.RedirectStandardInput = true; \n            psi.UserName = \"Vasya\";\n            psi.Password = \"123\";\n\n            var process = new Process();\n            using (process)\n            {\n                process.StartInfo = psi;                \n                process.Start();\n\n                while (!process.StandardOutput.EndOfStream)\n                {\n                    string res = process.StandardOutput.ReadLine();                    \n                    Console.WriteLine(res);\n                }\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>Код заточен под .NET Framework / Windows, но думаю, не составит труда переделать под .NET Core, так как все используемые библиотеки есть в .NET Standard. Запуск процессов от имени другого пользователя должен работать в .NET Core на всех ОС, начиная с .NET Core 2.1.</p>\n\n<hr>\n\n<p><strong>Примечание.</strong> В .NET Core 3.0 появилась <a href=\"https://docs.microsoft.com/en-us/dotnet/core/whats-new/dotnet-core-3-0#assembly-unloadability\" rel=\"nofollow noreferrer\">возможность выгрузки сборок из памяти</a>, но это все еще не решает проблему обеспечения безопасности.</p>\n"}