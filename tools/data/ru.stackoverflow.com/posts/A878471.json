{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":3,"last_activity_date":1536302504,"creation_date":1536302504,"answer_id":878471,"question_id":877005,"body":"<p>Образ ISO - это простая посекторная копия диска (точнее, раздела, или \"дорожки\", применительно к CD), без сжатия и каких-либо служебных заголовков. Название произошло от файловой системы <a href=\"https://ru.wikipedia.org/wiki/ISO_9660\" rel=\"nofollow noreferrer\">ISO-9660</a>, которая была одной из первых файловых систем для CD, но фактически образ ISO может содержать любую файловую систему в зависимости от типа носителя: UDF для DVD, FAT для дискет, FAT32/NTFS для флешек и т.п. Чтобы создать такой образ, достаточно открыть диск на чтение и переписать все содержимое в файл, поэтому потребуется лишь несколько функций для работы с файлами из WinAPI. Да, конечно, это можно сделать в .NET.</p>\n\n<p>Создать образ CD-ROM или другого подобного незаписываемого носителя довольно просто:</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Runtime.InteropServices;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        static extern bool GetDiskFreeSpace(string lpRootPathName,\n            out uint lpSectorsPerCluster,\n            out uint lpBytesPerSector,\n            out uint lpNumberOfFreeClusters,\n            out uint lpTotalNumberOfClusters);\n\n        const uint GENERIC_READ = 0x80000000;\n        const uint FILE_SHARE_READ = 0x00000001;\n        const uint FILE_SHARE_WRITE = 0x00000002;\n        const uint OPEN_EXISTING = 3;\n        const uint FILE_ATTRIBUTE_NORMAL = 0x00000080;\n\n        [DllImport(\"kernel32.dll\", SetLastError = true, CharSet = CharSet.Auto)]\n        public static extern IntPtr CreateFile(\n             [MarshalAs(UnmanagedType.LPTStr)] string filename,\n             [MarshalAs(UnmanagedType.U4)] uint access,\n             [MarshalAs(UnmanagedType.U4)] uint share,\n             IntPtr securityAttributes,\n             [MarshalAs(UnmanagedType.U4)] uint creationDisposition,\n             [MarshalAs(UnmanagedType.U4)] uint flagsAndAttributes,\n             IntPtr templateFile);\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        static extern bool ReadFile(IntPtr hFile, [Out] byte[] lpBuffer,\n           uint nNumberOfBytesToRead, out uint lpNumberOfBytesRead, IntPtr lpOverlapped);\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        static extern bool CloseHandle(IntPtr hObject);\n\n        static void CreateISO(string letter, string outfile)\n        {            \n            byte[] buf;\n            uint dwRead = 0;\n            ulong count = 0;            \n            uint dwSectorsPerCluster, dwBytesPerSector, dwNumberOfFreeClusters, dwTotalNumberOfClusters;\n            uint blocksize;\n            ulong totalsize;\n\n            const uint SECTOR_SIZE = 2048; //размер сектора для CD\n            string fmt = \"\\\\\\\\.\\\\{0}:\"; //формат имени файла для открытия тома\n\n            //найдем размер сектора и объем данных на диске\n            bool res = GetDiskFreeSpace(letter + \":\\\\\", out dwSectorsPerCluster, out dwBytesPerSector,\n                out dwNumberOfFreeClusters, out dwTotalNumberOfClusters);\n\n            //вычислим размер блока, кратный размеру сектора, и общий объем данных в байтах\n            if (res)\n            {\n                blocksize = dwBytesPerSector * 20;\n                totalsize = dwSectorsPerCluster * dwBytesPerSector * (ulong)dwTotalNumberOfClusters;\n            }\n            else\n            {\n                Console.WriteLine(\"GetDiskFreeSpace error {0}\", Marshal.GetLastWin32Error());\n                blocksize = SECTOR_SIZE * 20;\n                totalsize = 4700307456; //DVD\n            }\n            buf = new byte[blocksize];\n\n            string volume = String.Format(fmt, letter);\n\n            //открываем том для прямого доступа на чтение\n            var handle = CreateFile(volume, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,\n            IntPtr.Zero, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, IntPtr.Zero);\n\n            if (handle.ToInt64() == -1) throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());\n\n            //открываем файл для записи\n            var target = new System.IO.FileStream(outfile, System.IO.FileMode.Create);\n\n            try\n            {\n                while (true)\n                {\n                    dwRead = 0;\n                    Array.Clear(buf, 0, buf.Length);\n\n                    //считаем блок данных\n                    res = ReadFile(handle, buf, blocksize, out dwRead, IntPtr.Zero);\n                    if (res == false)\n                    {\n                        Console.WriteLine();\n                        Console.WriteLine(\"ReadFile error {0}\", Marshal.GetLastWin32Error());\n                        break;\n                    }\n\n                    if (dwRead == 0) break; //конец считывания\n\n                    count += dwRead;\n\n                    Console.Write(\" Creating image: {0}% [{1} KB / {2} KB]\\r\",\n                        (count * 100.0f / totalsize).ToString(\"F1\").PadLeft(5),\n                        (count / 1024.0f).ToString(\"F2\").PadLeft(10),\n                        (totalsize / 1024.0f).ToString(\"F2\").PadLeft(10));\n\n                    //запишем блок в файл\n                    target.Write(buf, 0, (int)dwRead);\n                }\n\n            }\n            finally\n            {\n                CloseHandle(handle);\n                target.Close();\n            }\n\n            Console.WriteLine();\n        }\n\n        static void Main(string[] args)\n        {\n            CreateISO(\"E\", \"c:\\\\distr\\\\image.iso\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre>\n\n<p>Для создания образа записываемого носителя (флешки и т.п.), необходимо сначала попросить пользователя закрыть все программы, которые его используют, и открывать диск монопольно (0 вместо <code>FILE_SHARE_READ | FILE_SHARE_WRITE</code>). Если этого не сделать, во время создания образа часть информации на диске может быть параллельно изменена другой программой, и образ получится в итоге в некорректном состоянии. Альтернативное решение этой проблемы - использование Volume Shadow-Copy Services (VSS).</p>\n\n<p>Что касается жестких дисков, то создавать ISO-образ таким методом для них не выглядит хорошей идеей. Во-первых, открыть жесткий диск эксклюзивно не всегда получится (а системный и вовсе никогда). Во-вторых, формат ISO для них просто не предназначен, и многие утилиты вообще не смогут обработать ISO-образ для жесткого диска. Вместо этого лучше использовать специальный формат для образов жестких дисков, например <a href=\"https://msdn.microsoft.com/ru-ru/library/windows/desktop/dd323654%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396\" rel=\"nofollow noreferrer\">VHD</a>. Он поддерживается как средствами Windows, так и сторонними продуктами типа Акрониса. Опять же, для программного создания таких образов можно не изобретать что-то свое, а воспользоваться стандартной утилитой командной строки <a href=\"https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/wbadmin\" rel=\"nofollow noreferrer\">wbadmin</a>, которая автоматически умеет использовать VSS и создавать образ в том числе системного диска. </p>\n"}