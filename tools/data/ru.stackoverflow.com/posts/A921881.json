{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1559457011,"last_edit_date":1559457011,"creation_date":1545022702,"answer_id":921881,"question_id":921312,"body":"<p>Программа некорректна как минимум в двух аспектах.</p>\n\n<ol>\n<li><p>Программа пытается динамически создать в памяти кусок кода, но при этом не вызывает функцию <a href=\"https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-flushinstructioncache\" rel=\"nofollow noreferrer\">FlushInstructionCache</a>. </p></li>\n<li><p>Нет гарантий, что в адресном пространстве любого процесса по заданному адресу <code>NtHeader-&gt;OptionalHeader.ImageBase</code> ОС сможет выделить непрерывный блок памяти нужного размера (вы даже не проверяете результат возврата VirtualAllocEx, чтобы узнать это). В современных версиях Windows действует Address space layout randomization, и предугадать, по какому адресу что будет загружено, невозможно. </p></li>\n</ol>\n\n<p>Я бы сказал, то, что вы пытаетесь сделать, не будет работать. Выгрузите бинарник во временный файл и создайте процесс с него, это единственная рабочая схема.</p>\n\n<p>Если вас интересует, как избавиться от Access Violation и вместо этого корректно вернуть ошибку, посмотрите улучшенный вариант этого кода: <a href=\"https://github.com/Anon-65535/RunPE-Fixed-/blob/master/RunPE32_From_Memory.cpp\" rel=\"nofollow noreferrer\">https://github.com/Anon-65535/RunPE-Fixed-/blob/master/RunPE32_From_Memory.cpp</a></p>\n"}