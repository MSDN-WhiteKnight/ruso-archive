---
title: "Answer 930705"
se.owner.user_id: 32793
se.owner.display_name: "iluxa1810"
se.owner.link: "https://ru.stackoverflow.com/users/32793/iluxa1810"
se.answer_id: 930705
se.question_id: 930603
se.post_type: answer
se.score: 3
se.is_accepted: False
---
<p>Дополню вопрос касательно нативных DLL на основании этого <a href="https://stackoverflow.com/questions/6452951/how-to-dynamically-load-and-unload-a-native-dll-file">ответа</a>:</p>

<p>Нужно через P/Invoke описать 2 функции:</p>

<pre><code>[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
private static extern IntPtr LoadLibrary(string libname);

[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
private static extern bool FreeLibrary(IntPtr hModule);

//Load
IntPtr Handle = LoadLibrary(fileName);
if (Handle == IntPtr.Zero)
{
     int errorCode = Marshal.GetLastWin32Error();
     throw new Exception(string.Format("Failed to load library (ErrorCode: {0})",errorCode));
}

//Free
if(Handle != IntPtr.Zero)
        FreeLibrary(Handle);
</code></pre>

<p>Если мы хотим работать с функцией из загруженной либы(а мы это хотим, иначе не грузили бы), то нужно еще определить <code>GetProcAddress</code></p>

<pre><code>[DllImport("kernel32.dll", CharSet = CharSet.Ansi)]
private static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName); 


    IntPtr funcaddr = GetProcAddress(Handle,functionName);
</code></pre>

<p>И потом создать делегат</p>

<pre><code>YourFunctionDelegate function = Marshal.GetDelegateForFunctionPointer(funcaddr,typeof(YourFunctionDelegate )) as YourFunctionDelegate ;
function.Invoke(pass here your parameters);
</code></pre>

<p>Помните, что C# не поддерживает работу с неуправляемыми объектами=> возможны только API вызовы. Если нужно создавать неуправляемые объекты, то нужно делать прослойку на <code>C++/CLI</code></p>
