{"owner":{"reputation":16117,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":7,"last_activity_date":1535947309,"last_edit_date":1535947309,"creation_date":1535736189,"answer_id":875964,"question_id":875165,"body":"<p>Можно написать свою программу для этих целей, воспользовавшись <a href=\"https://ru.stackoverflow.com/questions/866161/%D0%9D%D0%B0%D0%B9%D1%82%D0%B8-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0-%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B8-%D0%B4%D1%80%D1%83%D0%B3%D0%BE%D0%B3%D0%BE-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0\">существующими наработками по парсингу MSIL-кода</a>. Напишем вот такую программу, принимающую на вход путь к сборке, и возвращающую код 0, если она не содержит вызовов запрещенных методов, или код 1 при их наличии (код неэффективный по производительности, воспринимайте только как пример):</p>\n\n<pre><code>//Утилита для проверки сборки на наличие вызовов запрещенных методов\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nnamespace AssValidator\n{\n    class Program\n    {\n\n        public static OpCode FindOpCode(short val)\n        {\n            OpCode ret = OpCodes.Nop;\n            FieldInfo[] mas = typeof(OpCodes).GetFields();\n            for (int i = 0; i &lt; mas.Length; i++)\n            {\n                if (mas[i].FieldType == typeof(OpCode))\n                {\n                    OpCode opcode = (OpCode)mas[i].GetValue(null);\n                    if (opcode.Value == val)\n                    {\n                        ret = opcode;\n                        break;\n                    }\n                }\n            }\n            return ret;\n        }\n\n        //получает список методов, вызываемых указанным методом\n        public static List&lt;MethodBase&gt; GetCalledMethods(MethodBase mi)\n        {\n            MethodBody mb = null;\n\n            //получаем тело метода\n            try\n            {\n                mb = mi.GetMethodBody();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.GetType().ToString() + \" \" + ex.Message);                \n            }\n            if (mb == null) return new List&lt;MethodBase&gt;();\n\n            //получаем IL-код\n            var msil = mb.GetILAsByteArray();\n\n            //получаем модуль, в котором расположен метод\n            var module = mi.Module;\n\n            List&lt;MethodBase&gt; methods = new List&lt;MethodBase&gt;();\n\n            short op;\n            int n = 0;\n\n            //парсим IL-код...\n            while (true)\n            {\n                if (n &gt;= msil.Length) break;\n\n                //получаем код операции\n                if (msil[n] == 0xfe)\n                    op = (short)(msil[n + 1] | 0xfe00);\n                else\n                    op = (short)(msil[n]);\n\n                //найдем имя операции\n                OpCode opcode = FindOpCode(op);\n                string str = opcode.Name;\n                int size = 0;\n\n                //найдем размер операции\n                switch (opcode.OperandType)\n                {\n                    case OperandType.InlineBrTarget: size = 4; break;\n                    case OperandType.InlineField: size = 4; break;\n                    case OperandType.InlineMethod: size = 4; break;\n                    case OperandType.InlineSig: size = 4; break;\n                    case OperandType.InlineTok: size = 4; break;\n                    case OperandType.InlineType: size = 4; break;\n                    case OperandType.InlineI: size = 4; break;\n                    case OperandType.InlineI8: size = 8; break;\n                    case OperandType.InlineNone: size = 0; break;\n                    case OperandType.InlineR: size = 8; break;\n                    case OperandType.InlineString: size = 4; break;\n                    case OperandType.InlineSwitch: size = 4; break;\n                    case OperandType.InlineVar: size = 2; break;\n                    case OperandType.ShortInlineBrTarget: size = 1; break;\n                    case OperandType.ShortInlineI: size = 1; break;\n                    case OperandType.ShortInlineR: size = 4; break;\n                    case OperandType.ShortInlineVar: size = 1; break;\n                    default:\n                        throw new Exception(\"Unknown operand type.\");\n                }\n                size += opcode.Size;\n\n                int token = 0;\n                if (str == \"call\" || str == \"callvirt\")\n                {\n                    //если это вызов метода, найдем токен\n                    token = (((msil[n + 1] | (msil[n + 2] &lt;&lt; 8)) |\n                        (msil[n + 3] &lt;&lt; 0x10)) | (msil[n + 4] &lt;&lt; 0x18));\n\n                    //найдем метод в модуле по токену\n                    try\n                    {\n                        var method = module.ResolveMethod(token);\n                        if (!methods.Contains(method)) methods.Add(method);\n                    }\n                    catch (Exception ex)\n                    {\n                        //MessageBox.Show(ex.ToString());\n                        Console.WriteLine(ex.GetType().ToString() + \" \" + ex.Message);\n                    }\n                }\n\n                n += size; //пропускаем нужное число байтов\n            }\n\n            return methods;\n        }\n\n        //получает список методов, вызываемых всеми классами в указанной сборке\n        public static List&lt;MethodBase&gt; GetCalledMethods(Assembly ass)\n        {\n            List&lt;MethodBase&gt; methods = new List&lt;MethodBase&gt;();\n            var types = ass.GetTypes();\n\n            StringBuilder sb = new StringBuilder();\n            foreach (var t in types)\n            {                \n                //поиск по методам...\n                var mlist = t.GetMethods(BindingFlags.Public | BindingFlags.NonPublic |\n                    BindingFlags.Instance | BindingFlags.Static);\n                foreach (var m in mlist)\n                {\n                    var arr = GetCalledMethods(m);\n                    foreach (var x in arr)\n                    {\n                        if (!methods.Contains(x)) methods.Add(x);\n                    }\n                }\n\n                //поиск по конструкторам...\n                var clist = t.GetConstructors(BindingFlags.Public | BindingFlags.NonPublic |\n                    BindingFlags.Instance | BindingFlags.Static);\n                foreach (var m in clist)\n                {\n                    var arr = GetCalledMethods(m);\n                    foreach (var x in arr)\n                    {\n                        if (!methods.Contains(x)) methods.Add(x);\n                    }\n                }\n\n\n            }\n            return methods;\n        }\n\n        //проверяет указанную сборку на наличие вызовов запрещенных методов\n        static bool ValidateAssembly(string path)\n        {            \n\n            Assembly ass = Assembly.LoadFrom(path); //загружаем сборку\n\n            var methods = GetCalledMethods(ass); //получаем все вызываемые методы\n\n            foreach (var x in methods)\n            {\n                var pars = x.GetParameters();\n\n                //вызов метода System.Windows.Forms.MessageBox.Show(string) запрещен\n                if (x.DeclaringType.ToString() == \"System.Windows.Forms.MessageBox\"\n                    &amp;&amp; x.Name == \"Show\"\n                    &amp;&amp; pars.Length == 1\n                    &amp;&amp; pars[0].ParameterType.Name == \"String\"\n                    )\n                {\n                    Console.WriteLine(\"Method call not allowed: MessageBox.Show(String)\");\n                    return false;\n                }\n            }\n\n            return true; //не найдено запрещенных методов\n        }\n\n        //AssValidator - точка входа\n        static void Main(string[] args)\n        {\n\n            if (args.Length == 0)\n            {\n                Console.WriteLine(\"Error: too few arguments!\");                \n                Environment.Exit(0xff);\n            }\n\n            Console.WriteLine(\"Validating \"+args[0]+\" ...\");\n\n            try\n            {\n                bool res = ValidateAssembly(args[0]);\n                if (!res) { Console.WriteLine(\"Assembly is invalid\"); Environment.Exit(1); }\n                else { Console.WriteLine(\"Assembly is valid\"); Environment.Exit(0); }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"Validation error!\");\n                Console.WriteLine(ex.ToString());\n                Environment.Exit(0xff);\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>Соберем ее (желательно в режиме Release, так как процесс довольно тяжелый), и разместим полученный файл так, что путь к нему будет, допустим, <code>D:\\Distr\\AssValidator\\AssValidator.exe</code>. </p>\n\n<p>В свойствах проекта, на вкладке \"События построения\", зададим событие после построения: </p>\n\n<pre><code>\"D:\\Distr\\AssValidator\\AssValidator.exe\" $(TargetPath)\n</code></pre>\n\n<p>Теперь, при попытке собрать проект с запрещенным методом получим ошибку построения </p>\n\n<pre><code>error MSB3073: выход из команды \"\"D:\\Distr\\AssValidator\\AssValidator.exe\" d:\\...\\WindowsFormsApplication1.exe\" с кодом 1.\n</code></pre>\n\n<p>Выглядит это как-то так:</p>\n\n<p><a href=\"https://i.stack.imgur.com/a0lQ3.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/a0lQ3.png\" alt=\"VS screeshots\"></a></p>\n\n<p>Протестировано для .NET 4.5 / VS 2012.</p>\n\n<p>Недостатки способа:</p>\n\n<ul>\n<li><p>В ходе проверки сборки может быть выполнен код из нее (например, статические конструкторы). В том числе, этот код может упасть с исключением и нарушить все.</p></li>\n<li><p>Чтобы работало для не-<em>AnyCPU</em> проектов, понадобится две версии проверяющей программы (32-битная и 64-битная)</p></li>\n<li><p>Хотя при непрохождении проверки построение завершается с ошибкой, сам скомпилированный файл сборки остается. Опять же, можно создать BAT-файл, удаляющий сборку при неудачном результате проверки.</p></li>\n</ul>\n"}