---
title: "Answer 907269"
se.owner.user_id: 178556
se.owner.display_name: "default locale"
se.owner.link: "https://ru.stackoverflow.com/users/178556/default-locale"
se.answer_id: 907269
se.question_id: 907230
se.post_type: answer
se.score: 6
se.is_accepted: True
---
<p>По-моему тут накладываются друг на друга две особенности работы CLR.</p>

<h2>Необработанные исключения в дочерних потоках убивают процесс</h2>

<p>Не только переполнение стека, а вообще любое необработанное исключение в дочернем потоке убивает весь процесс:</p>

<pre><code>static void Main()
{
    var thread = new Thread(Recursive);
    thread.Start();
    while (true)
    {
        Console.WriteLine("I will live forever!");
        Thread.Sleep(1000);
    }
}

static void Recursive()
{
    throw new Exception("RIP Unnamed Process (2018-2018");
}
</code></pre>

<p>Об это <a href="https://docs.microsoft.com/en-us/dotnet/standard/threading/exceptions-in-managed-threads" rel="nofollow noreferrer">говорится в MSDN</a>:</p>

<blockquote>
  <p>Starting with the .NET Framework version 2.0, the common language runtime allows most unhandled exceptions in threads to proceed naturally. In most cases this means that the unhandled exception causes the application to terminate.</p>
</blockquote>

<p>[Спорную] мотивацию такого поведения <a href="https://blogs.msdn.microsoft.com/ericlippert/2010/11/23/asynchrony-in-c-5-part-eight-more-exceptions/" rel="nofollow noreferrer">дает Эрик Липперт</a>:</p>

<blockquote>
  <p>We cannot easily tell the difference between bugs which are missing handlers for vexing/exogenous exceptions, and which are bugs that have caused a program crash because something is broken in the implementation. <strong>The safest thing to do is to assume that every unhandled exception is either a fatal exception or an unhandled boneheaded exception. In both cases, the right thing to do is to take down the process immediately.</strong></p>
  
  <p>This philosophy underlies the implementation of unhandled exceptions in the CLR. Way back in the CLR v1.0 days the policy was that an unhandled exception on the "main" thread took down the process aggressively, but an unhandled exception on a "worker" thread simply killed the thread and left the main thread running. (And an exception on the finalizer thread was ignored and finalizers kept running.) This turned out to be a poor choice; the scenario it leads to is that a server assigns a buggy subsystem to do some work on a bunch of worker threads; all the worker threads go down silently, and the user is stuck with a server that is sitting there waiting patiently for results that will never come because all the threads that produce results have disappeared. It is very difficult for the user to diagnose such a problem; a server that is working furiously on a hard problem and a server that is doing nothing because all its workers are dead look pretty much the same from the outside. The policy was therefore changed in CLR v2.0 such that an unhandled exception on a worker thread also takes down the process by default. You want to be noisy about your failures, not silent.</p>
</blockquote>

<p>Это означает что исключения в потоках нужно обрабатывать намертво, например так:</p>

<pre><code>static void SafeRecursive()
{
    try
    {
        Recursive();
    }
    catch (Exception e)
    {
        //должная обработка, запись в логи и уведомление администраторам
        //ха-ха, так никто не делает, просто глотаем и забываем о потоке
    }
}
</code></pre>

<h2>StackOverflowException нельзя поймать</h2>

<p>Но особенность <a href="https://docs.microsoft.com/en-us/dotnet/api/system.stackoverflowexception?view=netframework-4.7.2#version-considerations" rel="nofollow noreferrer">StackOverflowException</a> в том, что его нельзя поймать, ни в дочернем потоке, ни где-либо еще:</p>

<pre><code>static void Main()
{
    try
    {
        Recursive();
    }
    catch (Exception)
    {
        //не получится
        Console.WriteLine("Catch!");
    }
}
</code></pre>

<p>О чем сказано в документации исключения:</p>

<blockquote>
  <p>Starting with the .NET Framework 2.0, you can’t catch a StackOverflowException object with a try/catch block, and the corresponding process is terminated by default. Consequently, you should write your code to detect and prevent a stack overflow. </p>
</blockquote>

<p>Документация ясно дает понять, что нигде в процессе переполнение стека возникать не должно, вообще нигде.</p>

<p>Есть вырожденные случаи, в которых StackOverflowException все же можно обработать:</p>

<ul>
<li>если Вы сами <a href="https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/9x0wh2z3(v=vs.90)" rel="nofollow noreferrer">загружаете CLR</a>, то может получится ее восстановить;</li>
<li>если StackOverflowException выбрасывается кодом.</li>
</ul>

<p>В .Net 1.0 переполнение стека можно было отловить, с версии 2.0 разработчики заняли жесткую позицию: «Переполнение стека — проблема программиста и его кода, а не CLR». Я не смог найти прямых указаний на то, по какой причине потребовалось внести изменения. Предполагаю, что восстановление после SOE было небеспроблемно и разработчики решили не тратить на эту задачу ресурсы.</p>

<p>Вообще, обе эти особенности CLR вполне укладываются в пуританскую философскую позицию «мертвые программы не врут», которую также освещает Эрик Липперт:</p>

<blockquote>
  <p>I am of the philosophical school that says that sudden, catastrophic failure of a software device is, of course, unfortunate, but in many cases it is preferable that the software call attention to the problem so that it can be fixed, rather than trying to muddle along in a bad state, possibly introducing a security hole or corrupting user data along the way.</p>
</blockquote>

<h2>Обновление: Constrained Execution Regions</h2>

<p>Вопрос в комментариях:</p>

<blockquote>
  <p>А "Области с ограничением выполнения" CER - это что такое? Вот там можно повесить атрибут, что есть возможность того, что будет поврежден процесс. Это на что-то влияет?</p>
</blockquote>

<p>Влияет. <a href="https://docs.microsoft.com/en-us/dotnet/framework/performance/constrained-execution-regions" rel="nofollow noreferrer">CER</a> позволяет защититься от части ошибок, которые могли бы возникнуть при исполнении кода (ошибки загрузки классов, нехватки памяти) и корректно освободить ресурсы.</p>

<p>Тем не менее, переполнение стека с помощью CER обработать не получится. Об этом пишет Рихтер (CLR via C#, Constrained Execution Regions):</p>

<blockquote>
  <p><strong>Note</strong> Even if all the methods are eagerly prepared, a method call could still result in a StackOverflowException. When the CLR is not being hosted, a StackOverflowException causes the process to terminate immediately by the CLR internally calling Environment.FailFast. When hosted, the PreparedConstrainedRegions method checks the stack to see if there is approximately 48 KB of stack space remaining. If there is limited stack space,
  the StackOverflowException occurs before entering the try block.</p>
  
  <p><strong>Внимание:</strong> Даже если все методы были явно подготовлены, вызов метода все еще может привести к StackOverflowException. Если CLR не загружена извне, то StackOverflowException завершает процесс немедленно, вызывая Environment.FailFast. Если CLR загружена извне, то метод PreparedConstrainedRegions  проверяет, осталось ли в стеке примерно 48КБ свободного пространства. Если пространство стека ограничено, то StackOverflowException вызывается перед входом в блок try.</p>
</blockquote>

<p>Т.о. отловить переполнение стека с помощью одного CER не получится. StackOverflowException также отдельно упоминается в <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.runtimehelpers.prepareconstrainedregions?view=netframework-4.7.2" rel="nofollow noreferrer">документации</a>:</p>

<blockquote>
  <p>CERs that are marked using the PrepareConstrainedRegions method do not work perfectly when a StackOverflowException is generated from the try block. For more information, see the ExecuteCodeWithGuaranteedCleanup method.</p>
</blockquote>

<p>Мне никак не удалось заставить метод <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.runtimehelpers.executecodewithguaranteedcleanup?view=netframework-4.7.2" rel="nofollow noreferrer">ExecuteCodeWithGuaranteedCleanup</a> обработать переполнение стека. Судя по обсуждению в <a href="https://stackoverflow.com/questions/2591364/when-does-executecodewithguaranteedcleanup-actually-guarantee-cleanup">вопросе по данному методу</a> он также сработает только если Вы сами захостите CLR. </p>

<h2>Ссылки</h2>

<ul>
<li><a href="https://stackoverflow.com/questions/4284986/catching-unhandled-exception-on-separate-threads">Catching unhandled exception on separate threads</a> — вопрос об обработке исключений в отдельном потоке</li>
<li><a href="https://stackoverflow.com/questions/5983779/catch-exception-that-is-thrown-in-different-thread">catch exception that is thrown in different thread</a> — еще один.</li>
<li><a href="https://stackoverflow.com/questions/206820/how-do-i-prevent-and-or-handle-a-stackoverflowexception">How do I prevent and/or handle a StackOverflowException?</a> — вопрос о предупреждении SOE, рассматриваются разного рода костыли.</li>
<li><a href="https://blogs.msdn.microsoft.com/jaredpar/2008/10/22/when-can-you-catch-a-stackoverflowexception/" rel="nofollow noreferrer">When can you catch a StackOverflowException?</a> — статья о вырожденных случаях, которая только подчеркивает, что SOE поймать нельзя.</li>
<li><a href="https://blogs.msdn.microsoft.com/ericlippert/2010/11/23/asynchrony-in-c-5-part-eight-more-exceptions/" rel="nofollow noreferrer">Asynchrony in C# 5, Part Eight: More Exceptions</a> — статья Эрика Липперта об исключениях в асинхронных функциях, в которой, между делом, рассказывается об истории обработки исключений в дочерних потоках в .Net 1.0 и, в целом, об отношении авторов C# к обработке исключений.</li>
</ul>
