{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1525952760,"creation_date":1525952760,"answer_id":825851,"question_id":825504,"body":"<p>Для получения SMART-показателей в Windows используется IoCtl  <a href=\"https://msdn.microsoft.com/en-us/library/windows/hardware/ff566204%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396\" rel=\"nofollow noreferrer\">SMART_RCV_DRIVE_DATA</a>. </p>\n\n<p>Реализацию на С++ возьмем из статьи <a href=\"https://www.codeproject.com/Articles/16671/Hard-drive-information-using-S-M-A-R-T\" rel=\"nofollow noreferrer\">Hard drive information using S.M.A.R.T.</a> на CodeProject и слегка упростим. Для сборки понадобятся некоторые заголовочные файлы из Windows DDK (они также есть в архиве по ссылке). Получаем такой код (запускать с правами администратора):</p>\n\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;tchar.h&gt;\n#include &lt;windows.h&gt;\n#include &lt;locale.h&gt;\n#include &lt;map&gt;\n\n#define _WIN32_WINNT 0x500\n//Windows DDK header files\n#include \"devioctl.h\"\n#include \"ntdddisk.h\"\n#pragma warning(disable:4786)\n\nusing namespace std;\ntypedef map&lt;DWORD,LPVOID&gt; SMARTINFOMAP;\n\n//SMART attribute constants\n#define SMART_ATTRIB_RAW_READ_ERROR_RATE                    1\n#define SMART_ATTRIB_THROUGHPUT_PERFORMANCE                 2\n#define SMART_ATTRIB_SPIN_UP_TIME                           3\n#define SMART_ATTRIB_START_STOP_COUNT                       4\n#define SMART_ATTRIB_START_REALLOCATION_SECTOR_COUNT        5\n#define SMART_ATTRIB_SEEK_ERROR_RATE                        7\n#define SMART_ATTRIB_POWER_ON_HOURS_COUNT                   9\n#define SMART_ATTRIB_SPIN_RETRY_COUNT                       10\n#define SMART_ATTRIB_RECALIBRATION_RETRIES                  11\n#define SMART_ATTRIB_DEVICE_POWER_CYCLE_COUNT               12\n#define SMART_ATTRIB_SOFT_READ_ERROR_RATE                   13\n#define SMART_ATTRIB_LOAD_UNLOAD_CYCLE_COUNT                193\n#define SMART_ATTRIB_TEMPERATURE                            194\n#define SMART_ATTRIB_ECC_ON_THE_FLY_COUNT                   195\n#define SMART_ATTRIB_REALLOCATION_EVENT_COUNT               196\n#define SMART_ATTRIB_CURRENT_PENDING_SECTOR_COUNT           197\n#define SMART_ATTRIB_UNCORRECTABLE_SECTOR_COUNT             198\n#define SMART_ATTRIB_ULTRA_DMA_CRC_ERROR_COUNT              199\n#define SMART_ATTRIB_WRITE_ERROR_RATE                       200\n#define SMART_ATTRIB_TA_COUNTER_INCREASED                   202\n#define SMART_ATTRIB_GSENSE_ERROR_RATE                      221\n#define SMART_ATTRIB_POWER_OFF_RETRACT_COUNT                228\n#define MAX_ATTRIBUTES  256\n\n#define INDEX_ATTRIB_INDEX                                  0\n#define INDEX_ATTRIB_UNKNOWN1                               1\n#define INDEX_ATTRIB_UNKNOWN2                               2\n#define INDEX_ATTRIB_VALUE                                  3\n#define INDEX_ATTRIB_WORST                                  4\n#define INDEX_ATTRIB_RAW                                    5\n\n//SMART structures\n\ntypedef struct\n{\n    BYTE m_ucAttribIndex;\n    DWORD m_dwAttribValue;\n    BYTE m_ucValue;\n    BYTE m_ucWorst;\n    DWORD m_dwThreshold;\n}ST_SMART_INFO;\n\n\ntypedef struct \n{\n    WORD wGenConfig;\n    WORD wNumCyls;\n    WORD wReserved;\n    WORD wNumHeads;\n    WORD wBytesPerTrack;\n    WORD wBytesPerSector;\n    WORD wSectorsPerTrack;\n    WORD wVendorUnique[3];\n    BYTE sSerialNumber[20];\n    WORD wBufferType;\n    WORD wBufferSize;\n    WORD wECCSize;\n    BYTE sFirmwareRev[8];\n    BYTE sModelNumber[39];\n    WORD wMoreVendorUnique;\n    WORD wDoubleWordIO;\n    WORD wCapabilities;\n    WORD wReserved1;\n    WORD wPIOTiming;\n    WORD wDMATiming;\n    WORD wBS;\n    WORD wNumCurrentCyls;\n    WORD wNumCurrentHeads;\n    WORD wNumCurrentSectorsPerTrack;\n    WORD ulCurrentSectorCapacity;\n    WORD wMultSectorStuff;\n    DWORD ulTotalAddressableSectors;\n    WORD wSingleWordDMA;\n    WORD wMultiWordDMA;\n    BYTE bReserved[127];\n}ST_IDSECTOR;\n\ntypedef struct\n{\n    BYTE  bDriverError;\n    BYTE  bIDEStatus;\n    BYTE  bReserved[2];\n    DWORD dwReserved[2];\n} ST_DRIVERSTAT;\n\ntypedef struct\n{\n    DWORD      cBufferSize;\n    ST_DRIVERSTAT DriverStatus;\n    BYTE       bBuffer[1];\n} ST_ATAOUTPARAM;\n\n\ntypedef struct\n{\n    GETVERSIONINPARAMS m_stGVIP;\n    ST_IDSECTOR m_stInfo;\n    ST_SMART_INFO m_stSmartInfo[256];\n    BYTE m_ucSmartValues;\n    BYTE m_ucDriveIndex;\n    char m_csErrorString[1000];\n}ST_DRIVE_INFO;\n\ntypedef struct\n{\n    BOOL m_bCritical;\n    BYTE m_ucAttribId;\n    char m_csAttribName[100];\n    char m_csAttribDetails[1000];\n}ST_SMART_DETAILS;\n\n#define DRIVE_HEAD_REG  0xA0\n\n/*Global variables*/\nSMARTINFOMAP m_oSmartInfo; //map для хранения SMART-показателей\nST_DRIVE_INFO m_stDrivesInfo[32]; //массив с данными о жестких дисках\n\n/*Functions*/\n\n//преобразование идентификатора SMART-показателя в строку\nchar* SmartIndexToString(BYTE index)\n{\n    switch (index)\n    {\ncase SMART_ATTRIB_RAW_READ_ERROR_RATE   : return \"RAW_READ_ERROR_RATE\";\ncase  SMART_ATTRIB_THROUGHPUT_PERFORMANCE   : return \"THROUGHPUT_PERFORMANCE\";\ncase  SMART_ATTRIB_SPIN_UP_TIME         : return \"SPIN_UP_TIME\";\ncase  SMART_ATTRIB_START_STOP_COUNT     : return \"START_STOP_COUNT\";\ncase  SMART_ATTRIB_START_REALLOCATION_SECTOR_COUNT      : return \"START_REALLOCATION_SECTOR_COUNT\";\ncase  SMART_ATTRIB_SEEK_ERROR_RATE                      : return \"SEEK_ERROR_RATE\";\ncase  SMART_ATTRIB_POWER_ON_HOURS_COUNT : return \"POWER_ON_HOURS_COUNT\";\ncase  SMART_ATTRIB_SPIN_RETRY_COUNT     : return \"SPIN_RETRY_COUNT\";\ncase  SMART_ATTRIB_RECALIBRATION_RETRIES    : return \"RECALIBRATION_RETRIES\";\ncase  SMART_ATTRIB_DEVICE_POWER_CYCLE_COUNT : return \"DEVICE_POWER_CYCLE_COUNT\";\ncase  SMART_ATTRIB_SOFT_READ_ERROR_RATE     : return \"SOFT_READ_ERROR_RATE\";\ncase  SMART_ATTRIB_LOAD_UNLOAD_CYCLE_COUNT      : return \"LOAD_UNLOAD_CYCLE_COUNT\";\ncase  SMART_ATTRIB_TEMPERATURE                  : return \"TEMPERATURE\";\ncase  SMART_ATTRIB_ECC_ON_THE_FLY_COUNT     : return \"ECC_ON_THE_FLY_COUNT\";\ncase  SMART_ATTRIB_REALLOCATION_EVENT_COUNT : return \"REALLOCATION_EVENT_COUNT\";\ncase  SMART_ATTRIB_CURRENT_PENDING_SECTOR_COUNT: return \"CURRENT_PENDING_SECTOR_COUNT\";\ncase  SMART_ATTRIB_UNCORRECTABLE_SECTOR_COUNT   : return \"UNCORRECTABLE_SECTOR_COUNT\";\ncase  SMART_ATTRIB_ULTRA_DMA_CRC_ERROR_COUNT    : return \"ULTRA_DMA_CRC_ERROR_COUNT\";\ncase  SMART_ATTRIB_WRITE_ERROR_RATE         : return \"WRITE_ERROR_RATE  \";\ncase  SMART_ATTRIB_TA_COUNTER_INCREASED     : return \"TA_COUNTER_INCREASED\";\ncase  SMART_ATTRIB_GSENSE_ERROR_RATE            : return \"GSENSE_ERROR_RATE\";\ncase  SMART_ATTRIB_POWER_OFF_RETRACT_COUNT      : return \"POWER_OFF_RETRACT_COUNT   \";\n\n    default:\n        return \"\";\n    }\n}\n\n//вывод сообщения об ошибке\nvoid ErrorMes(LPTSTR lpszFunction) \n{ \n    // Retrieve the system error message for the last-error code\n\n    LPVOID lpMsgBuf;\n    LPVOID lpDisplayBuf;\n    DWORD dw = GetLastError(); \n\n    FormatMessage(\n        FORMAT_MESSAGE_ALLOCATE_BUFFER | \n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,\n        dw,\n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n        (LPTSTR) &amp;lpMsgBuf,\n        0, NULL );\n\n    // Display the error message and exit the process\n\n    lpDisplayBuf = (LPVOID)LocalAlloc(LMEM_ZEROINIT, \n        (lstrlen((LPCTSTR)lpMsgBuf) + lstrlen((LPCTSTR)lpszFunction) + 40) * sizeof(TCHAR)); \n    printf(\"%s failed with error %d: %s\", \n        lpszFunction, dw, lpMsgBuf);     \n\n    LocalFree(lpMsgBuf);\n    LocalFree(lpDisplayBuf);\n\n}\n\n//получение значения показателя из m_oSmartInfo\nST_SMART_INFO * GetSMARTValue(BYTE ucDriveIndex,BYTE ucAttribIndex)\n{\n    SMARTINFOMAP::iterator pIt;\n    ST_SMART_INFO *pRet=NULL;\n\n    pIt=m_oSmartInfo.find(MAKELPARAM(ucAttribIndex,ucDriveIndex));\n    if(pIt!=m_oSmartInfo.end())\n        pRet=(ST_SMART_INFO *)pIt-&gt;second;\n    return pRet;\n}\n\nBOOL ReadSMARTAttributes(HANDLE hDevice,UCHAR ucDriveIndex)\n{\n    SENDCMDINPARAMS stCIP={0};\n    DWORD dwRet=0;\n    BOOL bRet=FALSE;\n    BYTE    szAttributes[sizeof(ST_ATAOUTPARAM) + READ_ATTRIBUTE_BUFFER_SIZE - 1];\n    UCHAR ucT1;\n    PBYTE pT1,pT3;PDWORD pT2;\n    ST_SMART_INFO *pSmartValues;\n\n    stCIP.cBufferSize=READ_ATTRIBUTE_BUFFER_SIZE;\n    stCIP.bDriveNumber =ucDriveIndex;\n    stCIP.irDriveRegs.bFeaturesReg=READ_ATTRIBUTES;\n    stCIP.irDriveRegs.bSectorCountReg = 1;\n    stCIP.irDriveRegs.bSectorNumberReg = 1;\n    stCIP.irDriveRegs.bCylLowReg = SMART_CYL_LOW;\n    stCIP.irDriveRegs.bCylHighReg = SMART_CYL_HI;\n    stCIP.irDriveRegs.bDriveHeadReg = DRIVE_HEAD_REG;\n    stCIP.irDriveRegs.bCommandReg = SMART_CMD;\n    bRet=DeviceIoControl(hDevice,SMART_RCV_DRIVE_DATA,&amp;stCIP,sizeof(stCIP),szAttributes,sizeof(ST_ATAOUTPARAM) + READ_ATTRIBUTE_BUFFER_SIZE - 1,&amp;dwRet,NULL);\n    if(bRet)\n    {\n        m_stDrivesInfo[ucDriveIndex].m_ucSmartValues=0;\n        m_stDrivesInfo[ucDriveIndex].m_ucDriveIndex=ucDriveIndex;\n        pT1=(PBYTE)(((ST_ATAOUTPARAM*)szAttributes)-&gt;bBuffer);\n        for(ucT1=0;ucT1&lt;30;++ucT1)\n        {\n            pT3=&amp;pT1[2+ucT1*12];\n            pT2=(PDWORD)&amp;pT3[INDEX_ATTRIB_RAW];\n            pT3[INDEX_ATTRIB_RAW+2]=pT3[INDEX_ATTRIB_RAW+3]=pT3[INDEX_ATTRIB_RAW+4]=pT3[INDEX_ATTRIB_RAW+5]=pT3[INDEX_ATTRIB_RAW+6]=0;\n            if(pT3[INDEX_ATTRIB_INDEX]!=0)\n            {\n                pSmartValues=&amp;m_stDrivesInfo[ucDriveIndex].m_stSmartInfo[m_stDrivesInfo[ucDriveIndex].m_ucSmartValues];\n                pSmartValues-&gt;m_ucAttribIndex=pT3[INDEX_ATTRIB_INDEX];\n                pSmartValues-&gt;m_ucValue=pT3[INDEX_ATTRIB_VALUE];\n                pSmartValues-&gt;m_ucWorst=pT3[INDEX_ATTRIB_WORST];\n                pSmartValues-&gt;m_dwAttribValue=pT2[0];\n                pSmartValues-&gt;m_dwThreshold=MAXDWORD;\n                m_oSmartInfo[MAKELPARAM(pSmartValues-&gt;m_ucAttribIndex,ucDriveIndex)]=pSmartValues;\n                m_stDrivesInfo[ucDriveIndex].m_ucSmartValues++;\n            }\n        }\n    }\n    else\n        dwRet=GetLastError();\n\n    stCIP.irDriveRegs.bFeaturesReg=READ_THRESHOLDS;\n    stCIP.cBufferSize=READ_THRESHOLD_BUFFER_SIZE; // Is same as attrib size\n    bRet=DeviceIoControl(hDevice,SMART_RCV_DRIVE_DATA,&amp;stCIP,sizeof(stCIP),szAttributes,sizeof(ST_ATAOUTPARAM) + READ_ATTRIBUTE_BUFFER_SIZE - 1,&amp;dwRet,NULL);\n    if(bRet)\n    {\n        pT1=(PBYTE)(((ST_ATAOUTPARAM*)szAttributes)-&gt;bBuffer);\n        for(ucT1=0;ucT1&lt;30;++ucT1)\n        {\n            pT2=(PDWORD)&amp;pT1[2+ucT1*12+5];\n            pT3=&amp;pT1[2+ucT1*12];\n            pT3[INDEX_ATTRIB_RAW+2]=pT3[INDEX_ATTRIB_RAW+3]=pT3[INDEX_ATTRIB_RAW+4]=pT3[INDEX_ATTRIB_RAW+5]=pT3[INDEX_ATTRIB_RAW+6]=0;\n            if(pT3[0]!=0)\n            {\n                pSmartValues=GetSMARTValue(ucDriveIndex,pT3[0]);\n                if(pSmartValues)\n                    pSmartValues-&gt;m_dwThreshold=pT2[0];\n            }\n        }\n    }\n    return bRet;\n}\n\nBOOL CollectDriveInfo(HANDLE hDevice,UCHAR ucDriveIndex)\n{\n    BOOL bRet=FALSE;\n    SENDCMDINPARAMS stCIP={0};\n    DWORD dwRet=0;\n    #define OUT_BUFFER_SIZE IDENTIFY_BUFFER_SIZE+16\n    char szOutput[OUT_BUFFER_SIZE]={0};\n\n    stCIP.cBufferSize=IDENTIFY_BUFFER_SIZE;\n    stCIP.bDriveNumber =ucDriveIndex;\n    stCIP.irDriveRegs.bFeaturesReg=0;\n    stCIP.irDriveRegs.bSectorCountReg = 1;\n    stCIP.irDriveRegs.bSectorNumberReg = 1;\n    stCIP.irDriveRegs.bCylLowReg = 0;\n    stCIP.irDriveRegs.bCylHighReg = 0;\n    stCIP.irDriveRegs.bDriveHeadReg = DRIVE_HEAD_REG;\n    stCIP.irDriveRegs.bCommandReg = ID_CMD;\n\n    bRet=DeviceIoControl(hDevice,SMART_RCV_DRIVE_DATA,&amp;stCIP,sizeof(stCIP),szOutput,OUT_BUFFER_SIZE,&amp;dwRet,NULL);\n    if(bRet)\n    {\n        CopyMemory(&amp;m_stDrivesInfo[ucDriveIndex].m_stInfo,szOutput+16,sizeof(ST_IDSECTOR)); \n    }\n    else\n        dwRet=GetLastError();\n    return bRet;\n}\n\nBOOL IsSmartEnabled(HANDLE hDevice,UCHAR ucDriveIndex)\n{\n    SENDCMDINPARAMS stCIP={0};\n    SENDCMDOUTPARAMS stCOP={0};\n    DWORD dwRet=0;\n    BOOL bRet=FALSE;\n\n    stCIP.cBufferSize=0;\n    stCIP.bDriveNumber =ucDriveIndex;\n    stCIP.irDriveRegs.bFeaturesReg=ENABLE_SMART;\n    stCIP.irDriveRegs.bSectorCountReg = 1;\n    stCIP.irDriveRegs.bSectorNumberReg = 1;\n    stCIP.irDriveRegs.bCylLowReg = SMART_CYL_LOW;\n    stCIP.irDriveRegs.bCylHighReg = SMART_CYL_HI;\n    stCIP.irDriveRegs.bDriveHeadReg = DRIVE_HEAD_REG;\n    stCIP.irDriveRegs.bCommandReg = SMART_CMD;\n\n    bRet=DeviceIoControl(hDevice,SMART_SEND_DRIVE_COMMAND,&amp;stCIP,sizeof(stCIP),&amp;stCOP,sizeof(stCOP),&amp;dwRet,NULL);\n    if(bRet)\n    {\n\n    }\n    else\n    {\n        dwRet=GetLastError();\n        sprintf(m_stDrivesInfo[ucDriveIndex].m_csErrorString,\"Error %d in reading SMART Enabled flag\",dwRet);       \n    }\n    return bRet;\n}\n\n//Считывает SMART-показатели для диска с указанным индексом\nBOOL ReadSMARTInfo(BYTE ucDriveIndex)\n{\n    HANDLE hDevice=NULL;\n    char szT1[MAX_PATH]={0};\n    BOOL bRet=FALSE;\n    DWORD dwRet=0;\n\n    wsprintf(szT1,\"\\\\\\\\.\\\\PHYSICALDRIVE%d\",ucDriveIndex);\n    hDevice=CreateFile(szT1,GENERIC_READ|GENERIC_WRITE,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_SYSTEM,NULL);\n    if(hDevice!=INVALID_HANDLE_VALUE)\n    {\n        bRet=DeviceIoControl(hDevice,SMART_GET_VERSION,NULL,0,&amp;m_stDrivesInfo[ucDriveIndex].m_stGVIP,sizeof(GETVERSIONINPARAMS),&amp;dwRet,NULL);\n        if(bRet)\n        {           \n            if((m_stDrivesInfo[ucDriveIndex].m_stGVIP.fCapabilities &amp; CAP_SMART_CMD)==CAP_SMART_CMD)\n            {\n                if(IsSmartEnabled(hDevice,ucDriveIndex))\n                {\n                    bRet=CollectDriveInfo(hDevice,ucDriveIndex);\n                    bRet=ReadSMARTAttributes(hDevice,ucDriveIndex);\n                }\n            }\n        }\n        CloseHandle(hDevice);\n    }\n    else ErrorMes(\"CreateFile\");\n    return bRet;\n}\n</code></pre>\n\n<p>Пример вывода в консоль показателей по первому диску:</p>\n\n<pre><code>int _tmain(int argc, _TCHAR* argv[])\n{\n\n    setlocale(LC_ALL,\"Russian\");\n    BOOL res = ReadSMARTInfo(0);\n    ST_SMART_INFO * pSmart;\n\n    for(int i=0;i&lt;MAX_ATTRIBUTES;i++)\n    {\n        pSmart = GetSMARTValue(0,i);\n        if(pSmart == NULL)continue;\n        printf(\"0x%02x %s: %u\\n\", pSmart-&gt;m_ucAttribIndex,SmartIndexToString(pSmart-&gt;m_ucAttribIndex),(UINT)pSmart-&gt;m_ucValue);\n\n    }\n\n    system(\"PAUSE\");\n    return 0;\n}\n</code></pre>\n"}