---
title: "Answer 1038514"
se.owner.user_id: 184217
se.owner.display_name: "Alexander Petrov"
se.owner.link: "https://ru.stackoverflow.com/users/184217/alexander-petrov"
se.answer_id: 1038514
se.question_id: 1037304
se.post_type: answer
se.score: 3
se.is_accepted: False
---
<p><sub>Пожалуйста, не плюсуйте это сообщение, т. к. оно не является точным ответом на вопрос. Минусовать можно.</sub></p>

<p>Рассмотрим ваш код по шагам.<br>
Считали файл как массив байтов:</p>

<pre><code>byte[] bf = File.ReadAllBytes(path);
</code></pre>

<p>Конвертировали массив байтов в base64:</p>

<pre><code>string s = Convert.ToBase64String(bf);
</code></pre>

<p>Внутри метода <code>Base64Decode</code> тут же конвертировали эту base64-строку обратно в байты:</p>

<pre><code>var base64EncodedBytes = System.Convert.FromBase64String(base64EncodedData);
</code></pre>

<p>То есть содержимое массивов <code>base64EncodedBytes</code> и <code>bf</code> одинаково. Можно смело выкидывать эти действия.</p>

<p>Далее массив байтов преобразуется в строку:</p>

<pre><code>return System.Text.Encoding.UTF8.GetString(base64EncodedBytes);
</code></pre>

<p>Я не спец в PDF, однако быстрый поиск <a href="https://stackoverflow.com/a/10656899/5045688">показывает</a>, что внутри PDF могут быть разные кодировки. И не факт, что у вашего файла UTF-8. Поэтому вы могли получить кракозябры вместо текста.</p>

<p>После замены вы перегоняете строку в байты кодировки UTF-8.<br>
Далее вы опять совершаете ненужные действия: массив байтов конвертируется в base64 и тут же обратно из base64 в массив байтов.</p>

<p>Как я понимаю, эти ненужные конвертации ничего не должны портить. Но они просто лишние и создают нагрузку на процессор и память.</p>

<hr>

<p>Вообще, незачем читать сперва байты, а потом перекодировать их в текст в нужной кодировке. Можно это сделать сразу, вызовом одного метода:</p>

<pre><code>var text = File.ReadAllText(path, Encoding.UTF8);
</code></pre>

<p>Тут делаем замену: <code>text = text.Replace</code>.<br>
Записываем аналогично:</p>

<pre><code>File.WriteAllText(path, text, Encoding.UTF8);
</code></pre>

<p>Естественно, кодировки должны совпадать при чтении и записи.</p>

<p>Можно попробовать брутфорс: перебрать все кодировки.</p>

<pre><code>foreach (var encoding in Encoding.GetEncodings())
</code></pre>

<p>Их довольно много. У меня показывает 140 штук.</p>

<hr>

<p>Никто больше не отвечает, так что буду отдуваться.</p>

<p>Почему простая строковая замена не работает? Повторю, что я не спец в PDF. Но там вполне может быть структура данных с полями определённых размеров. И когда вы делаете замену:</p>

<pre><code>decodeStr.Replace(@"/Producer (HiQPdf 11.1)", "/Producer (MyMy)");
</code></pre>

<p>то очевидно, что длины строк не совпадают. Из-за этого весь текст сдвигается. Но это же не просто текст - это структура данных со множеством полей, где хранится разметка страниц, шрифты, изображения и многое другое. В результате сдвига эти данные сломались. В итоге вы получаете пустые листы.</p>

<p>Самый лучший способ решения проблемы - взять библиотеку для работы с PDF, о чём уже писали в комментариях.</p>
