---
title: "Answer 971989"
se.owner.user_id: 184217
se.owner.display_name: "Alexander Petrov"
se.owner.link: "https://ru.stackoverflow.com/users/184217/alexander-petrov"
se.answer_id: 971989
se.question_id: 969675
se.post_type: answer
se.score: 2
se.is_accepted: False
---
<p>Давайте я попробую немножко объяснить по-своему.</p>

<p>Зайду с другого конца: зачем на практике могут понадобиться интерфейсы?</p>

<p>Допустим, вам понадобилось выводить на консоль содержимое списка <code>List&lt;int&gt;</code> и вы написали такой метод для этого:</p>

<pre><code>static void Print(List&lt;int&gt; list)
{
    foreach (var n in list)
        Console.Write(n + " ");
    Console.WriteLine();
}
</code></pre>

<p>Теперь можно его использовать:</p>

<pre><code>List&lt;int&gt; list = new List&lt;int&gt; { 1, 2, 3 };
Print(list);
</code></pre>

<p>Удобно.</p>

<p>Но что, если нам понадобилось вывести массив? Пробуем использовать этот же метод:</p>

<pre><code>int[] array = new int[] { 4, 5, 6 };
Print(array);
</code></pre>

<p>Увы, это невозможно.</p>

<p>Как быть? Давайте разберёмся, что именно делается со списком в этом методе: он <em>перечисляется</em> (enumerate). В него ничего не добавляется, не изменяется, не удаляется. Всё, что от него требуется - позволить себя перечислять (проходить по нему).</p>

<p>Интерфейс <code>IEnumerable</code> как раз и означает, что тип, реализующий его, является <em>перечислым</em> - по нему можно пробежаться в цикле.</p>

<p>Изменим наш метод следующим образом:</p>

<pre><code>static void Print(IEnumerable&lt;int&gt; list)
{
    foreach (var n in list)
        Console.Write(n + " ");
    Console.WriteLine();
}
</code></pre>

<p>Теперь код <code>Print(array);</code> успешно компилируется и работает.</p>

<p>Теперь мы можем передавать в этот метод любой тип, реализующий интерфейс <code>IEnumerable&lt;int&gt;</code>. Конечно, здесь мы ограничены типом <code>int</code>, но оставим это за рамками обсуждения.</p>

<p>Более того, другой программист, использующий нашу библиотеку с этим методом, по одной лишь сигнатуре этого метода скажет, что может произойти с коллекцией, которую он подаст на вход: она будет перечислена и только. А если метод принимает <code>List&lt;int&gt;</code>, то внутри метода вполне может произойти добавление новых данных в список или их удаление, или другие нежелательные действия...</p>

<p>Таким образом, интерфейсы позволяют использовать не один жёстко заданный тип, а множество разных. А также интерфейсы дают понять, какие действия разрешены.</p>

<p>PS: ещё больше гарантий по неизменности данных дают интерфейсы <code>IReadOnly*</code>.</p>
