{"owner":{"reputation":9630,"user_id":182162,"user_type":"registered","profile_image":"https://i.stack.imgur.com/JAEvg.jpg?s=128&g=1","display_name":"Mark Shevchenko","link":"https://ru.stackoverflow.com/users/182162/mark-shevchenko"},"is_accepted":true,"score":3,"last_activity_date":1563547262,"creation_date":1563547262,"answer_id":1004732,"question_id":1004704,"body":"<p>Похожие вещи делаются в C# через так называемые <em>деревья выражений</em>. Эта тема сложная, которая требует ознакомления, и её невозможно осветить в одном ответе на Stack Overflow.</p>\n\n<p>Если вкратце, то для начала вы должны объявить параметр не как <code>Func&lt;T, bool&gt;</code>, <code>Action&lt;T&gt;</code> или <code>Predicate&lt;T&gt;</code>, а как <code>Expression&lt;Func&lt;T, bool&gt;&gt;</code> или <code>Expression&lt;Predicated&lt;T&gt;&gt;</code>.</p>\n\n<pre><code>public string GetSource&lt;T&gt;(Expression&lt;Predicate&lt;T&gt;&gt; expression)\n{\n    . . .\n}\n</code></pre>\n\n<p>В этом случае вы не сможете просто вызывать метод, предварительно его придётся <a href=\"https://docs.microsoft.com/ru-ru/dotnet/api/system.linq.expressions.expression-1.compile?view=netframework-4.8\" rel=\"nofollow noreferrer\">скомпилировать</a>.</p>\n\n<p>На зато вы можете <em>разобрать</em> его на составные части. В случае <code>x.Name == \"name\"</code> в корне дерева будет находиться объект типа <a href=\"https://docs.microsoft.com/ru-ru/dotnet/api/system.linq.expressions.binaryexpression?view=netframework-4.8\" rel=\"nofollow noreferrer\"><code>BinaryExpression</code></a> со свойством <a href=\"https://docs.microsoft.com/ru-ru/dotnet/api/system.linq.expressions.expression.nodetype?view=netframework-4.8\" rel=\"nofollow noreferrer\"><code>NodeType</code></a> равным <a href=\"https://docs.microsoft.com/ru-ru/dotnet/api/system.linq.expressions.expressiontype?view=netframework-4.8\" rel=\"nofollow noreferrer\"><code>ExpressionType.Equal</code></a>.</p>\n\n<p>Левый и правый дочерние узлы этого узла будут представлять <code>x.Name</code> и <code>\"name\"</code> соответственно. Проще всего пройтись в отладчике по этому дереву и посмотреть, какие объекты там встречаются.</p>\n\n<p>Чтобы вывести всё это на экран, можно просто вызвать метод <code>expression.ToString()</code>. Но в сложных случаях придётся формировать строку из дерева выражения самостоятельно.</p>\n"}