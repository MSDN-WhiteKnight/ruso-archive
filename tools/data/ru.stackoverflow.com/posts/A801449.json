{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":2,"last_activity_date":1521460997,"last_edit_date":1521460997,"creation_date":1521460448,"answer_id":801449,"question_id":753833,"body":"<p>Для NTFS-дисков начиная с Windows 7, как <a href=\"https://ru.stackoverflow.com/questions/753833/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0-%D0%BF%D0%BE-%D0%BD%D0%BE%D0%BC%D0%B5%D1%80%D1%83-%D0%BA%D0%BB%D0%B0%D1%81%D1%82%D0%B5%D1%80%D0%B0-%D0%BD%D0%B0-%D0%B4%D0%B8%D1%81%D0%BA%D0%B5/801449#comment1163645_753833\">отметил jfs</a>, можно использовать <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ff951637%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396\" rel=\"nofollow noreferrer\">FSCTL_LOOKUP_STREAM_FROM_CLUSTER</a> (требует привилегий администратора). </p>\n\n<p>Пример на С++:</p>\n\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;locale.h&gt;  \n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n#include &lt;tchar.h&gt;\n\n/*Вывод сообщения об ошибке*/\nvoid ErrorMes(LPTSTR lpszFunction) \n{ \n    // Retrieve the system error message for the last-error code\n\n    LPVOID lpMsgBuf;\n    LPVOID lpDisplayBuf;\n    DWORD dw = GetLastError(); \n\n    FormatMessage(\n        FORMAT_MESSAGE_ALLOCATE_BUFFER | \n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,\n        dw,\n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n        (LPTSTR) &amp;lpMsgBuf,\n        0, NULL );\n\n    // Display the error message and exit the process\n\n    lpDisplayBuf = (LPVOID)LocalAlloc(LMEM_ZEROINIT, \n        (lstrlen((LPCTSTR)lpMsgBuf) + lstrlen((LPCTSTR)lpszFunction) + 40) * sizeof(TCHAR)); \n    wprintf(L\"%s failed with error %d: %s\", \n        lpszFunction, dw, lpMsgBuf);     \n\n    LocalFree(lpMsgBuf);\n    LocalFree(lpDisplayBuf);\n\n}\n\n/*Отображение информации о файле, расположенном в указанном кластере указанного тома*/\nBOOL FindFileByClaster(TCHAR* volume,LONGLONG cluster){\n\n    HANDLE hDevice = CreateFile(volume,      // drive to open\n        GENERIC_READ ,                       // access to the drive\n        FILE_SHARE_READ | FILE_SHARE_WRITE,  // share mode\n        NULL,                                // default security attributes\n        OPEN_EXISTING,                       // disposition\n        FILE_FLAG_BACKUP_SEMANTICS,          // file attributes\n        NULL);\n\n    if(hDevice == INVALID_HANDLE_VALUE)\n    {   \n          ErrorMes(L\"CreateFile\");\n          return FALSE;\n    }\n\n    //входные параметры\n    LOOKUP_STREAM_FROM_CLUSTER_INPUT input={0};\n    input.NumberOfClusters = 1;\n    input.Cluster[0].QuadPart = cluster;        \n\n    //буфер для результатов\n    BYTE output[5000]={};\n    DWORD dwRes=0;\n    LOOKUP_STREAM_FROM_CLUSTER_OUTPUT result={0};   \n\n    //пытаемся отправить IOCTL...\n    BOOL bRes = DeviceIoControl( (HANDLE)       hDevice,   // handle to file, directory, or volume \n                 FSCTL_LOOKUP_STREAM_FROM_CLUSTER, // dwIoControlCode\n                 (LPVOID)       &amp;input,        // input buffer \n                 (DWORD)        sizeof(input),     // size of input buffer \n                 (LPVOID)       output,       // output buffer \n                 (DWORD)        5000,    // size of output buffer \n                 (LPDWORD)      &amp;dwRes,   // number of bytes returned \n                 NULL );    // OVERLAPPED structure\n\n    if(bRes == FALSE){      \n          ErrorMes(L\"DeviceIoControl\");\n          return FALSE;\n    }\n\n    //переносим результат из массива в структуру LOOKUP_STREAM_FROM_CLUSTER_OUTPUT\n    memcpy(&amp;result,output,sizeof(LOOKUP_STREAM_FROM_CLUSTER_OUTPUT));\n\n    if(result.NumberOfMatches == 0){\n        wprintf( L\"Файл не найден\\n\");\n        return FALSE;\n    }   \n\n    wprintf( L\"Информация о файле\\n\");\n\n    //переходим к адресу первой структуры LOOKUP_STREAM_FROM_CLUSTER_ENTRY\n    BYTE* p = (BYTE*)output + result.Offset;\n    LOOKUP_STREAM_FROM_CLUSTER_ENTRY* pentry = (LOOKUP_STREAM_FROM_CLUSTER_ENTRY*)p;    \n\n    //выводим информацию\n    wprintf( L\"Flags: 0x%x \",(UINT)pentry-&gt;Flags);\n\n    if((pentry-&gt;Flags &amp; LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_PAGE_FILE) &gt; 0) wprintf(L\"(Pagefile)\");\n    else if((pentry-&gt;Flags &amp; LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_FS_SYSTEM_FILE) &gt; 0)  wprintf(L\"(Internal filesystem file)\");\n    else if((pentry-&gt;Flags &amp; LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_TXF_SYSTEM_FILE) &gt; 0) wprintf(L\"(Internal TXF file)\");\n    else wprintf(L\"(Normal file)\"); \n\n    wprintf( L\"\\nFile: %s\\n\",pentry-&gt;FileName); \n    return TRUE;\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    setlocale(LC_ALL,\"Russian\");\n\n    LONGLONG inp=0;\n    wprintf( L\"Введите номер кластера: \\n\");\n    scanf(\"%llu\",&amp;inp);\n\n    FindFileByClaster(L\"\\\\\\\\.\\\\C:\",inp);        \n\n    system(\"PAUSE\");\n    return 0;\n}\n</code></pre>\n\n<p>Данный пример выводит имя потока, чтобы получить имя файла, нужно взять часть до вхождения строки \"::\" (например, до префикса<code>::$DATA</code>).</p>\n"}