---
title: "Answer 1075141"
se.owner.user_id: 240512
se.owner.display_name: "MSDN.WhiteKnight"
se.owner.link: "https://ru.stackoverflow.com/users/240512/msdn-whiteknight"
se.answer_id: 1075141
se.question_id: 1075088
se.post_type: answer
se.score: 3
se.is_accepted: False
---
<blockquote>
  <p>Есть ли вообще понятие таблицы виртуальных функций в шарпе? Допустим есть иерархия классов, в классе на вершине иерархии виртуальный метод, который переопределяется в child классах. Методы с середины иерархии с меткой override заносятся в таблицу виртуальных функций?</p>
</blockquote>

<p>Не столько "виртуальных", сколько просто таблица функций (методов). Каждый тип имеет таблицу методов, которая хранит указатели на дескрипторы всех методов этого класса, как виртуальных, так обычных. В таблицу каждого типа заносится указатель либо на реализацию в этом типе, если это собственный или переопределенный виртуальный метод, либо на одну из реализаций выше по иерархии, если он унаследован. Естественно, каждая реализация будет в какой-то таблице, иначе как ее можно было бы вызвать? </p>

<p>Информацию о структуре таблицы методов можно посмотреть здесь: <a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2005/may/net-framework-internals-how-the-clr-creates-runtime-objects" rel="nofollow noreferrer">.NET Framework Internals: How the CLR Creates Runtime Objects</a> - хоть статья и старая, идеи в основном не изменились.</p>

<blockquote>
  <p>сказано, что для структур используется call для вызова функций, т. к.
  это значимый тип, но структуры также неявно наследуются от
  System.Object и могут оверрайдить методы, так вот, вопрос, для этих
  методов используется call или callvirt? Также интересует, когда
  используется call для вызова виртуальных функций и как работает
  таблица виртуальных функций для структур, т.к. методы оверрайдятся</p>
</blockquote>

<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes.call" rel="nofollow noreferrer">call</a> используется для вызова статического метода, либо для вызова метода экземпляра через раннее связывание (метод известен на этапе компиляции). Метод может быть как виртуальным, так и обычным, и принадлежать как структуре, так и классу. Но если вызвать виртуальный метод через <code>call</code>, virtual dispatch на деле не происходит, т.е. вызов вырождается в невиртуальный.</p>

<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes.callvirt" rel="nofollow noreferrer">callvirt</a> используется для вызова методов экземпляра через позднее связывание (метод определяется реальным типом объекта во время выполнения). Метод может быть как виртуальным, так и обычным, и принадлежать как структуре, так и классу. Но для обычного метода позднее связывание, конечно, вырождается в ранее, так как выбирать CLR не из чего (у всех наследников реализация одна и та же).</p>

<p>На практике, компилятор C# генерирует <code>callvirt</code> для вызовов всех виртуальных методов и вызовов обычных методов на классах (последнее связано, насколько я знаю, с лучшей диагностикой вызовов по null-ссылкам). <code>call</code> он генерирует для вызовов статических методов и вызовов обычных методов на структурах. </p>

<p>Следует понимать, что тут много тонкостей, все из которых невозможно описать в рамках ответа. Например, метод, реализующий интерфейс, с точки зрения CLR будет всегда виртуальным, даже если мы об этом не просили, т.е. не пометили его <code>virtual</code> в C#. Кроме того, чтобы <code>callvirt</code> работал со структурами, используется специальный префикс <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes.constrained" rel="nofollow noreferrer">constrained</a>. Полную информацию о внутренней механике CLR и структуре IL-кода можно посмотреть в спецификации <a href="https://www.ecma-international.org/publications/standards/Ecma-335.htm" rel="nofollow noreferrer">ECMA-335 Common Language Infrastructure</a>.</p>
