{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":2,"last_activity_date":1526271257,"last_edit_date":1526271257,"creation_date":1526270739,"answer_id":827498,"question_id":825131,"body":"<p>Для USB-мышей в Windows лог событий можно получить с помощью механизма Event Tracing. Этот механизм позволяет собирать события от определенных источников (провайдеров) и сохранять их в файл журнала событий (.etl). Этот файл потом можно открыть с помощью стандартной оснастки просмотра событий Windows или специализированного софта типа Network Monitor, либо прочитать программно с помощью того же API. </p>\n\n<p>Отслеживать передаваемые данные USB-устройств позволяют провайдеры <em>Microsoft-Windows-USB-USBPORT</em> (USB 2.0, введен в Windows 7) и <em>Microsoft-Windows-USB-UCX</em> (USB 3.0, введен в Windows 8); USB-мышь отправляет данные по протоколу HID, приблизительную структуру ее пакета можно посмотреть <a href=\"http://lms.ee.hm.edu/~seck/AlleDateien/OS9HILFE/OS9-Manuals-Teil2/usb_host.pdf\" rel=\"nofollow noreferrer\">здесь</a>. Для работы с Event Tracing в .NET существует библиотека <a href=\"https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent/\" rel=\"nofollow noreferrer\">Microsoft.Diagnostics.Tracing.TraceEvent</a>.</p>\n\n<p>Для запуска сеансов отслеживания требуются права администратора, но для чтения сохраненных логов они не обязательны. Запуск/остановку сеансов отслеживания можно также производить не из кода, а с помощью утилиты командной строки logman. Большой плюс способа в том, что сеанс отслеживания управляется самой системой и работает независимо от программы, т.е. можно закрыть программу и продолжать отслеживание (параметр StopOnDispose = false), пока сеанс не будет явно остановлен (программно или через logman / системный монитор). При желании можно настроить и так, чтобы отслеживание начиналось сразу при загрузке системы. Недостаток в том, что данные по движению мыши приходят не в пикселях, а в аппаратных единицах, и преобразовать их в пиксельные координаты довольно сложно.</p>\n\n<p>Пример кода отслеживания HID-пакетов для клавиатуры есть <a href=\"https://github.com/CyberPoint/Ruxcon2016ETW/tree/master/KeyloggerPOC\" rel=\"nofollow noreferrer\">здесь</a>. Модифицируем его, так чтобы можно было сохранять события в файл и добавим обработку мышиных пакетов, получаем что-то такое:</p>\n\n<pre><code>using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Microsoft.Diagnostics.Tracing;\nusing Microsoft.Diagnostics.Tracing.Session;\nusing System.Threading;    \n\nnamespace EtwHidlogger\n{\n    public interface IPrint\n    {\n        void Print(string text);\n    }\n\n    public class KeyMap\n    {\n        public static string[] GetKey(int value)\n        {\n            switch (value)\n            {                \n                case 0x00: return new string[1]; // unused\n                case 0x04: return new[] { \"a\", \"A\" };\n                case 0x05: return new[] { \"b\", \"B\" };\n                case 0x06: return new[] { \"c\", \"C\" };\n                case 0x07: return new[] { \"d\", \"D\" };\n                case 0x08: return new[] { \"e\", \"E\" };\n                case 0x09: return new[] { \"f\", \"F\" };\n                case 0x0A: return new[] { \"g\", \"G\" };\n                case 0x0B: return new[] { \"h\", \"H\" };\n                case 0x0C: return new[] { \"i\", \"I\" };\n                case 0x0D: return new[] { \"j\", \"J\" };\n                case 0x0E: return new[] { \"k\", \"K\" };\n                case 0x0F: return new[] { \"l\", \"L\" };\n                case 0x10: return new[] { \"m\", \"M\" };\n                case 0x11: return new[] { \"n\", \"N\" };\n                case 0x12: return new[] { \"o\", \"O\" };\n                case 0x13: return new[] { \"p\", \"P\" };\n                case 0x14: return new[] { \"q\", \"Q\" };\n                case 0x15: return new[] { \"r\", \"R\" };\n                case 0x16: return new[] { \"s\", \"S\" };\n                case 0x17: return new[] { \"t\", \"T\" };\n                case 0x18: return new[] { \"u\", \"U\" };\n                case 0x19: return new[] { \"v\", \"V\" };\n                case 0x1A: return new[] { \"w\", \"W\" };\n                case 0x1B: return new[] { \"x\", \"X\" };\n                case 0x1C: return new[] { \"y\", \"Y\" };\n                case 0x1D: return new[] { \"z\", \"Z\" };\n                case 0x1E: return new[] { \"1\", \"!\" };\n                case 0x1F: return new[] { \"2\", \"@\" };\n                case 0x20: return new[] { \"3\", \"#\" };\n                case 0x21: return new[] { \"4\", \"$\" };\n                case 0x22: return new[] { \"5\", \"%\" };\n                case 0x23: return new[] { \"6\", \"^\" };\n                case 0x24: return new[] { \"7\", \"&amp;\" };\n                case 0x25: return new[] { \"8\", \"*\" };\n                case 0x26: return new[] { \"9\", \"(\" };\n                case 0x27: return new[] { \"0\", \")\" };\n                case 0x28: return new[] { \"[RET]\" };\n                case 0x29: return new[] { \"[ESC]\" };\n                case 0x2A: return new[] { \"[DEL]\" };\n                case 0x2B: return new[] { \"[TAB]\" };\n                case 0x2C: return new[] { \"[SPACE]\" };\n                case 0x2D: return new[] { \"-\", \"_\" };\n                case 0x2E: return new[] { \"=\", \"+\" };\n                case 0x2F: return new[] { \"[\", \"{\" };\n                case 0x30: return new[] { \"]\", \"}\" };\n                case 0x31: return new[] { \"\\\\\", \"|\" };\n                case 0x32: return new[] { \"#\", \"~\" };       //non-US\n                case 0x33: return new[] { \";\", \":\" };\n                case 0x34: return new[] { \"\\'\", \"\\\"\" };\n                case 0x35: return new[] { \"`\", \"~\" };\n                case 0x36: return new[] { \";\", \"&lt;\" };\n                case 0x37: return new[] { \".\", \"&gt;\" };\n                case 0x38: return new[] { \"/\", \"?\" };\n                case 0x39: return new[] { \"[CAPS]\" };\n                case 0x3A: return new[] { \"[F1]\" };\n                case 0x3B: return new[] { \"[F2]\" };\n                case 0x3C: return new[] { \"[F3]\" };\n                case 0x3D: return new[] { \"[F4]\" };\n                case 0x3E: return new[] { \"[F5]\" };\n                case 0x3F: return new[] { \"[F6]\" };\n                case 0x40: return new[] { \"[F7]\" };\n                case 0x41: return new[] { \"[F8]\" };\n                case 0x42: return new[] { \"[F9]\" };\n                case 0x43: return new[] { \"[F10]\" };\n                case 0x44: return new[] { \"[F11]\" };\n                case 0x45: return new[] { \"[F12]\" };\n                case 0x46: return new[] { \"[PRT]\" };\n                case 0x47: return new[] { \"[SCL]\" };\n                case 0x48: return new[] { \"[PAU]\" };\n                case 0x49: return new[] { \"[INS]\" };\n                case 0x4A: return new[] { \"[HOME]\" };\n                case 0x4B: return new[] { \"[P-UP]\" };\n                case 0x4C: return new[] { \"[FWD]\" };\n                case 0x4D: return new[] { \"[END]\" };\n                case 0x4E: return new[] { \"[P-DN]\" };\n                case 0x4F: return new[] { \"[RT]\" };\n                case 0x50: return new[] { \"[LT]\" };\n                case 0x51: return new[] { \"[DN]\" };\n                case 0x52: return new[] { \"[UP]\" };\n                case 0x53: return new[] { \"[NUM]\", \"[CLR]\" };\n                case 0x54: return new[] { \"/\" };\n                case 0x55: return new[] { \"*\" };\n                case 0x56: return new[] { \"-\" };\n                case 0x57: return new[] { \"+\" };\n                case 0x58: return new[] { \"[ENTER]\" };\n                case 0x59: return new[] { \"1\", \"[END]\" };\n                case 0x5A: return new[] { \"2\", \"[DN]\" };\n                case 0x5B: return new[] { \"3\", \"[P-DN]\" };\n                case 0x5C: return new[] { \"4\", \"[LT]\" };\n                case 0x5D: return new[] { \"5\" };\n                case 0x5E: return new[] { \"6\", \"[RT]\" };\n                case 0x5F: return new[] { \"7\", \"[HOME]\" };\n                case 0x60: return new[] { \"8\", \"[UP]\" };\n                case 0x61: return new[] { \"9\", \"[P-UP]\" };\n                case 0x62: return new[] { \"0\", \"[INS]\" };\n                case 0x63: return new[] { \".\", \"[DEL]\" };\n                case 0x64: return new[] { \"\\\\\", \"|\" };      //non-US\n\n                default: return null;\n            }\n        }\n    }\n\n    /*Represents a block of data transferred via USB*/\n    public class UsbData\n    {\n        public byte usbver; //usb version (2.0 or 3.0)\n        public byte[] data; //transferred bytes\n        public ulong hndl; //device handle\n        public DateTime time; //timestamp\n        public uint vid; //Vendor ID (2.0 only)\n        public uint pid; //Product ID (2.0 only)\n        public uint datalen; //amount of bytes transferred\n\n        public UsbData(DateTime inputTime, ulong inputHndl, byte[] inputData)\n        {\n            time = inputTime;\n            data = inputData;\n            hndl = inputHndl;\n        }\n    }\n\n    /*A class to manage Event tracing for Windows sessions*/\n    public class UsbEventSource\n    {\n        // Microsoft-Windows-USB-UCX (usb3.0)\n        private static Guid UsbUcx = new Guid(\"36DA592D-E43A-4E28-AF6F-4BC57C5A11E8\");\n        // Microsoft-Windows-USB-USBPORT (usb2.0)\n        private static Guid UsbPort = new Guid(\"C88A4EF5-D048-4013-9408-E04B7DB2814A\");\n\n        private static string sessionName = \"UsbKeylog\";\n        public static TraceEventSession session;\n\n        public static IPrint Instance; //object to display things on GUI                \n\n        /// &lt;summary&gt;\n        /// Starts new event tracing session\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"newSessionName\"&gt;Session name&lt;/param&gt;\n        /// &lt;param name=\"filename\"&gt;Path where to save event log file&lt;/param&gt;\n        public static void StartCapture(string newSessionName = null, string filename = \"log.etl\")\n        {\n            if (session != null) StopCapture();\n\n            if (newSessionName != null)\n                sessionName = newSessionName;\n\n            session = new TraceEventSession(\n                sessionName,\n                filename);              \n\n            session.EnableProvider(UsbUcx);\n            session.EnableProvider(UsbPort);\n        }\n\n        /// &lt;summary&gt;\n        /// Stops event tracing session\n        /// &lt;/summary&gt;\n        public static void StopCapture()\n        {\n            if (session != null)\n            {\n                session.Stop();\n                session.Dispose();\n                session = null;\n            }\n        }\n\n        private static Dictionary&lt;string, string&gt; _expose(object hidden)\n        {\n            string str = hidden.ToString();\n            char[] separators = { '{', '}', ',' };\n            char[] remove = { ' ', '\"' };\n            string[] s = str.Split(separators, StringSplitOptions.RemoveEmptyEntries);\n            Dictionary&lt;string, string&gt; item = s.ToDictionary(x =&gt; x.Split('=')[0].Trim(), x =&gt; x.Split('=')[1].Trim(remove));\n            return item;\n        }\n\n        //Gets item with certain name from event data\n        private static object GetItem(TraceEvent eventData, string item)\n        {  \n            object value = null;\n            int pIndex = eventData.PayloadIndex(item);\n            if (pIndex &lt; 0)\n                return value;\n\n            try\n            {\n                value = eventData.PayloadValue(pIndex);\n            }\n            catch (ArgumentOutOfRangeException) {                \n            }\n\n            return value;\n        }\n\n        //Parses usb event data\n        private static UsbData GetData(TraceEvent eventData)\n        {\n            ulong hndl;\n            object field;\n            uint vid=0,pid=0;\n            byte usbver = 0;\n\n            //try to determine device handle and IDs\n            field = GetItem(eventData, \"fid_USBPORT_Device\");\n            if (field != null)\n            {\n                Dictionary&lt;string, string&gt; deviceInfo = _expose(field);\n\n                if (!ulong.TryParse(deviceInfo[\"DeviceHandle\"], out hndl) &amp;&amp; hndl &lt;= 0)\n                    return null;\n\n                vid = UInt32.Parse(deviceInfo[\"idVendor\"]);\n                pid = UInt32.Parse(deviceInfo[\"idProduct\"]);\n            }\n            else\n            {\n                hndl = (ulong)GetItem(eventData, \"fid_PipeHandle\");\n                if (hndl &lt;= 0) return null;\n            }\n\n            //try to get event parameters\n            field = GetItem(eventData, \"fid_USBPORT_URB_BULK_OR_INTERRUPT_TRANSFER\"); //2.0\n            usbver = 2;\n            if (field == null)\n            {\n                field = GetItem(eventData, \"fid_UCX_URB_BULK_OR_INTERRUPT_TRANSFER\"); //3.0\n                usbver = 3;\n            }\n            Dictionary&lt;string, string&gt; urb = _expose(field);//transform parameter string to dictionary\n\n            //determine transferred data length\n            int xferDataSize = 0;\n            if (!int.TryParse(urb[\"fid_URB_TransferBufferLength\"], out xferDataSize))\n                return null;\n            if ((xferDataSize &gt; 8) &amp;&amp; (usbver == 2)) xferDataSize = 8; //USB 2.0 sometimes gives wrong size \n\n            if (xferDataSize &gt; 8) return null; //data is too large for mouse / keyboard\n\n            byte[] data2=eventData.EventData();\n            byte[] xferData = new byte[xferDataSize];\n            Array.Copy(data2, eventData.EventDataLength - xferDataSize, xferData, 0, xferDataSize);\n\n            bool HasNonZero = false;\n            for (int i = 0; i &lt; xferDataSize; i++)\n                if (xferData[i] != 0) { HasNonZero = true; break; }\n            if (HasNonZero == false) return null; //data is empty\n\n            /* Construct UsbData object*/\n            UsbData data = new UsbData(eventData.TimeStamp, hndl, xferData);\n            data.usbver = usbver;\n            data.datalen = (uint)xferDataSize;\n            data.vid = vid;\n            data.pid = pid;\n            return data;\n        }\n\n\n\n        //Method called on new event\n        public static void EventCallback(TraceEvent eventData)\n        {\n\n            if (eventData.EventDataLength &lt;= 0)\n                return;\n\n            UsbData usbdata = null;\n            string output = \"\";\n\n            try\n            {\n\n                if (eventData.PayloadNames.Contains(\"fid_USBPORT_URB_BULK_OR_INTERRUPT_TRANSFER\")\n                    || eventData.PayloadNames.Contains(\"fid_UCX_URB_BULK_OR_INTERRUPT_TRANSFER\"))\n                    usbdata = GetData(eventData);\n\n                if (usbdata == null) return;\n\n                string idstr=\"\";\n                if (usbdata.usbver == 2)\n                {\n                    idstr = String.Format(\"VID_0x{0} PID_0x{1}\", usbdata.vid.ToString(\"X4\"), usbdata.pid.ToString(\"X4\"));\n                }\n\n                //determine what device data comes from and actual length of data (for USB 2.0)\n                bool IsMouse = false;\n                uint len = usbdata.datalen;\n\n                //(mouse data is 4 or 5 bytes, keyboard - 8 bytes)\n                if (usbdata.datalen &lt; 8) { IsMouse = true; len = usbdata.datalen; }\n                else\n                {\n                    if (usbdata.usbver == 2 &amp;&amp;\n                        usbdata.data[0] == 0 &amp;&amp; usbdata.data[1] == 0 &amp;&amp;\n                        usbdata.data[2] == 4 &amp;&amp; usbdata.data[3] == 0) { IsMouse = true; len = 4; }\n                    else if (usbdata.usbver == 2 &amp;&amp; \n                        usbdata.data[0] == 5 &amp;&amp; usbdata.data[1] == 0) { IsMouse = true; len = 5; }\n                    else IsMouse = false;\n                }\n\n                //Print data\n                if (IsMouse == false &amp;&amp; usbdata.data[1]==0) //second byte must be zero for keyboard\n                {\n                    var arr = ParseKeys(usbdata.data);\n                    output = String.Format(\"{0} {1} Keyboard \", usbdata.time, idstr);\n                    if (arr != null) foreach (var s in arr) output += s + \" \";\n                }\n                else\n                {                                        \n                    sbyte b;\n                    output = String.Format(\"{0} {1} Mouse \",usbdata.time,idstr);\n\n                    uint i_start = usbdata.datalen - len;                                        \n                    uint index;\n                    bool action = false;\n\n                    for (uint i = i_start; i &lt; usbdata.datalen; i++)\n                    {\n                        index = i - i_start;\n                        b = (sbyte)usbdata.data[i];\n                        switch (index)\n                        {\n                            case 0: //first byte defines pressed buttons\n                                if ((usbdata.data[i] &amp; 0x01) &gt; 0) {output+= \"Left button press \";action=true;}\n                                if ((usbdata.data[i] &amp; 0x02) &gt; 0) {output += \"Right button press \";action=true;}\n                                if ((usbdata.data[i] &amp; 0x04) &gt; 0) {output += \"Middle button press \";action=true;}\n                                if ((usbdata.data[i] &amp; 0x08) &gt; 0) {output += \"Special button press \";action=true;}\n                                if ((usbdata.data[i] &amp; 0xf0) &gt; 0) { output += \"Special button press \";action = true; }\n\n                                break;\n                            case 1: //second byte is x movement\n                                if (usbdata.data[i] != 0 || usbdata.data[i + 1] != 0) { output += \"move: \"; action = true; }\n                                if (usbdata.data[i] != 0) output += \"dx=\" + b.ToString() + \" \";\n                                break;\n                            case 2: //third byte is y movement\n                                if (usbdata.data[i] != 0) output += \"dy=\" + b.ToString() + \" \";\n                                break;\n                            case 3: //4th byte (if present) is wheel movement\n                                if (usbdata.data[i] != 0)\n                                {\n                                    output += \"Wheel Move: Delta=\" + b.ToString() + \" \";\n                                    action = true;\n                                }\n                                break;\n                        }\n\n                        /*output += b.ToString() + \" \";*/\n                    }\n                    if (!action) output += \"Button release\";\n\n                }\n\n\n            }\n            catch (Exception ex)\n            {\n                output = \"Error in callback: \"+ex.GetType().ToString()+\" \"+ex.Message;\n            }\n\n            if(output!=\"\")Instance.Print(output);\n            //datastore.Add(usbdata);\n        }\n\n\n\n        private static string[] ParseKeys(byte[] bytes)\n        {\n            string[] result = new string[2];\n            result[0] = BitConverter.ToString(bytes).Replace(\"-\", \" \");\n\n            // modifiers:\n            //  CTL = 1\n            //  SFT = 2\n            //  ALT = 4\n            byte modByte = bytes[0];\n            byte noneByte = bytes[1];\n\n            byte[] dataBytes = new byte[6];\n            Array.Copy(bytes, 2, dataBytes, 0, 6);\n\n            string[] fullKeyStroke = new string[6];\n\n            // convert usageId -&gt; usageName\n            for (int i = 0; i &lt; fullKeyStroke.Length; i++)\n            {\n                int usageId = dataBytes[i];\n                string[] key = KeyMap.GetKey(usageId);\n\n                // skip unmapped data\n                if (key == null)\n                    return null;\n\n                // empty data (usageId == 0)\n                if (key.SequenceEqual(new string[1]))\n                {\n                    fullKeyStroke[i] = \"\";\n                    continue;\n                }\n\n                // [SFT]\n                if ((modByte &amp; 0x22) != 0)\n                    fullKeyStroke[i] = key.Last();\n                else\n                    fullKeyStroke[i] = key.First();\n            }\n\n            string parsed = \"\";\n            if ((modByte &amp; 0x11) != 0)\n                parsed += \"[CTL] \";\n            if ((modByte &amp; 0x44) != 0)\n                parsed += \"[ALT] \";\n            parsed += String.Join(\" \", fullKeyStroke);\n            result[1] = parsed.Trim();\n\n            return result;\n        }        \n\n    }\n}\n</code></pre>\n\n<p>Пример использования:</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Text;\nusing System.Windows.Forms;\nusing EtwHidlogger;\nusing Microsoft.Diagnostics.Tracing;\nusing Microsoft.Diagnostics.Tracing.Session;\n\nnamespace HidLogger\n{\n    public partial class Form1 : Form, IPrint\n    {\n        StringBuilder sb;\n\n        public void Print(string text)\n        {\n            if (sb == null) sb = new StringBuilder(50000);\n            if (text == null) return;\n            this.Invoke((MethodInvoker)(() =&gt;\n            {\n                sb.AppendLine(text);\n            }));\n        }\n\n        public Form1()\n        {\n            InitializeComponent();\n            UsbEventSource.Instance = this;\n        }\n\n        //запуск сеанса отслеживания\n        private void bStartCapture_Click(object sender, EventArgs e)\n        {\n            string session = tbSessionName.Text;            \n\n            try\n            {\n                UsbEventSource.StartCapture(session, tbFile.Text);\n                MessageBox.Show(\"Capture sesion is started\");   \n            }\n            catch (Exception ex)\n            {\n                tbEvents.Text = ex.ToString();\n            }            \n        }\n\n        //остановка сеанса отслеживания\n        private void bStopCapture_Click(object sender, EventArgs e)\n        {\n            try\n            {\n                UsbEventSource.StopCapture();\n                MessageBox.Show(\"Capture sesion is stopped\");\n            }\n            catch (Exception ex)\n            {\n                tbEvents.Text = ex.ToString();\n            }  \n\n        }\n\n        //чтение сохраненных событий из .etl-файла\n        private void bViewEvents_Click(object sender, EventArgs e)\n        {\n            tbEvents.Text = \"\";\n            sb = new StringBuilder(50000);\n            try\n            {\n                this.Cursor = Cursors.WaitCursor;\n                ETWTraceEventSource src = new ETWTraceEventSource(tbFile.Text);\n                src.Dynamic.All += UsbEventSource.EventCallback;\n                src.Process();\n\n                string s;\n                if \n                    (sb.Length &lt;= 100000) s = sb.ToString();\n                else \n                    s = sb.ToString().Substring(0, 99999) +\n                        Environment.NewLine + \"(some text trimmed)\";\n\n                tbEvents.Text = s;                \n            }\n            catch (Exception ex)\n            {\n                tbEvents.Text = ex.ToString();\n            }\n            finally\n            {\n                this.Cursor = Cursors.Arrow;\n            }\n        } \n\n    }\n}\n</code></pre>\n"}