{"tags":["c#",".net","com","interop"],"owner":{"reputation":4994,"user_id":206435,"user_type":"registered","accept_rate":78,"profile_image":"https://www.gravatar.com/avatar/aff8ab0e5f74d01facde887535318d53?s=128&d=identicon&r=PG","display_name":"ヒミコ","link":"https://ru.stackoverflow.com/users/206435/%e3%83%92%e3%83%9f%e3%82%b3"},"is_answered":true,"view_count":58,"accepted_answer_id":912842,"answer_count":2,"score":4,"last_activity_date":1543421236,"creation_date":1543102305,"last_edit_date":1543252092,"question_id":911112,"link":"https://ru.stackoverflow.com/questions/911112/%d0%9d%d0%b0%d1%81%d0%bb%d0%b5%d0%b4%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-comobject-%d0%b8%d0%bd%d1%82%d0%b5%d1%80%d1%84%d0%b5%d0%b9%d1%81%d0%be%d0%b2-%d0%b8-%d0%bd%d0%b0%d0%b7%d0%bd%d0%b0%d1%87%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b0%d1%82%d1%82%d1%80%d0%b8%d0%b1%d1%83%d1%82%d0%be%d0%b2","title":"Наследование ComObject интерфейсов и назначение аттрибутов","body":"<p>Есть ли необходимость повторно указывать аттрибут типа интерфейса <code>Com</code>, если он наследуется от другого <code>Com</code> интерфейса, в котором уже был задан тип?</p>\n\n<p>Пример:</p>\n\n<pre><code>[ComImport]\n[Guid(\"aec22fb8-76f3-4639-9be0-28eb43a67a2e\")]\n[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\npublic interface IDXGIObject\n{\n    long SetPrivateData([In] ref Guid name, [In] uint dataSize, IntPtr dataPtr);\n\n    long SetPrivateDataInterface([In] ref Guid name, [In] [MarshalAs(UnmanagedType.IUnknown)]\n        object unknownInterfaceObject);\n\n    long GetPrivateData([In] ref Guid name, out int dataSize, out IntPtr dataPtr);\n\n    long GetParent([In] ref Guid rIId, [Out] out object pParent);\n}\n</code></pre>\n\n<p>Далее, его наследником будет <code>IDXGIFactory</code>:</p>\n\n<pre><code>/// &lt;inheritdoc cref=\"IDXGIObject\"/&gt; /&gt;\n/// &lt;summary&gt;\n///     An IDXGIFactory interface implements methods for generating DXGI objects (which handle fullscreen transitions).\n/// &lt;/summary&gt;\n[ComImport]\n[Guid(\"7b7166ec-21c7-44ae-b21a-c9ae321ae369\")]\n[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\npublic interface IDXGIFactory : IDXGIObject\n{\n    /// &lt;summary&gt;\n    ///     Enumerates the adapters (video cards).\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    HResult EnumAdapters(uint numAdapter, [MarshalAs(UnmanagedType.IUnknown)] out object adapter);\n\n    /// &lt;summary&gt;\n    ///     Allows DXGI to monitor an application's message queue for the alt-enter key sequence (which causes the application\n    ///     to switch from windowed to fullscreen or vice versa).\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    HResult MakeWindowAssociation(IntPtr windowHandle, uint flags);\n\n    /// &lt;summary&gt;\n    ///     Get the window through which the user controls the transition to and from fullscreen.\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    HResult GetWindowAssociation(out IntPtr outHandleWindow);\n\n    /// &lt;summary&gt;\n    ///     Creates a swap chain.\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    HResult CreateSwapChain(IntPtr lpIUnknown, IntPtr ptr, out IntPtr outPtr);\n\n    /// &lt;summary&gt;\n    ///     Create an adapter interface that represents a software adapter.\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    HResult CreateSoftwareAdapter(IntPtr moduleHandle, out IntPtr outPtr);\n}\n</code></pre>\n\n<p>Есть ли необходимость вновь писать аттрибут</p>\n\n<pre><code>[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n</code></pre>\n\n<p>для интерфейса наследника, если он тоже по сути является <code>IUnknown</code>?</p>\n"}