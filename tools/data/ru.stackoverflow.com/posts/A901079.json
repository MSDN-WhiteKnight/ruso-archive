{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":2,"last_activity_date":1541100227,"creation_date":1541100227,"answer_id":901079,"question_id":899928,"body":"<p>Все числовые типы объединяет то, что они являются структурами и реализуют интерфейс IComparable. С этим ограничением уже можно отсечь много неподходящих типов на этапе компиляции. Не нужно использовать статические конструкторы для \"валидации\", они предназначены для инициализации глобального состояния, и класс, единственная задача которого - арифметические операции, вообще не должен их иметь. Проверяйте перед вычислением (или компиляцией выражения), это намного более логично.</p>\n\n<p>Что касается алгоритма, есть еще один способ, который лежит на поверхности: это простой обобщенный метод с несколькими ветками в условном операторе. Может показаться, что веток будет слишком много, но на самом деле, операции сложения для многих типов по сути одинаковы и отличаются только типом, к которому приводится конечный результат. Например, операцию сложения на целом типе можно представить как операцию сложения на Decimal с последующим \"сужающим\" приведением к целому типу (Decimal позволяет представить все значения любых целых типов и еще оставляет некоторый запас для обработки переполнений). Аналогично, сложение на типе float можно представить как сложение на типе double с последующим преобразованием результата. </p>\n\n<p>Весь набор числовых типов можно разделить на три группы:</p>\n\n<ol>\n<li><strong>Беззнаковые целые.</strong> Для них формула преобразования из Decimal в конкретный тип будет выглядеть так:</li>\n</ol>\n\n<blockquote>\n  <p>y = x % 2 <sup> n</sup> </p>\n</blockquote>\n\n<p>где n - размер типа в битах.</p>\n\n<p>(Остаток от деления тут появляется, так как по умолчанию у нас unchecked-контекст, и переполнения не генерируют ошибку, а просто обрезаются по границе типа.)</p>\n\n<ol start=\"2\">\n<li><strong>Знаковые целые.</strong> Для них минимальное значение равно <strong>- 0.5 * 2 <sup> n</sup></strong>, а максимальное <strong>0.5 * 2 <sup> n</sup> - 1</strong>. Пользуясь этим, можно вывести формулу перевода:</li>\n</ol>\n\n<blockquote>\n  <p>y = (x + 2 <sup> n</sup> * 1.5) % 2 <sup> n</sup> - 0.5 * 2 <sup> n</sup></p>\n</blockquote>\n\n<p>На самом деле, формула может выглядеть по разному, но для отлова переполнений подходит именно такой вид.</p>\n\n<ol start=\"3\">\n<li><strong>С плавающей точкой.</strong> Ну, тут все просто, формула не нужна, так как преобразование из double в float это просто обрезка \"знаков после запятой\".</li>\n</ol>\n\n<p>Реализовать это можно так:</p>\n\n<pre><code>using System;\nusing System.Text;\n\nnamespace ConsoleApp1\n{\n    public class Calculator&lt;T&gt; where T : struct,IComparable\n    {\n        static bool IsSignedInteger(Type t)\n        {\n            return (t == typeof(sbyte) || t == typeof(short) || t == typeof(int) || t == typeof(long));\n        }\n\n        static bool IsUnsignedInteger(Type t)\n        {\n            return (t == typeof(byte) || t == typeof(ushort) || t == typeof(uint) || t == typeof(ulong));\n        }\n\n        static bool IsReal(Type t)\n        {\n            return (t == typeof(float) || t == typeof(double));\n        }\n\n        //преобразует значение из Decimal в целевой целочисленный тип\n        public static T FromDecimal(decimal val)\n        {\n            //вычисляем размер типа\n            int size = System.Runtime.InteropServices.Marshal.SizeOf(typeof(T));\n\n            //вычисляем количество элементов в целевом множестве\n            decimal capacity = (size &lt; 8) ? (1L &lt;&lt; (size * 8)) : ((decimal)UInt64.MaxValue + 1);\n\n            //отображаем элемент на целевое множество\n            decimal res;\n\n            if (IsUnsignedInteger(typeof(T)))\n            {\n                res = (val) % (capacity);\n                return (T)Convert.ChangeType(res, typeof(T));\n            }\n            else if (IsSignedInteger(typeof(T)))\n            {    \n                res = (val + capacity * 1.5M) % (capacity) - capacity * 0.5M;    \n                return (T)Convert.ChangeType(res, typeof(T));\n            }\n            else throw new NotSupportedException(typeof(T).ToString() + \" is not integer type\");\n        }\n\n        //непосредственно сложение\n        public static T Add(T A, T B)\n        {\n            if (IsSignedInteger(typeof(T)) || IsUnsignedInteger(typeof(T)))\n            {\n                return FromDecimal(Convert.ToDecimal(A) + Convert.ToDecimal(B));\n            }\n            else if (IsReal(typeof(T)))\n            {\n                return (T)Convert.ChangeType(Convert.ToDouble(A) + Convert.ToDouble(B), typeof(T));\n            }\n            else throw new NotSupportedException(typeof(T).ToString() + \" is not supported, because it is not numeric type\");\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {    \n            unchecked\n            {\n                //тест сложения целых чисел\n                Console.WriteLine(\"{0} {1}\", Calculator&lt;int&gt;.Add(1000, 222), (1000 + 222));\n                Console.WriteLine(\"{0} {1}\", Calculator&lt;byte&gt;.Add(200, 200), (byte)(200 + 200));\n                Console.WriteLine(\"{0} {1}\", Calculator&lt;sbyte&gt;.Add(100, 100), (sbyte)(100 + 100));                        \n                Console.WriteLine(\"{0} {1}\", Calculator&lt;long&gt;.Add(long.MinValue, -1), (long)(long.MinValue - 1));\n\n                //тест сложения с плавающей точкой    \n                Console.WriteLine(\"{0} {1}\", Calculator&lt;float&gt;.Add((float)Math.PI, 2.2f), (float)Math.PI + 2.2f);\n                Console.WriteLine(\"{0} {1}\", Calculator&lt;double&gt;.Add(Math.PI, 2.2), Math.PI + 2.2);\n\n                //этот код выдаст исключение...                \n                //Console.WriteLine(\"{0}\", Calculator&lt;DateTime&gt;.Add(DateTime.Now, new DateTime(2000, 1, 1)));\n                //Console.WriteLine(\"{0}\", Calculator&lt;bool&gt;.Add(true, true));\n\n                //а этот - не скомпилируется\n                //Console.WriteLine(\"{0}\", Calculator&lt;string&gt;.Add(\"Саша\", \"Маша\"));\n\n            } \n            Console.ReadKey();\n        }              \n    }\n}\n</code></pre>\n\n<p>Если наплевать на переполнения, то код можно значительно упростить.</p>\n"}