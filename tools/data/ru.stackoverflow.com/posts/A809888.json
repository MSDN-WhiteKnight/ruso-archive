{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":2,"last_activity_date":1522919695,"last_edit_date":1522919695,"creation_date":1522918567,"answer_id":809888,"question_id":788394,"body":"<p>Стек вызовов проще всего вывести из SEH-фильтра, передавая в функцию <em>StackWalk64</em> указатель на контекст, возвращенный <em>GetExceptionInformation</em>. Как-то так:</p>\n\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;locale.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n#include \"DbgHelp.h\"\n#pragma comment(lib, \"Dbghelp.lib\")\n\nconst int MaxNameLen = 256;\n\n//выводит стек вызовов, соответствующий указанному контексту\nvoid printStack( CONTEXT* ctx )\n{\n    BOOL    result;\n    HANDLE  process;\n    HANDLE  thread;\n    HMODULE hModule;\n\n    STACKFRAME64        stack;\n    ULONG               frame;    \n    DWORD64             displacement;\n\n    char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)];\n    char name[ MaxNameLen ];\n    char module[MaxNameLen];\n    PSYMBOL_INFO pSymbol = (PSYMBOL_INFO)buffer;\n\n    memset( &amp;stack, 0, sizeof( STACKFRAME64 ) );\n\n    process                = GetCurrentProcess();\n    thread                 = GetCurrentThread();\n    displacement           = 0;\n#if !defined(_M_AMD64)\n    stack.AddrPC.Offset    = (*ctx).Eip;\n    stack.AddrPC.Mode      = AddrModeFlat;\n    stack.AddrStack.Offset = (*ctx).Esp;\n    stack.AddrStack.Mode   = AddrModeFlat;\n    stack.AddrFrame.Offset = (*ctx).Ebp;\n    stack.AddrFrame.Mode   = AddrModeFlat;\n#endif\n\n    SymInitialize( process, NULL, TRUE ); //загружаем символы\n\n    for( frame = 0; ; frame++ )\n    {\n        //получаем следующий вызов из стека\n        result = StackWalk64\n        (\n#if defined(_M_AMD64)\n            IMAGE_FILE_MACHINE_AMD64\n#else\n            IMAGE_FILE_MACHINE_I386\n#endif\n            ,\n            process,\n            thread,\n            &amp;stack,\n            ctx,\n            NULL,\n            SymFunctionTableAccess64,\n            SymGetModuleBase64,\n            NULL\n        );\n\n        if( !result ) break;        \n\n        //полчаем имя символа для адреса\n        pSymbol-&gt;SizeOfStruct = sizeof(SYMBOL_INFO);\n        pSymbol-&gt;MaxNameLen = MAX_SYM_NAME;\n        SymFromAddr(process, ( ULONG64 )stack.AddrPC.Offset, &amp;displacement, pSymbol);\n\n        hModule = NULL;\n        lstrcpyA(module,\"\");        \n        GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, \n            (LPCTSTR)(stack.AddrPC.Offset), &amp;hModule);\n\n        //получаем имя модуля\n        if(hModule != NULL)GetModuleFileNameA(hModule,module,MaxNameLen);       \n\n        printf (\"%lu: %s  (in %s)\\n\",frame,pSymbol-&gt;Name,module);       \n\n    }\n}\n\n\n\nvoid BuggedFunction()\n{\n    int * p = NULL;\n    *p = 5;\n}\n\nvoid bar()\n{\n    BuggedFunction();\n}\n\nvoid foo()\n{    \n     bar();    \n}\n\nint seh_filter(_EXCEPTION_POINTERS* ex)\n{\n    printf(\"Exception 0x%x occured\\n\",ex-&gt;ExceptionRecord-&gt;ExceptionCode);  \n    printStack(ex-&gt;ContextRecord);\n\n    return EXCEPTION_EXECUTE_HANDLER;\n}\n\nint main(void)\n{\n    setlocale(LC_ALL,\"Russian\");\n\n    __try\n    {\n        foo();\n    }\n    __except(seh_filter(GetExceptionInformation()))\n    {       \n        printf(\"Exception \\n\");         \n    }\n    getchar();\n    return 0;\n}\n</code></pre>\n"}