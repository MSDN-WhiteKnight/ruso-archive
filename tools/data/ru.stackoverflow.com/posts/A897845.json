{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":4,"last_activity_date":1540524421,"last_edit_date":1540524421,"creation_date":1540475138,"answer_id":897845,"question_id":891355,"body":"<h1>Windows 8 - 10</h1>\n\n<p>Можно использовать стандартный <a href=\"https://docs.microsoft.com/en-us/windows/desktop/intl/about-the-spell-checker-api\" rel=\"nofollow noreferrer\">Spell Checking API</a>. Словари для проверки орфографии устанавливаются с языковым пакетом, так что при наличии русскоязычной Windows русский язык будет поддерживаться.</p>\n\n<p>Объявим необходимые интерфейсы:</p>\n\n<pre><code>using System.Runtime.InteropServices;\n\nnamespace ConsoleApplication1\n{\n    public class SpellCheckAPI\n    {\n        public enum WORDLIST_TYPE\n        {\n            WORDLIST_TYPE_IGNORE,\n            WORDLIST_TYPE_ADD,\n            WORDLIST_TYPE_EXCLUDE,\n            WORDLIST_TYPE_AUTOCORRECT,\n        }\n\n        public enum CORRECTIVE_ACTION\n        {\n            CORRECTIVE_ACTION_NONE,\n            CORRECTIVE_ACTION_GET_SUGGESTIONS,\n            CORRECTIVE_ACTION_REPLACE,\n            CORRECTIVE_ACTION_DELETE,\n        }\n\n        [Guid(\"B7C82D61-FBE8-4B47-9B27-6C0D2E0DE0A3\")]\n        [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n        [ComImport]\n        public interface ISpellingError\n        {\n            uint StartIndex { get; }\n\n            uint Length { get; }\n\n            SpellCheckAPI.CORRECTIVE_ACTION CorrectiveAction { get; }\n\n            string Replacement { [return: MarshalAs(UnmanagedType.LPWStr)] get; }\n        }\n\n        [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n        [Guid(\"803E3BD4-2828-4410-8290-418D1D73C762\")]\n        [ComImport]\n        public interface IEnumSpellingError\n        {\n            [return: MarshalAs(UnmanagedType.Interface)]\n            SpellCheckAPI.ISpellingError Next();\n        }\n\n        [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n        [Guid(\"00000101-0000-0000-C000-000000000046\")]\n        [ComImport]\n        public interface IEnumString\n        {\n            void Next([In] uint celt, [MarshalAs(UnmanagedType.LPWStr)] out string rgelt, out uint pceltFetched);\n\n            void Skip([In] uint celt);\n\n            void Reset();\n\n            void Clone([MarshalAs(UnmanagedType.Interface)] out SpellCheckAPI.IEnumString ppenum);\n        }\n\n        [Guid(\"432E5F85-35CF-4606-A801-6F70277E1D7A\")]\n        [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n        [ComImport]\n        public interface IOptionDescription\n        {\n            string Id { [return: MarshalAs(UnmanagedType.LPWStr)] get; }\n\n            string Heading { [return: MarshalAs(UnmanagedType.LPWStr)] get; }\n\n            string Description { [return: MarshalAs(UnmanagedType.LPWStr)] get; }\n\n            SpellCheckAPI.IEnumString Labels { [return: MarshalAs(UnmanagedType.Interface)] get; }\n        }\n\n        [Guid(\"0B83A5B0-792F-4EAB-9799-ACF52C5ED08A\")]\n        [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n        [ComImport]\n        public interface ISpellCheckerChangedEventHandler\n        {\n            void Invoke([MarshalAs(UnmanagedType.Interface), In] SpellCheckAPI.ISpellChecker sender);\n        }\n\n        [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n        [Guid(\"B6FD0B71-E2BC-4653-8D05-F197E412770B\")]\n        [ComImport]\n        public interface ISpellChecker\n        {\n            string languageTag { [return: MarshalAs(UnmanagedType.LPWStr)] get; }\n\n            [return: MarshalAs(UnmanagedType.Interface)]\n            SpellCheckAPI.IEnumSpellingError Check([MarshalAs(UnmanagedType.LPWStr), In] string text);\n\n            [return: MarshalAs(UnmanagedType.Interface)]\n            SpellCheckAPI.IEnumString Suggest([MarshalAs(UnmanagedType.LPWStr), In] string word);\n\n            void Add([MarshalAs(UnmanagedType.LPWStr), In] string word);\n\n            void Ignore([MarshalAs(UnmanagedType.LPWStr), In] string word);\n\n            void AutoCorrect([MarshalAs(UnmanagedType.LPWStr), In] string from, [MarshalAs(UnmanagedType.LPWStr), In] string to);\n\n            byte GetOptionValue([MarshalAs(UnmanagedType.LPWStr), In] string optionId);\n\n            SpellCheckAPI.IEnumString OptionIds { [return: MarshalAs(UnmanagedType.Interface)] get; }\n\n            string Id { [return: MarshalAs(UnmanagedType.LPWStr)] get; }\n\n            string LocalizedName { [return: MarshalAs(UnmanagedType.LPWStr)] get; }\n\n            uint add_SpellCheckerChanged([MarshalAs(UnmanagedType.Interface), In] SpellCheckAPI.ISpellCheckerChangedEventHandler handler);\n\n\n            void remove_SpellCheckerChanged([In] uint eventCookie);\n\n            [return: MarshalAs(UnmanagedType.Interface)]\n            SpellCheckAPI.IOptionDescription GetOptionDescription([MarshalAs(UnmanagedType.LPWStr), In] string optionId);\n\n            [return: MarshalAs(UnmanagedType.Interface)]\n            SpellCheckAPI.IEnumSpellingError ComprehensiveCheck([MarshalAs(UnmanagedType.LPWStr), In] string text);\n        }\n\n        [Guid(\"8E018A9D-2415-4677-BF08-794EA61F94BB\")]\n        [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n        [ComImport]\n        public interface ISpellCheckerFactory\n        {\n            SpellCheckAPI.IEnumString SupportedLanguages { [return: MarshalAs(UnmanagedType.Interface)] get; }\n\n\n            int IsSupported([MarshalAs(UnmanagedType.LPWStr), In] string languageTag);\n\n\n            [return: MarshalAs(UnmanagedType.Interface)]\n            SpellCheckAPI.ISpellChecker CreateSpellChecker([MarshalAs(UnmanagedType.LPWStr), In] string languageTag);\n        }\n\n        [Guid(\"AA176B85-0E12-4844-8E1A-EEF1DA77F586\")]\n        [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n        [ComImport]\n        public interface IUserDictionariesRegistrar\n        {\n            void RegisterUserDictionary([MarshalAs(UnmanagedType.LPWStr), In] string dictionaryPath, [MarshalAs(UnmanagedType.LPWStr), In] string languageTag);\n\n            void UnregisterUserDictionary([MarshalAs(UnmanagedType.LPWStr), In] string dictionaryPath, [MarshalAs(UnmanagedType.LPWStr), In] string languageTag);\n        }\n\n\n\n        [Guid(\"7AB36653-1796-484B-BDFA-E74F1DB7C1DC\")]\n        [ComImport]\n        public class SpellCheckerFactoryClass\n        {\n        }\n    }\n} \n</code></pre>\n\n<p>Тогда метод для проверки правописания можно реализовать так:</p>\n\n<pre><code>public static string SpellCheck(string s)\n{\n    SpellCheckAPI.SpellCheckerFactoryClass factory = null;\n    SpellCheckAPI.ISpellCheckerFactory ifactory = null;\n    SpellCheckAPI.ISpellChecker checker = null;\n    SpellCheckAPI.ISpellingError error = null;\n    SpellCheckAPI.IEnumSpellingError errors = null;\n    SpellCheckAPI.IEnumString suggestions = null;\n    StringBuilder sb = new StringBuilder(s.Length * 10);\n\n    try\n    {\n\n        factory = new SpellCheckAPI.SpellCheckerFactoryClass();\n        ifactory = (SpellCheckAPI.ISpellCheckerFactory)factory;\n\n        //проверим поддержку русского языка\n        int res = ifactory.IsSupported(\"ru-RU\");\n        if (res == 0) { throw new Exception(\"Fatal error: russian language not supported!\"); }\n\n        checker = ifactory.CreateSpellChecker(\"ru-RU\");\n\n        errors = checker.Check(s);\n        while (true)\n        {\n            if (error != null) { Marshal.ReleaseComObject(error); error = null; }\n\n            error = errors.Next();\n            if (error == null) break;\n\n            //получаем слово с ошибкой\n            string word = s.Substring((int)error.StartIndex, (int)error.Length);\n            sb.AppendLine(\"Ошибка в слове: \" + word);\n\n            //получаем рекомендуемое действие\n            switch (error.CorrectiveAction)\n            {\n                case SpellCheckAPI.CORRECTIVE_ACTION.CORRECTIVE_ACTION_DELETE:\n                    sb.AppendLine(\"Рекомендуемое действие: удалить\");\n                    break;\n\n                case SpellCheckAPI.CORRECTIVE_ACTION.CORRECTIVE_ACTION_REPLACE:\n                    sb.AppendLine(\"Рекомендуемое действие: заменить на \" + error.Replacement);\n                    break;\n\n                case SpellCheckAPI.CORRECTIVE_ACTION.CORRECTIVE_ACTION_GET_SUGGESTIONS:\n                    sb.AppendLine(\"Рекомендуемое действие: заменить на одно из следующих слов\");\n\n                    if (suggestions != null) { Marshal.ReleaseComObject(suggestions); suggestions = null; }\n\n                    //получаем список слов, предложенных для замены\n                    suggestions = checker.Suggest(word);\n\n                    sb.Append(\"[ \");\n                    while (true)\n                    {\n                        string suggestion;\n                        uint count = 0;\n                        suggestions.Next(1, out suggestion, out count);\n                        if (count == 1) sb.Append(suggestion + \" \");\n                        else break;\n                    }\n                    sb.Append(\"] \");\n                    sb.AppendLine();\n                    break;\n            }\n            sb.AppendLine();\n\n        }\n\n\n    }\n    finally\n    {\n        if (suggestions != null) { Marshal.ReleaseComObject(suggestions); }\n        if (factory != null) { Marshal.ReleaseComObject(factory); }\n        if (ifactory != null) { Marshal.ReleaseComObject(ifactory); }\n        if (checker != null) { Marshal.ReleaseComObject(checker); }\n        if (error != null) { Marshal.ReleaseComObject(error); }\n        if (errors != null) { Marshal.ReleaseComObject(errors); }\n    }\n\n    return sb.ToString();\n\n}\n</code></pre>\n\n<h1>Windows Vista - 7</h1>\n\n<p>Можно использовать TextBox из WPF, тесты показали, что он отлично работает в не-WPF проекте без необходимости создания цикла обработки сообщений и добавления его в окно. Нужно лишь добавить ссылки на PresentationCore, PresentationFramework, WindowsBase и System.Xaml, а также пометить поток STAThread. Из коробки русский язык не поддерживается, поэтому придется скачать словарь, например <a href=\"https://www.karamasoft.com/UltimateSpell/Dictionary.aspx\" rel=\"nofollow noreferrer\">здесь</a>, и добавить его как нестандартный. Файл словаря желательно перекодировать в UTF-16 LE с BOM (эта кодировка в блокноте обозначена как \"Юникод\"), так как словари в других кодировках похоже обрабатываются некорректно. </p>\n\n<p>Пример:</p>\n\n<pre><code>using System.Windows.Controls;\n\n//...\n\npublic static string SpellCheckWPF(string s)\n{\n    StringBuilder sb = new StringBuilder(s.Length * 10);\n\n    TextBox textbox = new TextBox(); \n    textbox.Text = s;        \n    textbox.Language = System.Windows.Markup.XmlLanguage.GetLanguage(\"en-US\");\n    textbox.SpellCheck.IsEnabled = true;\n\n    //добавим нестандартный словарь из файла\n    textbox.SpellCheck.CustomDictionaries.Add(new Uri(@\"ru-RU.dic\", UriKind.Relative));\n\n    int index = 0;\n    while (true)\n    {\n        //находим ошибку            \n        index = textbox.GetNextSpellingErrorCharacterIndex(index, System.Windows.Documents.LogicalDirection.Forward);\n        if (index &gt; s.Length || index &lt; 0) break;\n\n        var error = textbox.GetSpellingError(index);\n        int len = textbox.GetSpellingErrorLength(index);\n\n        string word = textbox.Text.Substring(index, len);\n\n        sb.AppendFormat(\"Ошибка в слове {0}, рекомендуется заменить на одно из следующих слов: \", word);\n\n        //выводим список предлагаемых замен\n        foreach (string x in error.Suggestions)\n        {\n            sb.Append(x + \"; \");\n        }\n        sb.AppendLine();\n\n        //переход к следующему слову\n        index += len;\n    }\n    return sb.ToString();\n}\n</code></pre>\n\n<p>Поскольку загрузка большого словаря занимает существенное время, нужно создать один TextBox, загрузить в него словарь один раз при запуске приложения и в последующем коде использовать его (а не грузить словарь каждый раз, когда нужно что-то проверить).</p>\n\n<p>Данный код не будет работать в Windows 8.1+ и .NET 4.6.1+, так как в этих версиях WPF также использует вышеописанный стандартный API. Механизм загрузки словарей в связи с этим сильно изменился, и большие словари не поддерживаются. Чтобы все нормально заработало в этом случае, нужно убрать нестандартный словарь и устанавливать в TextBox русский язык, а не английский.</p>\n\n<h1>Источники</h1>\n\n<p><a href=\"https://visualstudiomagazine.com/articles/2013/08/01/using-the-c-spell-checking-api.aspx\" rel=\"nofollow noreferrer\">Using the C++ Spell Checking API</a></p>\n\n<p><a href=\"https://blogs.msdn.microsoft.com/wpf/2015/10/29/wpf-in-net-4-6-1/\" rel=\"nofollow noreferrer\">WPF in .NET 4.6.1</a></p>\n\n<p><a href=\"https://support.microsoft.com/en-us/help/3088234/spelling-checker-isn-t-supported-in-the-net-4-6-1-in-some-conditions\" rel=\"nofollow noreferrer\">Spelling checker isn't supported in the .NET 4.6.1 in some conditions</a></p>\n"}