{"owner":{"reputation":514,"user_id":193306,"user_type":"registered","accept_rate":19,"profile_image":"https://lh3.googleusercontent.com/-_PVhno94Ga0/AAAAAAAAAAI/AAAAAAAAINU/ktc-cgDHWcU/photo.jpg?sz=128","display_name":"Sergej Loos","link":"https://ru.stackoverflow.com/users/193306/sergej-loos"},"is_accepted":true,"score":1,"last_activity_date":1527080748,"last_edit_date":1527080748,"creation_date":1527064412,"answer_id":832133,"question_id":831776,"body":"<p>Натолкнулся на одно решение и оно у меня на Windows 10 с небольшими изменениями работает:\n<a href=\"https://stackoverflow.com/questions/6319568/how-to-bring-a-form-already-shown-up-to-the-very-foreground-and-focus-it/22737820#22737820\">https://stackoverflow.com/questions/6319568/how-to-bring-a-form-already-shown-up-to-the-very-foreground-and-focus-it/22737820#22737820</a></p>\n\n<pre><code>    [DllImport(\"user32.dll\")]\n    private static extern IntPtr GetForegroundWindow();\n\n    [DllImport(\"user32.dll\")]\n    private static extern uint GetWindowThreadProcessId(IntPtr hWnd, IntPtr ProcessId);\n\n    [DllImport(\"user32.dll\")]\n    private static extern bool AttachThreadInput(uint idAttach, uint idAttachTo, bool fAttach);\n\n    public static void xActivateAndBringToFront(this Form form) {\n\n        // activate window\n        var currentForegroundWindow = GetForegroundWindow();\n        var thisWindowThreadId = GetWindowThreadProcessId(form.Handle, IntPtr.Zero);\n        var currentForegroundWindowThreadId = GetWindowThreadProcessId(currentForegroundWindow, IntPtr.Zero);\n        AttachThreadInput(currentForegroundWindowThreadId, thisWindowThreadId, true);\n        form.Activate(); // or: SetForegroundWindow(form.Handle); \n        AttachThreadInput(currentForegroundWindowThreadId, thisWindowThreadId, false);\n\n        // set window to front\n        form.TopMost = true;\n        form.TopMost = false;\n    }\n</code></pre>\n\n<hr>\n\n<p>Дополнение после подсказок от MSDN.WhiteKnight.</p>\n\n<p>MSDN.WhiteKnight указал на то, что применение метода AttachThreadInput может вызывать в некоторых случаях проблемы. Краткий поиск в интернете подтверждает это. </p>\n\n<p>Поэтому, с его же подсказки, я попробовал применить метод AllowSetForegroundWindow. С успехом! А именно, приложение при первом запуске сохраняет ID своего процесса в реестре:</p>\n\n<pre><code>Application.UserAppDataRegistry.SetValue(CORE_PROCESS_ID, Process.GetCurrentProcess().Id);\n</code></pre>\n\n<p>Затем, при повторном запуске приложение перед посылкой сообщения ядру вызывает метод AllowSetForegroundWindow:</p>\n\n<pre><code>int processID = (int)Application.UserAppDataRegistry.GetValue(CORE_PROCESS_ID);\nbool b =  AllowSetForegroundWindow(processID);\n// .. сообщение ядру ..\n// .. выход ..\n</code></pre>\n\n<p>Ядро создает и отображает окно, окно получает фокус ввода как положено. Не нужно даже как-то принудительно подымать окно. По сути form.Activate() достаточно, но даже этот вызов не нужен, если окно создается и отображается в регламентированном порядке через Show(), ShowDialog() или Application.Run(form).</p>\n"}