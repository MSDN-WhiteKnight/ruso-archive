---
title: "UnhandledExceptionHandler на C# вне Visual Studio"
se.owner.user_id: 307194
se.owner.display_name: "Владимир Кравченко"
se.owner.link: "https://ru.stackoverflow.com/users/307194/%d0%92%d0%bb%d0%b0%d0%b4%d0%b8%d0%bc%d0%b8%d1%80-%d0%9a%d1%80%d0%b0%d0%b2%d1%87%d0%b5%d0%bd%d0%ba%d0%be"
se.link: "https://ru.stackoverflow.com/questions/872684/unhandledexceptionhandler-%d0%bd%d0%b0-c-%d0%b2%d0%bd%d0%b5-visual-studio"
se.question_id: 872684
se.post_type: question
se.score: 1
---
<p>Есть проект. Начальство, спустя более 40к строк кода решило добавить логирование. Обычное, уровня Debug, уже добавил, теперь пришёл черед Exception-ов.</p>

<p>Есть вариант прошить всё <code>try {} catch {log.write(message)}</code>, но, по-моему, это не самый оптимальный вариант.</p>

<p>Попытался использовать <code>UnhandledExceptionHandler</code>, однако вне студии (да и банально в запуске без отладки) handler работать не хочет.</p>

<p><strong>Вопрос</strong>: не сталкивался ли кто с подобным и что можете посоветовать в таком случае?
Т.е. задача: перехватывать все (не только фатальные) исключения в релизе.</p>

<p>Приложение WinForms .NET 2.0 (да, всё настолько плохо:)</p>

<p>Добавлено:</p>

<p>Вешаю <code>Handler</code> в <code>Main</code> перед <code>Application.Run(mainForm)</code>:</p>

<pre><code>AppDomain.CurrentDomain.UnhandledException += UnhandledExceptionHandler;
Application.SetUnhandledExceptionMode(UnhandledExceptionMode.CatchException);
</code></pre>

<p>Код обработки</p>

<pre><code>static void UnhandledExceptionHandler(object source, UnhandledExceptionEventArgs e)
        {
            logger.Error("Message: " + ((Exception)e.ExceptionObject).Message);
            var st = new StackTrace(((Exception)e.ExceptionObject), true);
            for (int i = 0; i &lt; st.FrameCount; i++)
            {
                var frame = st.GetFrame(i);
                var method = frame.GetMethod();
                //if (method.DeclaringType.FullName.Contains("AMT"))
                {
                    logger.Error("Source: " + method.DeclaringType.FullName + "." + method.Name);
                    logger.Error("Line: " + frame.GetFileLineNumber());
                }
            }
        }
</code></pre>

<p>Код просто не отрабатывает, как будто его и нет. В самой студии в режиме отладки всё нормально - и брекпоинт можно поставить, и лог пишется. Как только запускаю .exe напрямую - метода как-будто нет.</p>

<p><strong>Обновление</strong></p>

<p>Решение проблемы:</p>

<p>В Main:</p>

<pre><code>AppDomain.CurrentDomain.UnhandledException += UnhandledExceptionHandler;
Application.ThreadException += new ThreadExceptionEventHandler(ThreadExceptionHandler);
</code></pre>

<p>И три метода, два из которых перехватывают исключения и один вспомогательный для вывода инфы для юзера.</p>

<pre><code>static void UnhandledExceptionHandler(object source, UnhandledExceptionEventArgs e)
        {
            logger.Error("Message: " + ((Exception)e.ExceptionObject).Message);
            var st = new StackTrace(((Exception)e.ExceptionObject), true);
            for (int i = 0; i &lt; st.FrameCount; i++)
            {
                var frame = st.GetFrame(i);
                var method = frame.GetMethod();
                if (method.DeclaringType.FullName.Contains("AMT"))
                {
                    logger.Error("Source: " + method.DeclaringType.FullName + "." + method.Name);
                    logger.Error("Line: " + frame.GetFileLineNumber());
                }
            }
        }

        private static void ThreadExceptionHandler(object sender, ThreadExceptionEventArgs e)
        {
            logger.Error("Message: " + e.Exception.Message);
            var st = new StackTrace(e.Exception, true);
            for (int i = 0; i &lt; st.FrameCount; i++)
            {
                var frame = st.GetFrame(i);
                var method = frame.GetMethod();
                if (method.DeclaringType.FullName.Contains("AMT"))
                {
                    logger.Error("Source: " + method.DeclaringType.FullName + "." + method.Name);
                    logger.Error("Line: " + frame.GetFileLineNumber());
                }
            }

            DialogResult result = DialogResult.Cancel;
            try
            {
                result = ShowThreadExceptionDialog("Windows Forms Error", e.Exception);
            }
            catch
            {
                try
                {
                    MessageBox.Show("Fatal Windows Forms Error", "Fatal Windows Forms Error", MessageBoxButtons.AbortRetryIgnore, MessageBoxIcon.Stop);
                }
                finally
                {
                    Application.Exit();
                }
            }
            if (result == DialogResult.Abort)
                Application.Exit();
        }

        private static DialogResult ShowThreadExceptionDialog(string title, Exception e)
        {
            string errorMsg = "An application error occurred. Please contact the adminstrator " +
                "with the following information:\n\n";
            errorMsg = errorMsg + e.Message + "\n\nStack Trace:\n" + e.StackTrace;
            return MessageBox.Show(errorMsg, title, MessageBoxButtons.AbortRetryIgnore, MessageBoxIcon.Stop);
        }
</code></pre>
