{"tags":["c#","аудио","фурье","fft","naudio"],"owner":{"reputation":93,"user_id":269209,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/5d9ec235df110f7ad8a201031a72dce5?s=128&d=identicon&r=PG&f=1","display_name":"Алексей Однорог","link":"https://ru.stackoverflow.com/users/269209/%d0%90%d0%bb%d0%b5%d0%ba%d1%81%d0%b5%d0%b9-%d0%9e%d0%b4%d0%bd%d0%be%d1%80%d0%be%d0%b3"},"is_answered":true,"view_count":931,"answer_count":1,"score":6,"last_activity_date":1567184650,"creation_date":1524559895,"last_edit_date":1567184650,"question_id":818576,"link":"https://ru.stackoverflow.com/questions/818576/%d0%9f%d0%be%d0%bb%d1%83%d1%87%d0%b5%d0%bd%d0%b8%d0%b5-%d1%87%d0%b0%d1%81%d1%82%d0%be%d1%82%d1%8b-%d0%b7%d0%b2%d1%83%d0%ba%d0%b0-%d1%81-%d0%bc%d0%b8%d0%ba%d1%80%d0%be%d1%84%d0%be%d0%bd%d0%b0","title":"Получение частоты звука с микрофона","body":"<p>Есть задача получать частоту звука с микрофона для дальнейших преобразований на C#.\nПодобное уже делал на Python с numpy, но тут как то не клеится...</p>\n\n<pre><code>private void write(byte[] angles, int byte_len)\n{\n    Complex[] _fftBuffer = new Complex[byte_len];\n    var _m = (int)Math.Log(byte_len, 2.0);\n\n    for (var n=0; n &lt; byte_len; n++)\n    {\n        var r = angles[n];\n        var i = 0;\n        _fftBuffer[n].X = (float)(r * FastFourierTransform.HammingWindow(n, byte_len));\n        _fftBuffer[n].Y = i;\n\n    }\n    FastFourierTransform.FFT(true, _m, _fftBuffer);\n    float[] fft_x = new float[_fftBuffer.Length];\n    for (var i=0; i&lt;_fftBuffer.Length; i++)\n    {\n        fft_x[i] = Math.Abs(_fftBuffer[i].X);\n    }\n    int i_peak = fft_x.ToList().IndexOf(fft_x.Max());\n    for (var i = 0; i &lt; _fftBuffer.Length; i++)\n    {\n        fft_x[i] = (float)Math.Log(Math.Abs(_fftBuffer[i].X));\n    }\n    ///var i_peak = fft_x.Max();\n    var i_interp = parabolic(fft_x, i_peak);\n\n    float freq = byte_len * i_interp / angles.Length;\n    Console.WriteLine(\"Debug stop\");\n\n    ///this.port.Write(this.first_command, 0, 8);\n    ///this.port.Write(this.get_comand(0.0f, 0.0f), 0, 32);\n\n\n}\nprivate float parabolic(float[] f, int peak)\n{\n    var xv = 0.5f * (f[peak-1] - f[peak+1])/(f[peak-1]-2*f[peak] + f[peak+1]) + peak;\n\n    return xv;\n}\n</code></pre>\n\n<p>Это что на С# сделал. Сделано так, ибо так же было на Python.\nВ конечном итоге работает, но неправильно - частота получается одна и та же (+- пара герц), но по идее там должны быть абсолютно другие частоты - передаем данные с помощью звука.</p>\n\n<p>Помогите разобраться, что в коде может быть не так?</p>\n\n<p><strong>UPD</strong></p>\n\n<p>Вот что получилось в итоге. Спасибо товарищу @MSDN.WhiteKnight - натолкнул на правильные мысли.\nПлюс использовался проект \n<a href=\"http://www.cyberforum.ru/csharp-net/thread923739.html\" rel=\"nofollow noreferrer\">вот отсюда</a></p>\n\n<p>выкладываю только код, который несет смысл по вытаскиванию частот звука с микрофона(МОНО). Можно переделать на стерео - не особо сложно будет</p>\n\n<pre><code>public partial class MainWindow : Window\n{\n    static double Fs = 48000; // Частота дискретизации !В данной программе ТОЛЬКО целые числа\n    static double T = 1.0 / Fs; // Шаг дискретизации\n    static int N; //Длина сигнала (точек)\n    static double Fn = Fs / 2;// Частота Найквиста\n    WaveIn waveIn;\n\n    public MainWindow()\n    {\n        InitializeComponent();\n    }\n\n    void waveIn_DataAvailable(object sender, WaveInEventArgs e)\n    {\n\n        //данные из буфера распределяем в массив чтобы в нем они были в формате ?PCM?\n        byte[] buffer = e.Buffer;\n        N = buffer.Length;\n        int bytesRecorded = e.BytesRecorded;\n        Complex[] sig = new Complex[bytesRecorded / 2];\n        for (int i = 0, j = 0; i &lt; e.BytesRecorded; i += 2, j++)\n        {\n            short sample = (short)((buffer[i + 1] &lt;&lt; 8) | buffer[i + 0]);\n            sig[j] = sample / 32768f;\n        }\n\n        Fourier.Forward(sig, FourierOptions.Matlab);\n        // обнуляем спектр на небольших частотах (там постоянная составляющая и вообще много помех)\n        for (int i = 0; i &lt; 35 * sig.Length / Fn; i++)\n        {\n            sig[i] = 0;\n        }\n\n        write(sig);\n\n    }\n    //Окончание записи\n    private void waveIn_RecordingStopped(object sender, EventArgs e)\n    {\n        waveIn.Dispose();\n        waveIn = null;\n    }\n\n    private void start_button_Click(object sender, RoutedEventArgs e)\n    {\n        this.waveIn = new WaveIn();\n        this.waveIn.DeviceNumber = 0;\n        this.waveIn.DataAvailable += this.waveIn_DataAvailable;\n        this.waveIn.RecordingStopped += this.waveIn_RecordingStopped;\n        this.waveIn.WaveFormat = new WaveFormat((int)Fs, 1);\n        this.waveIn.StartRecording();\n        Start_button.IsEnabled = false;\n        Stop_button.IsEnabled = true;\n        this.log_box(\"старт записи\");\n    }\n\n\n    private void stop_Button_Click(object sender, RoutedEventArgs e)\n    {\n        this.stop_recording();\n    }\n\n    private void stop_recording()\n    {\n        this.waveIn.StopRecording();\n        Start_button.IsEnabled = true;\n        Stop_button.IsEnabled = false;\n        this.log_box(\"конец записи\");\n    }\n\n\n    private void log_box(string message)\n    {\n        Log_Box.AppendText(\"\\n\" + message);\n        Log_Box.ScrollToEnd();\n    }\n\n    private void write(Complex[] signal)\n    {\n        PointPairList list1 = new PointPairList();\n        int max_index = 0;\n        double freq = 0;\n        double K = signal.Length / 2;\n        for (int i = 0; i &lt; K; i++)\n        {\n            list1.Add(i * Fn / K, Complex.Abs(signal[i]) / N * 2);\n        }\n\n        foreach (ZedGraph.PointPair i in list1)\n        {\n            if (i.Y &gt; list1[max_index].Y)\n            {\n                max_index = list1.IndexOf(i);\n            }\n        }\n        freq = list1[max_index].X;\n\n        string s = freq.ToString();\n        log_box(s);\n\n\n    }\n\n}\n</code></pre>\n\n<p>что использовалось...\nNAudio - для получения потока звука с микрофона</p>\n\n<p>MathNET - Фурье</p>\n\n<p>ZedGraph - как переходник для работы с сигналом после преобразования Фурье - его можно убрать, но в моем случае был удобен.</p>\n"}