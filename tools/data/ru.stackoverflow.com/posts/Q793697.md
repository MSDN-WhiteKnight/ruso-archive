---
title: "WASAPI Запись звука"
se.owner.user_id: 238013
se.owner.display_name: "D .Stark"
se.owner.link: "https://ru.stackoverflow.com/users/238013/d-stark"
se.link: "https://ru.stackoverflow.com/questions/793697/wasapi-%d0%97%d0%b0%d0%bf%d0%b8%d1%81%d1%8c-%d0%b7%d0%b2%d1%83%d0%ba%d0%b0"
se.question_id: 793697
se.post_type: question
se.score: 1
---
<p>В результате записи получается полная ерунда. В чём ошибка?</p>

<pre><code>#include "stdafx.h"
#include "iostream"
#include "windows.h"
#include "mmdeviceapi.h"
#include "audioclient.h"

#pragma comment(lib, "ole32.lib")

using namespace System;
using namespace System::Collections::Generic;

#define REFTIMES_PER_SEC  10000000
#define REFTIMES_PER_MILLISEC  10000

#define EXIT_ON_ERROR(hres)     if (FAILED(hres)) { goto Exit; }
#define SAFE_RELEASE(punk)      if ((punk) != NULL) { (punk)-&gt;Release(); (punk) = NULL; }

const CLSID CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);
const IID IID_IMMDeviceEnumerator = __uuidof(IMMDeviceEnumerator);
const IID IID_IAudioClient = __uuidof(IAudioClient);
const IID IID_IAudioCaptureClient = __uuidof(IAudioCaptureClient);

List&lt;BYTE&gt;^ RecordAudioStream() {

    HRESULT hr;

    REFERENCE_TIME hnsRequestedDuration = REFTIMES_PER_SEC;
    REFERENCE_TIME hnsActualDuration;
    UINT32 bufferFrameCount;
    UINT32 numFramesAvailable;
    UINT32 packetLength = 0;
    BYTE *pData;
    List&lt;BYTE&gt;^ buf = gcnew List&lt;BYTE&gt;();
    DWORD flags;
    WAVEFORMATEX *pwfx = NULL;

    IMMDeviceEnumerator *pEnumerator = NULL;
    IMMDevice *pDevice = NULL;
    IAudioClient *pAudioClient = NULL;
    IAudioCaptureClient *pCaptureClient = NULL;

    // Get default audio device IMMDevice object.

    hr = CoCreateInstance(CLSID_MMDeviceEnumerator,
        NULL, CLSCTX_ALL,
        IID_IMMDeviceEnumerator,
        (void**)&amp;pEnumerator);
    EXIT_ON_ERROR(hr);

    hr = pEnumerator-&gt;GetDefaultAudioEndpoint(eCapture, eConsole, &amp;pDevice);
    EXIT_ON_ERROR(hr);

    hr = pDevice-&gt;Activate(IID_IAudioClient,
        CLSCTX_ALL, NULL,
        (void**)&amp;pAudioClient);
    EXIT_ON_ERROR(hr);

    hr = pAudioClient-&gt;GetMixFormat(&amp;pwfx);
    EXIT_ON_ERROR(hr);

    // Create audio client object.

    hr = pAudioClient-&gt;Initialize(AUDCLNT_SHAREMODE_SHARED, 0, hnsRequestedDuration, 0, pwfx, NULL);
    EXIT_ON_ERROR(hr);

    // Get the size of the allocated buffer.
    hr = pAudioClient-&gt;GetBufferSize(&amp;bufferFrameCount);
    EXIT_ON_ERROR(hr);

    hr = pAudioClient-&gt;GetService(IID_IAudioCaptureClient, (void**)&amp;pCaptureClient);
    EXIT_ON_ERROR(hr);

    Console::WriteLine("Used format:\nChannels: {0}\nFreq: {1}\nSample bits: {2}", pwfx-&gt;nChannels, pwfx-&gt;nSamplesPerSec, pwfx-&gt;wBitsPerSample);

    // Calculate the actual duration of the allocated buffer.
    hnsActualDuration = (double)REFTIMES_PER_SEC * bufferFrameCount / pwfx-&gt;nSamplesPerSec;

    hr = pAudioClient-&gt;Start(); // Start recording.
    EXIT_ON_ERROR(hr);

    // 4 sec recording.
    System::Diagnostics::Stopwatch^ s = gcnew System::Diagnostics::Stopwatch();
    s-&gt;Start();

    // Each loop fills about half of the shared buffer.
    while (s-&gt;ElapsedMilliseconds &lt; 4000)
    {
        // Sleep for half the buffer duration.
        Sleep(hnsActualDuration / REFTIMES_PER_MILLISEC / 2);

        hr = pCaptureClient-&gt;GetNextPacketSize(&amp;packetLength);
        EXIT_ON_ERROR(hr);

        while (packetLength != 0)
        {
            // Get the available data in the shared buffer.
            hr = pCaptureClient-&gt;GetBuffer(&amp;pData, &amp;numFramesAvailable, &amp;flags, NULL, NULL);
            EXIT_ON_ERROR(hr);

            if (flags &amp; AUDCLNT_BUFFERFLAGS_SILENT)
            {
                pData = NULL; // Tell CopyData to write silence.
            }
            else
            {
                // Copy the available capture data.
                for (int i = 0; i &lt; packetLength; i++)
                    buf-&gt;Add(*(pData + i));
            }

            hr = pCaptureClient-&gt;ReleaseBuffer(numFramesAvailable);
            EXIT_ON_ERROR(hr);

            hr = pCaptureClient-&gt;GetNextPacketSize(&amp;packetLength);
            EXIT_ON_ERROR(hr);
        }
    }

    hr = pAudioClient-&gt;Stop(); // Stop recording.

Exit:
    CoTaskMemFree(pwfx);
    SAFE_RELEASE(pEnumerator);
    SAFE_RELEASE(pDevice);
    SAFE_RELEASE(pAudioClient);
    SAFE_RELEASE(pCaptureClient);
    SAFE_RELEASE(pRenderClient);

    return buf;
}
</code></pre>

<p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd370800(v=vs.85).aspx" rel="nofollow noreferrer">Capturing a Stream (Windows)</a></p>

<hr>

<p>Тестовое воспроизведение в NAudio:</p>

<pre><code>WaveOut^ waveOut = gcnew WaveOut();
waveOut-&gt;DeviceNumber = 0;
waveOut-&gt;Init(gcnew RawSourceWaveStream(buf-&gt;ToArray(), 0, buf-&gt;Count, gcnew WaveFormat(44100, 32, 2)));
System::Threading::ThreadStart^ thStart = gcnew System::Threading::ThreadStart(waveOut, &amp;WaveOut::Play);
(gcnew System::Threading::Thread(thStart))-&gt;Start();
</code></pre>
