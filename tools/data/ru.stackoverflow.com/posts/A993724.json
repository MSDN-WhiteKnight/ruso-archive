{"owner":{"reputation":111,"user_id":339485,"user_type":"registered","profile_image":"https://i.stack.imgur.com/prFfH.jpg?s=128&g=1","display_name":"MrFresnel","link":"https://ru.stackoverflow.com/users/339485/mrfresnel"},"is_accepted":false,"score":0,"last_activity_date":1560788172,"creation_date":1560788172,"answer_id":993724,"question_id":969675,"body":"<p>Ответ немного припоздал, но всё-же. Важно понимать, что тип переменной и тип её значения - не одно и то же. К примеру:</p>\n\n<pre><code>using System;\nusing System.Collections.Generic;\n\nnamespace CSrharpApplicationTest\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            IEnumerable&lt;int&gt; x = new List&lt;int&gt;();\n            Console.WriteLine(x.GetType());\n        }\n    }\n}\n\n</code></pre>\n\n<p>Тип переменной - <code>IEnumerable&lt;int&gt;</code>, тип её значения - <code>List&lt;int&gt;</code>. </p>\n\n<p>В обоих случаях в Ваших примерах тип <code>t1</code> и <code>t2</code> - <code>List&lt;int&gt;</code>, благодаря вызову метода-расширения <code>ToList()</code>, реализация которого выглядит следующим образом:</p>\n\n<pre><code>        [__DynamicallyInvokable]\n        public static List&lt;TSource&gt; ToList&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source)\n        {\n            if (source == null)\n            {\n                throw Error.ArgumentNull(\"source\");\n            }\n            return new List&lt;TSource&gt;(source);\n        }\n</code></pre>\n\n<p>, где конструктор <code>List&lt;TSource&gt;</code> описывается так:</p>\n\n<pre><code>        [__DynamicallyInvokable]\n        public List(IEnumerable&lt;T&gt; collection)\n        {\n            if (collection == null)\n            {\n                ThrowHelper.ThrowArgumentNullException(ExceptionArgument.collection);\n            }\n            ICollection&lt;T&gt; collection2 = collection as ICollection&lt;T&gt;;\n            if (collection2 != null)\n            {\n                int count = collection2.Count;\n                if (count == 0)\n                {\n                    _items = _emptyArray;\n                }\n                else\n                {\n                    _items = new T[count];\n                    collection2.CopyTo(_items, 0);\n                    _size = count;\n                }\n            }\n            else\n            {\n                _size = 0;\n                _items = _emptyArray;\n                foreach (T item in collection)\n                {\n                    Add(item);\n                }\n            }\n        }\n</code></pre>\n\n<blockquote>\n  <p>Разнится в том, что при добавлении элементов во втором случае надо явно привести к типу List, так?</p>\n</blockquote>\n\n<p>Да, во втором случае Вы указываете компилятору, что тип <code>listValues2</code> - любой тип, реализующий <code>IEnumerable&lt;int&gt;</code>. В интерфейсе <code>IEnumerable&lt;out T&gt;</code>, нет методов добавления/изменения/удаления элементов, ведь он описывает минимальный функционал для возможности <strong>перечисления</strong> по коллекции, соответственно компилятор не может дать гарантий, что то, что лежит внутри <code>listValues2</code> - коллекция, с методом <code>Add</code>. Поэтому требуется явное приведение типа к <code>List&lt;int&gt;</code>.</p>\n"}