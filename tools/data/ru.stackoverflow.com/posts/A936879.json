{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":true,"score":1,"last_activity_date":1548487981,"creation_date":1548487981,"answer_id":936879,"question_id":936783,"body":"<p>Если конфигурация именно такая, как вы описали: неуправляемые модули для разных архитектур имеют одинаковое имя и расположены в разных подкаталогах каталога с программой, можно использовать функцию <a href=\"https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-setdlldirectoryw\" rel=\"nofollow noreferrer\">SetDllDirectory</a>. При запуске приложения вызовите SetDllDirectory, передав каталог x86 или x64 в зависимости от текущей архитектуры. Объявление P/Invoke на каждую функцию оставить одно, содержащее только имя dll, без пути к подкаталогу. При запуске программа будет искать dll сначала в каталоге программы, затем в каталоге SetDllDirectory, и далее в системных каталогах, поэтому, чтобы все заработало, в каталоге программы dll с таким же именем быть не должно.</p>\n\n<pre><code>[DllImport(\"kernel32.dll\")]\n[return: MarshalAs(UnmanagedType.Bool)]\nstatic extern bool SetDllDirectory(string lpPathName);\n\nstatic void InitializeDll(){\n\n    string path = new Uri(Assembly.GetExecutingAssembly().CodeBase).LocalPath;\n    string dir = Path.GetDirectoryName(path);\n    string subdir;\n\n    if(Environment.Is64BitProcess) subdir = Path.Combine(dir,\"x64\");\n    else subdir = Path.Combine(dir,\"x86\");\n\n    SetDllDirectory(subdir);\n}\n</code></pre>\n\n<p>Но, более логичное и независимое от WinAPI решение - иметь два объявления P/Invoke на каждую функцию и метод, вызывающий нужный в зависимости от архитектуры. </p>\n"}