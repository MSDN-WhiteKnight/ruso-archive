{"owner":{"reputation":121977,"user_id":195342,"user_type":"registered","accept_rate":81,"profile_image":"https://i.stack.imgur.com/8hsxs.jpg?s=128&g=1","display_name":"Harry","link":"https://ru.stackoverflow.com/users/195342/harry"},"is_accepted":true,"score":10,"last_activity_date":1460871390,"creation_date":1460871390,"answer_id":513775,"question_id":513736,"body":"<p>Официально в стандарте языка записано, если я не путаю, что переполнение знаковых целочисленных типов зависит от реализации (может генерироваться исключение, может игнорироваться), а беззнаковых игнорируется - значение приводится в представимый диапазон.</p>\n\n<p>Т.е. получается примерно так - сам C/C++ <strong>встроенных</strong> <strong>переносимых</strong> средств обнаружения переполнения не имеет.</p>\n\n<p>Но всегда можно использовать дополнительные методы, которые позволят по данным операндам выяснить, будет ли переполнение при выполнении операции. Масса таких вещей описана в книге Г. Уоррена <em>Алгоритмические трюки для программистов</em>.</p>\n\n<p>Ну и как иллюстрация, насколько легко пропустить это переполнение - у Страуструпа в <em>Программирование. Принципы и практика...</em> есть одна программка, в которой вычислялся ряд для e<sup>x</sup>, что ли - и она у него в разнос шла. Он честно написал, что раньше, мол, я думал, что это связано с потерей точности в <code>double</code>, и вроде даже так и написал в первом издании книги, а потом ко второму изданию дошло, что на самом деле это переполнение целочисленных значений при вычислении факториала. Если уж даже Страуструп... :)</p>\n"}