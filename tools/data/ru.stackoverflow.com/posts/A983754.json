{"owner":{"reputation":15321,"user_id":198316,"user_type":"registered","accept_rate":100,"profile_image":"https://i.stack.imgur.com/s4KpW.png?s=128&g=1","display_name":"rdorn","link":"https://ru.stackoverflow.com/users/198316/rdorn"},"is_accepted":true,"score":3,"last_activity_date":1558402454,"creation_date":1558402454,"answer_id":983754,"question_id":983720,"body":"<p>Согласно спецификации языка (пункт 3.6), в сигнатуру не входят ни тип возвращаемого значения, ни тип-параметр обобщенного метода, ни какие-либо ограничения на тип-параметр. </p>\n\n<p>Таким образом, с точки зрения компилятора, ваши методы неразличимы, т.к. имеют одинаковые имена и наборы входных параметров. В вашем примере входных параметров нет, следовательно будут учитываться только имена. <strong>Обобщенные типы C# похожи, но не эквивалентны шаблонам C++.</strong> </p>\n\n<p>Вам необходимо</p>\n\n<ul>\n<li><p>либо иметь два метода с различными сигнатурами (в\nприведенном примере - различными именами), если они являются членами\nодного класса/структуры, </p></li>\n<li><p>либо разнести их в разные классы/структуры с общим предком или\nинтерфейсом,</p></li>\n<li><p>либо определить два интерфейса с данной сигнатурой метода и\nиспользовать явную реализацию интерфейсов в классе/структуре,</p></li>\n<li><p>либо воспользоваться одним из решений по приведенной вами ссылке.</p></li>\n</ul>\n"}