---
title: "Answer 876456"
se.owner.user_id: 10105
se.owner.display_name: "VladD"
se.owner.link: "https://ru.stackoverflow.com/users/10105/vladd"
se.answer_id: 876456
se.question_id: 875165
se.post_type: answer
se.score: 16
se.is_accepted: True
---
<p>Здесь упоминалось решение с Roslyn API, его тоже несложно сделать.</p>

<p>Для начала, создадим анализатор, как показано в <a href="https://ru.stackoverflow.com/a/756891/10105">этом ответе</a>. Мы не можем придумать разумный code fix, поэтому у нас будет лишь анализ и подсвечивание красной волнистой линией.</p>

<p>Код нашего анализатора такой:</p>

<pre><code>using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace OverloadAnalyzer
{
    [DiagnosticAnalyzer(LanguageNames.CSharp)]
    public class OverloadAnalyzerAnalyzer : DiagnosticAnalyzer
    {
        public const string DiagnosticId = "OverloadAnalyzer";

        private static readonly string Title = "MessageBox.Show only with owner";
        private static readonly string MessageFormat = "Use overload with owner";
        private static readonly string Description =
            "You must always specify an owner for MessageBox.Show";
        private const string Category = "Framework usage";

        // соберём описание нашего правила
        private static DiagnosticDescriptor Rule = new DiagnosticDescriptor(
            DiagnosticId, Title, MessageFormat, Category,
            DiagnosticSeverity.Error, // укажен, что это ошибка, а не предупреждение
            isEnabledByDefault: true, description: Description);

        // список диагностик, которые мы выдаём
        public override ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics =&gt;
            ImmutableArray.Create(Rule);

        // при инициализации подпишемся на анализ всех команд вызова функции
        public override void Initialize(AnalysisContext context)
        {
            context.RegisterSyntaxNodeAction(AnalyzeSymbol,
                                             SyntaxKind.InvocationExpression);
        }

        // сам анализатор
        private static void AnalyzeSymbol(SyntaxNodeAnalysisContext context)
        {
            // получаем синтаксический узел, приводим его к типу «вызов функции»
            var invocationNode = (InvocationExpressionSyntax)context.Node;

            // мелкая эвристика для ускорения: если среди имён в выражении нет Show,
            // дальнейший дорогой семантический анализ не имеет смысла
            if (!invocationNode.DescendantNodes()
                               .OfType&lt;IdentifierNameSyntax&gt;()
                               .Any(n =&gt; n.Identifier.ValueText == "Show"))
                return;

            // получаем символ у семантической модели
            var symInfo = context.SemanticModel.GetSymbolInfo(invocationNode);
            var methodSymbol = (IMethodSymbol)symInfo.Symbol;
            // если его нет (например, у нас некомпилирующийся код), отваливаем
            if (methodSymbol == null)
                return;

            // проверяем, что это действительно вызов MessageBox.Show
            if (methodSymbol.ContainingAssembly.Name != "System.Windows.Forms")
                return;
            if (methodSymbol.ContainingType.ToDisplayString() !=
                    "System.Windows.Forms.MessageBox")
                return;

            // если в списке параметров есть параметр с типом IWin32Window, всё хорошо
            if (methodSymbol.Parameters.Any(p =&gt; p.Type.Name == "IWin32Window"))
                return;

            // иначе говорим юзеру «атата!»
            var diagnostic = Diagnostic.Create(Rule, invocationNode.GetLocation());
            context.ReportDiagnostic(diagnostic);
        }
    }
}
</code></pre>

<p>Получаем вот такое поведение:</p>

<p><a href="https://i.stack.imgur.com/LtMNL.gif" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/LtMNL.gif" alt="а я Roslyn ещё больше ку!"></a></p>

<p>Если вы хотите ещё и проверять код во время построения (а то вдруг программист отключит анализатор или не использует Visual Studio?), вам нужно будет написать ещё и анализатор командной строки, аналогично тому, как описано <a href="https://ru.stackoverflow.com/a/810044/10105">здесь</a>, и запускать его при построении на build-сервере (или в post-build step).</p>

<p>У меня получился вот такой анализатор командной строки:</p>

<pre><code>using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

using Microsoft.Build.Locator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Symbols;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.MSBuild;

namespace CommandLineOverloadAnalyzer
{
    class Program
    {
        static void Usage()
        {
            Console.WriteLine("Usage: CommandLineOverloadAnalyzer.exe SolutionPath" +
                              " MSBuildPath [\"batch\"]");
            Console.WriteLine("if batch specified, no extra output is done");
            Console.WriteLine("if no batch specified, MSBuildPath may be omitted" +
                              " and will be asked for if needed");
        }

        static async Task&lt;int&gt; Main(string[] args)
        {
            if ((args.Length &lt; 1 || args.Length &gt; 3) ||
                (args.Length == 3 &amp;&amp; args[2] != "batch"))
            {
                Usage();
                return 1;
            }
            var solutionPath = args[0];
            var msBuildPath = (args.Length &gt; 1) ? args[1] : null;
            bool batchMode = args.Length == 3;

            // найдём версию MSBuild
            var visualStudioInstances =
                MSBuildLocator.QueryVisualStudioInstances().ToArray();
            var instance =
                // указан путь, выбираем его
                (msBuildPath != null) ? visualStudioInstances.SingleOrDefault(
                                                   i =&gt; i.MSBuildPath == msBuildPath) :
                // только одна студия, выбираем её
                visualStudioInstances.Length == 1 ? visualStudioInstances[0] :
                // в пакетном режиме? падаем
                batchMode ? null :
                // спрашиваем у юзера
                SelectVisualStudioInstance(visualStudioInstances);
            if (instance == null)
            {
                Console.WriteLine("Cannot determine MSBuild path");
                return 1;
            }

            void Out(string s)
            {
                if (!batchMode)
                    Console.WriteLine(s);
            }

            Out($"Using MSBuild at '{instance.MSBuildPath}' to load projects.");

            // Экземпляр MSBuildLocator должен быть зарегистрирован
            // перед MSBuildWorkspace.Create(), иначе MEF-композиция не сработает
            MSBuildLocator.RegisterInstance(instance);

            bool hadProblems = false;
            using (var workspace = MSBuildWorkspace.Create())
            {
                // Напечатаем сообщение при приходе WorkspaceFailed, чтобы
                // помочь с диагностикой проблем загрузки проектов
                workspace.WorkspaceFailed += (o, e) =&gt; Out(e.Diagnostic.Message);

                Out($"Loading solution '{solutionPath}'");

                // печатаем прогресс при интерактивной загрузке
                var solution = await workspace.OpenSolutionAsync(solutionPath,
                    batchMode ? null : new ConsoleProgressReporter());
                Out($"Finished loading solution '{solutionPath}'");

                foreach (var project in solution.Projects)
                {
                    Out($"Processing project {project.Name}");
                    var compilation = await project.GetCompilationAsync();

                    // для каждого файла в проекте отдельное синтаксическое дерево
                    foreach (var syntaxTree in compilation.SyntaxTrees)
                    {
                        var root = await syntaxTree.GetRootAsync();
                        // создаём семантический анализатор
                        var model = compilation.GetSemanticModel(syntaxTree);
                        // получаем все типы переменных
                        foreach (var invocationNode in root.DescendantNodes()
                                             .OfType&lt;InvocationExpressionSyntax&gt;())
                        {
                            if (!invocationNode.DescendantNodes()
                                               .OfType&lt;IdentifierNameSyntax&gt;()
                                               .Any(n =&gt; n.Identifier.ValueText == "Show"))
                                continue;

                            var symInfo = model.GetSymbolInfo(invocationNode);
                            var methodSymbol = (IMethodSymbol)symInfo.Symbol;
                            if (methodSymbol == null)
                                continue;
                            if (methodSymbol.ContainingAssembly.Name !=
                                    "System.Windows.Forms")
                                continue;
                            if (methodSymbol.ContainingType.ToDisplayString() !=
                                    "System.Windows.Forms.MessageBox")
                                continue;

                            if (methodSymbol.Parameters.Any(p =&gt; p.Type.Name ==
                                    "IWin32Window"))
                                continue;

                            var location = invocationNode.GetLocation().GetLineSpan();
                            Console.WriteLine(
                                $"MessageBox.Show usage is wrong, location = {location}");
                            hadProblems = true;
                        }
                    }
                }
            }

            return hadProblems ? 1 : 0;
        }

        private static VisualStudioInstance SelectVisualStudioInstance(
            VisualStudioInstance[] visualStudioInstances)
        {
            Console.WriteLine("Multiple installs of MSBuild detected, please select one:");
            for (int i = 0; i &lt; visualStudioInstances.Length; i++)
            {
                Console.WriteLine($"Instance {i + 1}");
                Console.WriteLine($"    Name: {visualStudioInstances[i].Name}");
                Console.WriteLine($"    Version: {visualStudioInstances[i].Version}");
                Console.WriteLine(
                    $"    MSBuild Path: {visualStudioInstances[i].MSBuildPath}");
            }

            while (true)
            {
                var userResponse = Console.ReadLine();
                if (int.TryParse(userResponse, out int instanceNumber) &amp;&amp;
                    instanceNumber &gt; 0 &amp;&amp;
                    instanceNumber &lt;= visualStudioInstances.Length)
                {
                    return visualStudioInstances[instanceNumber - 1];
                }
                Console.WriteLine("Input not accepted, try again.");
            }
        }

        private class ConsoleProgressReporter : IProgress&lt;ProjectLoadProgress&gt;
        {
            public void Report(ProjectLoadProgress loadProgress)
            {
                var projectDisplay = Path.GetFileName(loadProgress.FilePath);
                if (loadProgress.TargetFramework != null)
                {
                    projectDisplay += $" ({loadProgress.TargetFramework})";
                }

                Console.WriteLine(
                    $"{loadProgress.Operation,-15}" +
                    $" {loadProgress.ElapsedTime,-15:m\\:ss\\.fffffff}" +
                    $" {projectDisplay}");
            }
        }

        private class SilentProgressReporter : IProgress&lt;ProjectLoadProgress&gt;
        {
            public void Report(ProjectLoadProgress loadProgress) { }
        }
    }
}
</code></pre>

<p>В Post-Build step укажите просто</p>

<pre><code>"&lt;путь к анализатору&gt;\CommandLineOverloadAnalyzer.exe" "$(SolutionPath)" "$(MSBuildBinPath)" batch
</code></pre>

<p>У меня при пробном пробеге вывело:</p>

<blockquote>
  <p>MessageBox.Show usage is wrong, location = &lt;полный путь>\RoslynTest\SampleApp\Program.cs: (13,12)-(13,46)</p>
</blockquote>
