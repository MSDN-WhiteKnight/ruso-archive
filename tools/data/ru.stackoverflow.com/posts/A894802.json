{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":2,"last_activity_date":1539861072,"creation_date":1539861072,"answer_id":894802,"question_id":894736,"body":"<p>Рисование в DC чужого окна определенно \"работает\". Другое дело, что:</p>\n\n<ul>\n<li><p>Нарисованное таким образом изображение затрется при первой обработке WM_PAINT в целевом окне (его понадобится постоянно перерисовывать).</p></li>\n<li><p>Если вам нужно рисовать рамку вокруг какого-то окна, вам нужен DC не этого окна, а его родительского окна (или рабочего стола, если это окно верхнего уровня). Ведь на DC окна можно рисовать только внутри этого окна, а рамка нужна снаружи.</p></li>\n</ul>\n\n<p>Подробнее см. в похожем вопросе: <a href=\"https://ru.stackoverflow.com/questions/661585/%D0%A0%D0%B8%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BD%D0%B0-%D0%BE%D0%BA%D0%BD%D0%B5-%D0%B4%D1%80%D1%83%D0%B3%D0%BE%D0%B3%D0%BE-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-winapi/661636#661636\">Рисование на окне другого приложения с помощью WinAPI</a></p>\n\n<hr>\n\n<p>Что касается layered window, вот так у меня работает:</p>\n\n<pre><code>LRESULT CALLBACK LayerWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\n{\n    switch (msg)\n    {\n        case WM_PAINT:\n        {\n            HPEN framePen = ::CreatePen(PS_SOLID, 5, RGB(255, 0, 0));\n            RECT rect = {};\n            PAINTSTRUCT ps;\n            ::GetClientRect(hwnd, &amp;rect);\n            HDC hdc = ::BeginPaint(hwnd, &amp;ps);\n            ::SelectObject(hdc, framePen);\n            ::Rectangle(hdc, rect.left, rect.top, rect.right, rect.bottom);\n            ::EndPaint(hwnd, &amp;ps);\n        }\n        break;\n        case WM_CLOSE:\n            DestroyWindow(hwnd);\n            break;\n        case WM_DESTROY:\n            PostQuitMessage(0);\n            break;\n        default:\n            return DefWindowProc(hwnd, msg, wParam, lParam);\n    }\n    return 0;\n}\n\nvoid CreateLayer(){\n    HWND handle = FindWindow(L\"ConsoleWindowClass\", L\"C:\\\\WINDOWS\\\\system32\\\\cmd.exe\");\n\n    SetForegroundWindow(handle);\n\n    RECT rect = {};\n    ::GetWindowRect(handle, &amp;rect);\n\n    WNDCLASSEX wx = {};\n    wx.cbSize = sizeof(WNDCLASSEX);\n    wx.lpfnWndProc = LayerWndProc;\n    wx.lpszClassName = L\"TestBorderWindow\";\n    wx.hCursor = ::LoadCursor(NULL, IDC_ARROW);\n    wx.hbrBackground = (HBRUSH)GetStockObject(LTGRAY_BRUSH);\n\n    ::RegisterClassEx(&amp;wx);\n\n    HWND hWnd = CreateWindowEx(WS_EX_LAYERED,\n    L\"TestBorderWindow\",\n    L\"Demo\",\n    WS_POPUP,\n    rect.left, rect.top,\n    rect.right - rect.left, rect.bottom - rect.top,\n    NULL,\n    NULL,\n    (HINSTANCE)GetModuleHandle(NULL),\n    NULL);\n\n    ::GetWindowRect(handle, &amp;rect);\n    SetLayeredWindowAttributes(hWnd, RGB(255,255,255), 0, LWA_COLORKEY);\n    ::SetWindowPos(handle, hWnd, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,\n    SWP_SHOWWINDOW);\n    ShowWindow(hWnd,SW_SHOW);\n}\n\nint APIENTRY wWinMain(_In_ HINSTANCE hInstance,\n                     _In_opt_ HINSTANCE hPrevInstance,\n                     _In_ LPWSTR    lpCmdLine,\n                     _In_ int       nCmdShow)\n{\n    UNREFERENCED_PARAMETER(hPrevInstance);\n    UNREFERENCED_PARAMETER(lpCmdLine);\n\n    MSG msg;    \n\n    CreateLayer();\n\n    // Main message loop:\n    while (GetMessage(&amp;msg, NULL, 0, 0))\n    {       \n            TranslateMessage(&amp;msg);\n            DispatchMessage(&amp;msg);      \n    }\n\n    return (int) msg.wParam;\n}\n</code></pre>\n"}