{"owner":{"reputation":4994,"user_id":206435,"user_type":"registered","accept_rate":78,"profile_image":"https://www.gravatar.com/avatar/aff8ab0e5f74d01facde887535318d53?s=128&d=identicon&r=PG","display_name":"ヒミコ","link":"https://ru.stackoverflow.com/users/206435/%e3%83%92%e3%83%9f%e3%82%b3"},"is_accepted":true,"score":0,"last_activity_date":1543421236,"creation_date":1543421236,"answer_id":912842,"question_id":911112,"body":"<p>Путем некоторых манипуляций удалось выяснить, в обязательном порядке стоит соблюдать следующие правила:</p>\n\n<ol>\n<li><p>Наследуемый объект должен переопределять декларацию интерфейса от которого наследуется, перед методами текущего метода, т.е. до их объявлений. (Спасибо за подсказку <a href=\"https://ru.stackoverflow.com/users/240512/msdn-whiteknight\">@MSDN.WhiteKnight</a>).</p></li>\n<li><p>Интерфейс наследник в обязательном порядке должен иметь атрибут <code>[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]</code>, иначе будем иметь проблемы с доступом к памяти.</p></li>\n<li><p>Интерфейс наследник наследуется от интерфейса который для него является базовым лишь для удобства работы с данными интерфейсами.</p></li>\n</ol>\n\n<p>Таким образом, базовый интерфейс к примеру в данном случае это <code>IDXGIObject</code> выглядит так:</p>\n\n<pre><code>/// &lt;summary&gt;\n///     An IDXGIObject interface is a base interface for all DXGI objects; IDXGIObject supports associating caller-defined\n///     (private data) with an object and retrieval of an interface to the parent object.\n/// &lt;/summary&gt;\n[Guid(\"aec22fb8-76f3-4639-9be0-28eb43a67a2e\")]\n[ComImport]\n[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\npublic interface IDXGIObject\n{\n    /// &lt;summary&gt;\n    ///     Sets an IUnknown interface as private data; this associates application-defined data with the object.\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    HResult SetPrivateData(ref Guid name, uint dataSize, IntPtr dataPtr);\n\n    /// &lt;summary&gt;\n    ///     Set an interface in the object's private data.\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    HResult SetPrivateDataInterface(ref Guid name,\n        [MarshalAs(UnmanagedType.IUnknown)] object unknownInterfaceObject);\n\n    /// &lt;summary&gt;\n    ///     Get a pointer to the object's data.\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    HResult GetPrivateData(ref Guid name, out int dataSize, out IntPtr dataPtr);\n\n    /// &lt;summary&gt;\n    ///     Gets the parent of the object.\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    HResult GetParent(ref Guid rIId, out object pParent);\n}\n</code></pre>\n\n<p>Далее от него к примеру наследуется <code>IDXGIFactory</code> определение необходимо задавать строго вот так:</p>\n\n<pre><code>/// &lt;inheritdoc /&gt;\n/// &lt;summary&gt;\n///     An &lt;see cref=\"T:Himiko.DXGI.Interfaces.IDXGIFactory\" /&gt; interface implements methods for generating DXGI objects (which handle fullscreen\n///     transitions).\n/// &lt;/summary&gt;\n[Guid(\"7b7166ec-21c7-44ae-b21a-c9ae321ae369\")]\n[ComImport]\n[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\npublic interface IDXGIFactory : IDXGIObject\n{\n    /// &lt;summary&gt;\n    ///     Sets an IUnknown interface as private data; this associates application-defined data with the object.\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    new HResult SetPrivateData(ref Guid name, uint dataSize, IntPtr dataPtr);\n\n    /// &lt;summary&gt;\n    ///     Set an interface in the object's private data.\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    new HResult SetPrivateDataInterface(ref Guid name,\n        [MarshalAs(UnmanagedType.IUnknown)] object unknownInterfaceObject);\n\n    /// &lt;summary&gt;\n    ///     Get a pointer to the object's data.\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    new HResult GetPrivateData(ref Guid name, out int dataSize, out IntPtr dataPtr);\n\n    /// &lt;summary&gt;\n    ///     Gets the parent of the object.\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    new HResult GetParent(ref Guid rIId, out object pParent);\n\n    /// &lt;summary&gt;\n    ///     Enumerates the adapters (video cards).\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    HResult EnumAdapters(uint numAdapter, [MarshalAs(UnmanagedType.IUnknown)] out object adapter);\n\n    /// &lt;summary&gt;\n    ///     Allows DXGI to monitor an application's message queue for the alt-enter key sequence (which causes the application\n    ///     to switch from windowed to fullscreen or vice versa).\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    HResult MakeWindowAssociation(IntPtr windowHandle, uint flags);\n\n    /// &lt;summary&gt;\n    ///     Get the window through which the user controls the transition to and from fullscreen.\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    HResult GetWindowAssociation(out IntPtr outHandleWindow);\n\n    /// &lt;summary&gt;\n    ///     Creates a swap chain.\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    HResult CreateSwapChain(object iUnknown, ref DxgiSwapChainDesc swapChainDesc,\n        [MarshalAs(UnmanagedType.IUnknown)] out object dxgiSwapChainObject);\n\n    /// &lt;summary&gt;\n    ///     Create an adapter interface that represents a software adapter.\n    /// &lt;/summary&gt;\n    [PreserveSig]\n    HResult CreateSoftwareAdapter(IntPtr moduleHandle, out IntPtr outPtr);\n}\n</code></pre>\n\n<p>Все проблемы себя исчерпали, и код стал работать так как должен.</p>\n"}