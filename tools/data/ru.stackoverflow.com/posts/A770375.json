{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1515868524,"creation_date":1515868524,"answer_id":770375,"question_id":668502,"body":"<p>CLR завершает .NET-приложение тогда, когда все его не <a href=\"https://msdn.microsoft.com/ru-ru/library/system.threading.thread.isbackground(v=vs.110).aspx\" rel=\"nofollow noreferrer\">фоновые</a> потоки завершили работу. Поток завершает работу, когда его главная функция возвращает управление (или при вызове метода Abort). Для приложений WPF поведение основного потока определяется свойством <a href=\"https://msdn.microsoft.com/en-us/library/system.windows.application.shutdownmode.aspx?f=255&amp;MSPPError=-2147217396\" rel=\"nofollow noreferrer\">Application.ShutdownMode</a>, по умолчанию он завершается при закрытии всех окон.</p>\n\n<p>Соответственно, методика отладки такой ситуации такова:</p>\n\n<ul>\n<li><p>Убедиться, что в программе не остается невидимых окон, мешающих закрытию основного потока.</p></li>\n<li><p>Если приложение создает (явно) дополнительные потоки, которые бесконечно работают и никогда не возвращают управление, при их запуске нужно установить свойство <code>IsBackground = true</code>. </p></li>\n<li><p>Если приложение не создает дополнительных не фоновых потоков, после завершения всех своих потоков нужно приостановить выполнение программы (<kbd>Отладка</kbd> - <kbd>Приостановить все</kbd>) и открыть окно потоков (<kbd>Отладка</kbd> - <kbd>Окна</kbd> - <kbd>Потоки</kbd>). В данном окне можно увидеть содержимое стека для каждого потока, и на основе этого понять источник проблемы. Если проблемный поток создает код сторонней библиотеки, нужно обратиться к ее документации и выяснить, как это исправить.</p></li>\n<li><p>Если проблемным потоком оказался \"GC Finalizer Thread\", нужно убедиться, что для всех IDisposable-объектов вызывается метод <code>Dispose</code> или его аналог (для файловых потоков, соединений с БД и т.п. нужно <strong>всегда</strong> явно освобождать ресурсы, чтобы избежать проблем с буферизацией/кэшированием). </p></li>\n</ul>\n\n<p>Дело в том, что финализаторы - очень ненадежный метод освобождения ресурсов. В некоторых ситуациях они могут приводить к взаимоблокировке, если поток сборщика мусора пытается взять Lock или на объект, занятый другим потоком, выполнение которого было прервано сборкой мусора (см. например <a href=\"http://blogs.microsoft.co.il/sasha/2010/06/30/sta-objects-and-the-finalizer-thread-tale-of-a-deadlock/\" rel=\"nofollow noreferrer\">здесь</a> описание такой ситуации для STA COM-объектов). </p>\n\n<p>Вызов метода <code>Environment.Exit</code> позволяет принудительно завершить программу (независимо от числа активных потоков), но так делать не следует. При этом не вызываются блоки finally в выполняющемся коде, как следствие - какие-то данные могут не дойти из промежуточных буферов до их места назначения (файл, БД, ...)</p>\n\n<p><strong>Примечание</strong> - потоки из ThreadPool по умолчанию являются фоновыми, о них можно не заботиться, они никогда не предотвращают  завершение программы.</p>\n\n<p><em>Руководство на основе обсуждения в недавнем вопросе \"Консольное приложение не завершается\", который почему-то снесли, поэтому оставляю информацию здесь.</em></p>\n"}