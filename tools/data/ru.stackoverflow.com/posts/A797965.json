{"owner":{"reputation":16058,"user_id":240512,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Ew6lG.png?s=128&g=1","display_name":"MSDN.WhiteKnight","link":"https://ru.stackoverflow.com/users/240512/msdn-whiteknight"},"is_accepted":false,"score":1,"last_activity_date":1521010941,"creation_date":1521010941,"answer_id":797965,"question_id":513736,"body":"<p>В Visual C++ можно использовать <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ff516460%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396\" rel=\"nofollow noreferrer\">функции из Intsafe.h</a>, например для умножения:</p>\n\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n#include &lt;tchar.h&gt;\n#include &lt;Intsafe.h&gt;\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    ULONGLONG  a=100000000000, b=5000000000, c;\n\n    HRESULT hr = ULongLongMult(a,b,&amp;c);\n\n    if(SUCCEEDED(hr)) printf(\"Result is %llu\",c);\n    else if(hr == INTSAFE_E_ARITHMETIC_OVERFLOW) printf(\"Overflow\");        \n\n    return 0;\n}\n</code></pre>\n\n<p>Данные функции определены как inline, и их реализация зависит от архитектуры. Функция <em>ULongLongMult</em>:</p>\n\n<ul>\n<li><p>На 64-битных архитектурах использует intrinsic-функцию компилятора <em>_umul128</em>, поэтому должна быть довольно эффективной.</p></li>\n<li><p>На 32-битных архитектурах использует специальный алгоритм расчета с разбиением чисел на 2 32-битных части (результат вычисляется по формуле <code>a.b * c.d = (a*c*2^64) + (a*d*2^32) + (b*c*2^32) + (b*d)</code>), и переполнение обнаруживается проверкой определенных битов в промежуточных результатах.</p></li>\n</ul>\n"}