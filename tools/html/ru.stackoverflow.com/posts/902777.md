---
title: "Post 902777"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Post 902777</h1>
<h2>Answer 902777</h2>
<p><a href="https://ru.stackoverflow.com/a/902777/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<p>В первом примере вот эта строка сохраняет данные аудио в массив data:</p>

<pre><code>alcCaptureSamples(dev[1], data, val);
</code></pre>

<p>Длительность звука в массиве рассчитывается по формуле </p>

<blockquote>
  <p>t = (N <sub>Samples</sub>) / (SampleRate * N <sub>Channels</sub>)</p>
</blockquote>

<p>Размер данных в массиве (в байтах) рассчитывается по формуле:</p>

<blockquote>
  <p>N <sub>Bytes</sub> = N <sub>Samples</sub> * (BitsPerSample / 8)</p>
</blockquote>

<p>У вас N <sub>Channels</sub> = 1 (моно), SampleRate = 22050, BitsPerSample = 16, получаем:</p>

<pre><code>t = val / 22050;

N_bytes = val * 2;
</code></pre>

<p>Вам нужно объявить массив, размером достаточный для хранения требуемой длительности аудио, допустим, saved_data. После получения каждой порции через alcCaptureSamples накапливаете данные в этом массиве (просто через memcpy копируете в конец массива и сохраняете суммарный размер). Когда длительность достигает требуемого значения, останавливаете цикл, делаете свою обработку, а потом массив с накопленными данными передаете в alBufferData и выполняете код воспроизведения:</p>

<pre><code>alSourceUnqueueBuffers(source, 1, &amp;buf);
alBufferData(buf, AL_FORMAT_MONO16, saved_data, N_bytes, 22050);
alSourceQueueBuffers(source, 1, &amp;buf);
</code></pre>

<p>Есть вот такой <a href="https://ru.stackoverflow.com/a/794133/240512">пример записи звука на чистом WASAPI</a>, возможно будет полезен. Правда, там сохранение сразу в файл сделано, а не в массив.</p>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
