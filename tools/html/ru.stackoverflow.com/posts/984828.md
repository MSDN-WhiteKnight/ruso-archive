---
title: "Для чего нужны делегаты в C#?"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Для чего нужны делегаты в C#?</h1>
<p><a href="https://ru.stackoverflow.com/questions/984828/%d0%94%d0%bb%d1%8f-%d1%87%d0%b5%d0%b3%d0%be-%d0%bd%d1%83%d0%b6%d0%bd%d1%8b-%d0%b4%d0%b5%d0%bb%d0%b5%d0%b3%d0%b0%d1%82%d1%8b-%d0%b2-c">Source</a> - by <a href="https://ru.stackoverflow.com/users/329976/kioshilol">Kioshilol</a></p>
<blockquote>
<p>Разбираюсь в c# в частности с делегатами, возник вопрос зачем нужны делегаты если можно создать экземпляр класса и вызвать метод.</p>

<p>Экземпляр класса</p>

<pre><code>class MainClass
{
    public string  Print3(string s)
    {
        return s + "hello bro";
    }

    public static void Main()
    {
        MainClass m = new MainClass();
        m.Print3...
    }
}
</code></pre>

<p>Делегат </p>

<pre><code>delegate string Print2(string s);
class MainClass
{
    static string  Print3(string s)
    {
        return s + "hello bro";
    }

    public static void Main()
    {
        Print2 p = new Print2(Print3);
        string s = p("hello");
    }
}
</code></pre>

</blockquote>
<h2>Answer 984955</h2>
<p><a href="https://ru.stackoverflow.com/a/984955/">Source</a> - by <a href="https://ru.stackoverflow.com/users/178556/default-locale">default locale</a></p>
<blockquote>
<p><strong>Вопрос:</strong> Можно ли обойтись без делегатов? </p>

<p><strong>Ответ:</strong> Да. Java, можно сказать, обходится без них, до версии 8 так и аналогов никаких не было. Да и во многих других языках аналогов нет.</p>

<p><strong>Вопрос:</strong> Можно ли код, который использует делегаты, переписать без делегатов?</p>

<p><strong>Ответ:</strong> Да. Например, в той же Java, до версии 8, всегда когда нужно было привязать слушатель к событию нужно было объявить класс. Выглядело это примерно так:</p>

<pre><code>button.addActionListener(new ActionListener() {
  public void actionPerformed(ActionEvent clickevent) {
        System.out.println("Button Clicked");
  }
});
</code></pre>

<p><strong>Вопрос:</strong> Для чего нужны делегаты?</p>

<p><strong>Ответ:</strong> Это <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%81%D0%B0%D1%85%D0%B0%D1%80" rel="noreferrer">синтаксический сахар</a>. Они позволяют писать код короче.</p>

<p>Например, аналог кода выше на C#:</p>

<pre><code>button.Click += (s, e) =&gt; Console.WriteLine("Button clicked");
</code></pre>

<p>Делегаты тесно связаны с другими элементами языка: </p>

<ul>
<li>на них реализованы операторы <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/how-to-combine-delegates-multicast-delegates" rel="noreferrer">сложения и вычитания</a>; </li>
<li>они работают с методами, анонимными методами и лямбда-выражениями;</li>
<li>привязываются к событиям.</li>
</ul>

<p>Все это можно при желании реализовать самому через классы и интерфейсы, но этот функционал расширяет возможности языка, позволяет писать более короткий код.</p>

<p>Если можете написать код без делегатов — пишите. Но если тот же код можно написать быстрее и проще с делегатами было бы странно их не использовать.</p>

<p>Вообще, без большей части функционала языка можно обойтись: код, в котором используется наследование, можно переписать без него; классы можно переписать на процедурах и т.д. Любой код на C# можно переписать на ассемблере без потери производительности и функционала. Просто кода будет намного больше. В <a href="https://en.wikipedia.org/wiki/Brainfuck" rel="noreferrer">Brainfuck</a> всего 8 инструкций и любой код на C# теоретически можно переписать на нем. Разница в производительности если будет, то она скорее будет связана с поддержкой оптимизаций на уровне ОС и процессоров чем с возможностями языка.</p>

<p>P.S. Последний раз про Java: в версии 8 ввели лямбда-выражения не вводя при этом понятия «делегат» и «событие» на уровне языка. Вместо делегатов используются интерфейсы. Из-за отстутствия поддержки на уровне языка операторы на них не определены и объявление выглядит чуть более громоздко, но возможности те же.</p>

</blockquote>
<h2>Answer 984957</h2>
<p><a href="https://ru.stackoverflow.com/a/984957/">Source</a> - by <a href="https://ru.stackoverflow.com/users/338418/%d0%a0%d0%b0%d0%bc%d0%b0%d0%b7%d0%b0%d0%bd-%d0%90%d0%bb%d0%b8%d1%81%d1%85%d0%b0%d0%bd%d0%be%d0%b2">Рамазан Алисханов</a></p>
<blockquote>
<p>С помощью делегатов можно передать ссылку на метод или сам метод как параметр.</p>

<p>Например:</p>

<pre><code>User GetUser(uint id, Action&lt;Exception&gt; onError)
</code></pre>

<p>Этот метод возвращает объект User, и если произошла ошибка то выполняет НАШ код передавая в него Exception</p>

<pre><code>try {} catch(Exception e) {
OnError?.Invoke(e);
}
</code></pre>

<p>Конкретно в Вашем случае можно не создавать новый делегат, а воспользоваться встроенным Action.</p>

<pre><code>void Print(Action&lt;string&gt; print2) {
    print2?.Invoke("myMessage");
}
</code></pre>

<p>Вызвать такой метод можно следующим образом:</p>

<pre><code>void Print2((e) =&gt; { Console.WriteLn(e); }
</code></pre>

</blockquote>
<h2>Answer 984966</h2>
<p><a href="https://ru.stackoverflow.com/a/984966/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<p>Один из примеров, когда без делегатов вовсе не обойтись - взаимодействие с кодом на процедурных языках программирования, который оперирует указателями на функции. Например, см. <a href="https://ru.stackoverflow.com/a/880287/240512">данный ответ</a>, в котором определяется делегат </p>

<pre><code>delegate IntPtr KeyboardProc(int nCode, IntPtr wParam, IntPtr lParam);
</code></pre>

<p>который передается в неуправляемую функцию <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-setwindowshookexa" rel="nofollow noreferrer">SetWindowsHookEx</a> в качестве параметра HOOKPROC. Исключительно на классах (через шаблон "Наблюдатель") это не реализовать.</p>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
