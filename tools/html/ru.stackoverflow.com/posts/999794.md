---
title: "Невозможно сделать реактивацию окна посредством Winapi - SetForegroundWindow"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Невозможно сделать реактивацию окна посредством Winapi - SetForegroundWindow</h1>
<p><a href="https://ru.stackoverflow.com/questions/999794/%d0%9d%d0%b5%d0%b2%d0%be%d0%b7%d0%bc%d0%be%d0%b6%d0%bd%d0%be-%d1%81%d0%b4%d0%b5%d0%bb%d0%b0%d1%82%d1%8c-%d1%80%d0%b5%d0%b0%d0%ba%d1%82%d0%b8%d0%b2%d0%b0%d1%86%d0%b8%d1%8e-%d0%be%d0%ba%d0%bd%d0%b0-%d0%bf%d0%be%d1%81%d1%80%d0%b5%d0%b4%d1%81%d1%82%d0%b2%d0%be%d0%bc-winapi-setforegroundwindow">Source</a> - by <a href="https://ru.stackoverflow.com/users/18910/ilw">ilw</a></p>
<blockquote>
<pre><code>int main() {

    HWND hWnd = FindWindow(NULL, "Безымянный — Блокнот");    
    if (!hWnd) ExitProcess(1);

    for (int i = 0; i &lt; 2; ++i) {
        SetForegroundWindow(hWnd);
        Sleep(2000);
    }


    ExitProcess(0);
}
</code></pre>

<p>При первом шаге цикла <code>notepad</code> активируется нормально.
Потом я делаю дективацию нотепада вручную (альт таб на какое то другое окно (<strong>не консольное</strong>, если запуск даного приложения происходит из консоли)).
Но на втором шаге <code>notepad</code> не активируется, а мигает в трее коричневым.
<a href="https://i.stack.imgur.com/dUgnH.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/dUgnH.png" alt="введите сюда описание изображения"></a>
Как сделать реактивацию возможной?</p>

<p><strong>Update</strong>:
Прочтя ответы и доп. инфу попробовал сделать вот так. </p>

<pre><code>int main(int argc, char **argv) {

    if (argc &gt; 1) {
        HWND hWnd = FindWindow(NULL, "Безымянный — Блокнот");
        if (!hWnd) ExitProcess(1);
        SetForegroundWindow(hWnd);
        ExitProcess(10);
    }

    std::string app(argv[0]);
    app.append(" 1");
    for (int i = 0; i &lt; 2; ++i) {
        system(app.c_str());
        Sleep(2000);
    }

    ExitProcess(0);
 }
</code></pre>

<p>И ведь задуманное работает! Неужели нельзя найти обходной путь и заставить работать все это в одном процессе. :(
Ведь с костылем все равно работает так или иначе.</p>

</blockquote>
<h2>Answer 999801</h2>
<p><a href="https://ru.stackoverflow.com/a/999801/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<p>Никак. Функция SetForegroundWindow имеет <a href="https://docs.microsoft.com/ru-ru/windows/win32/api/winuser/nf-winuser-setforegroundwindow#remarks" rel="nofollow noreferrer">определенные ограничения</a>: фоновый процесс не может изменить активное окно, если в данный момент активно окно другого процесса. Процесс, владеющий активным окном, может передать это право другому процессу с помощью функции AllowSetForegroundWindow, но возможности принудительно "увести" активное окно у любого процесса нет. </p>

<p>Так как идея принудительно делать окно активным каждые 2 секунды выглядит довольно бессмысленной, возможно, вам на самом деле нужно что-то другое. Например, вызов <a href="https://docs.microsoft.com/ru-ru/windows/win32/api/winuser/nf-winuser-setwindowpos" rel="nofollow noreferrer">SetWindowPos</a> с флагом HWND_TOPMOST, который позволяет отображать окно постоянно поверх всех окон. </p>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
