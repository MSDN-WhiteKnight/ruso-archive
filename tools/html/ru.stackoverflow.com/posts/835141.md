---
title: "Не получается получить данные о UDP соединениях с помощью GetExtendedUdpTable"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Не получается получить данные о UDP соединениях с помощью GetExtendedUdpTable</h1>
<p><a href="https://ru.stackoverflow.com/questions/835141/%d0%9d%d0%b5-%d0%bf%d0%be%d0%bb%d1%83%d1%87%d0%b0%d0%b5%d1%82%d1%81%d1%8f-%d0%bf%d0%be%d0%bb%d1%83%d1%87%d0%b8%d1%82%d1%8c-%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d0%b5-%d0%be-udp-%d1%81%d0%be%d0%b5%d0%b4%d0%b8%d0%bd%d0%b5%d0%bd%d0%b8%d1%8f%d1%85-%d1%81-%d0%bf%d0%be%d0%bc%d0%be%d1%89%d1%8c%d1%8e-getextendedudptable">Source</a> - by <a href="https://ru.stackoverflow.com/users/289076/oleg-lylok">Oleg Lylok</a></p>
<blockquote>
<p>Есть следующий код:</p>

<pre><code>    private struct MIB_UDPROW_OWNER_PID
    {
        public uint dwLocalAddr;
        public uint dwLocalPort;
        public uint dwOwningPid;
    }
   enum UDP_TABLE_CLASS
    {
        UDP_TABLE_BASIC,
        UDP_TABLE_OWNER_MODULE,
        UDP_TABLE_OWNER_PID
    }

    const uint ERROR_INSUFFICIENT_BUFFER = 122;
    const uint NO_ERROR = 0;
    private const uint AF_INET = 2;
    private const uint AF_INET6 = 23;

    [DllImport("Iphlpapi.dll", SetLastError = true, ExactSpelling = true)]
    static extern uint GetExtendedUdpTable(IntPtr pTcpTable,
       ref int pdwSize,
       bool bOrder,
       uint ulAf,
       UDP_TABLE_CLASS TableClass,
       uint Reserved
       )
       ;
    static void Main(string[] args)
    {
        while (true)
        {
            Thread.Sleep(100);
            MIB_UDPROW_OWNER_PID[] ms = GetUdpTableForEachProcess();
            foreach (MIB_UDPROW_OWNER_PID m in ms )
            {
                Console.WriteLine(m.dwLocalPort);
            }
        }
    }
    static MIB_UDPROW_OWNER_PID[] GetUdpTableForEachProcess()
    {
        IntPtr ptr = IntPtr.Zero;
        int buffSize = 0;
        uint dwError;

        dwError = GetExtendedUdpTable(ptr, ref buffSize, false, AF_INET, UDP_TABLE_CLASS.UDP_TABLE_OWNER_PID, 0);

        if (dwError != ERROR_INSUFFICIENT_BUFFER)
        {
            return null;
        }

        ptr = Marshal.AllocHGlobal(buffSize);

        dwError = GetExtendedUdpTable(ptr, ref buffSize, false, AF_INET, UDP_TABLE_CLASS.UDP_TABLE_OWNER_PID, 0);

        if (dwError != NO_ERROR)
        {
            Marshal.FreeHGlobal(ptr);
            return null;
        }

        int count = Marshal.ReadInt32(ptr);
        IntPtr ptrRead = ptr + sizeof(int);
        int sz = Marshal.SizeOf(typeof(MIB_UDPROW_OWNER_PID));
        MIB_UDPROW_OWNER_PID[] mtop = new MIB_UDPROW_OWNER_PID[count];

        for (int i = 0; i &lt;= count - 1; i++)
        {
            mtop[i] = (MIB_UDPROW_OWNER_PID)Marshal.PtrToStructure(ptrRead, typeof(MIB_UDPROW_OWNER_PID));
            ptrRead += sz;
        }
        Marshal.FreeHGlobal(ptr);

        return mtop;


    }
</code></pre>

<p>И вместо того, чтобы вернуть мне порт, оно возвращает значения вида 0 0 0 <em>куча цифр</em> 0 0 0. Тоже самое и с PID. Причем с GetExtendedTcpTable все работает отлично. Все структуры и перечисления точно правильные, так как взяты с MSDN. Null нигде и никто не возвращает. Есть идеи, товарищи?</p>

</blockquote>
<h2>Answer 835285</h2>
<p><a href="https://ru.stackoverflow.com/a/835285/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<blockquote>
  <p>Все структуры и перечисления точно правильные</p>
</blockquote>

<p>Так то нет. В <em>UDP_TABLE_CLASS</em> порядок неверный, должно быть:</p>

<pre><code>enum UDP_TABLE_CLASS
{
    UDP_TABLE_BASIC,            
    UDP_TABLE_OWNER_PID,
    UDP_TABLE_OWNER_MODULE,
}
</code></pre>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
