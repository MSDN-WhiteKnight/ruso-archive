---
title: "Post 775831"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Post 775831</h1>
<h2>Answer 775831</h2>
<p><a href="https://ru.stackoverflow.com/a/775831/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<p>В современных версиях Visual C++ CRT функция <code>localtime</code> (как большинство других подобных функций) не имеет проблем с доступом из разных потоков: используемый буфер не является настоящей статической переменной, а размещен на самом деле в локальном хранилище потока. Это не значит, что хорошо ее использовать - это просто очень неудачно спроектированный API, с которым легко допустить ошибки. Но таких в С/С++ много, это ни о чем не говорит.</p>

<p>Насколько я знаю, студия на такие функции дает предупреждение, а не ошибку. Вероятно, у вас включена опция компилятора "обрабатывать предупреждения как ошибки". Вы можете отключить предупреждение директивой <code>#pragma warning(disable : 4996)</code>, если у вас хватит дисциплины при этом не использовать <strong>действительно</strong> небезопасные функции из CRT, вроде <code>strcpy</code>. Либо переписывать код с использованием безопасных функций, доступных в конкретных компиляторах.</p>

<p>Что касается <code>localtime_s</code>, она введена в стандарте С11, который считается "экзотикой", и не все реализации в полной мере его поддерживают. В С++11 ее нету. GLIBC (аналог CRT в GCC) содержит вместо нее <code>localtime_r</code> из POSIX. Чтобы писать код, который будет обрабатываться разными компиляторами, придется воспользоваться условными директивами препроцессора и написать разные ветки кода для разных компиляторов. Иначе никак.</p>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
