---
title: "Как автоматически присвоить полю его же имя?"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Как автоматически присвоить полю его же имя?</h1>
<p><a href="https://ru.stackoverflow.com/questions/949643/%d0%9a%d0%b0%d0%ba-%d0%b0%d0%b2%d1%82%d0%be%d0%bc%d0%b0%d1%82%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%b8-%d0%bf%d1%80%d0%b8%d1%81%d0%b2%d0%be%d0%b8%d1%82%d1%8c-%d0%bf%d0%be%d0%bb%d1%8e-%d0%b5%d0%b3%d0%be-%d0%b6%d0%b5-%d0%b8%d0%bc%d1%8f">Source</a> - by <a href="https://ru.stackoverflow.com/users/327954/user327954">user327954</a></p>
<blockquote>
<pre><code>public static class Class1
{
    public static string name1 = "name1";
    public static string name2 = this.Name;
}
</code></pre>

<p>К name2 автоматически присвоить значение его же имени, без указания имени в строке.</p>

<p>А можно как-то покороче чем это, без указания второй раз имени name2?:</p>

<pre><code>public static string name2 = nameof(name2);
</code></pre>

</blockquote>
<h2>Answer 949786</h2>
<p><a href="https://ru.stackoverflow.com/a/949786/">Source</a> - by <a href="https://ru.stackoverflow.com/users/186752/andrew">Andrew</a></p>
<blockquote>
<p>Давай представим себе ситуацию:</p>

<pre><code>Cat Tomas = new Cat();
Cat Daryl = Tomas;
</code></pre>

<p>в даном случае и <code>Tomas</code> и <code>Daryl</code> переменные ссылаются на один и тот же обьект.</p>

<p>Какое значение должно вернутся если мы обратимся к <code>Tomas.Name</code> и какое если мы обратимся к <code>Daryl.Name</code>? Как в теории язык должен определить от какого имени был сделан вызов метода который возвращает имя?</p>

<hr>

<p>Мое предположение в даном случае что можно сделать инициализацию имени переменной обязательной. Вроде</p>

<pre><code>Cat Tomas = new Cat("Tomas");
</code></pre>

<p>Это не решает проблемы, зато работает в части случаев. (в примере выше, конечно же, работать не будет).</p>

<p>...........</p>

<p>Чисто в теории можно что-то придумать с стектрейсом. Но не факт что это будет работать в релизном билде. </p>

<p>...........</p>

<p>Чисто в теории возможно что-то придумать с рефлексией. Но не факт что это будет работать всегда как нужно и не выдавать ложных результатов, как в примере выше.</p>

<hr>

<p>Вообще я настоятельно не советую так делать вообще в принципе. Используй <code>nameof()</code> в местах где тебе это нужно. Это гарантированно не принесет проблем.</p>

<p>А так же, скорее всего, ты движешся в неправильном направлении и придумал неправильное решение своей задачи.</p>

</blockquote>
<h2>Answer 953109</h2>
<p><a href="https://ru.stackoverflow.com/a/953109/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<p><strong>Решение для .NET 4.5+ / .NET Core</strong></p>

<pre><code>using System.Runtime.CompilerServices;

public static class MyName
{
     public static string Get([CallerMemberName] string s = "") { return s; }
}

public class Class1
{     
     public static string name1 = "name1";            
     public static string name2 = MyName.Get();            
}
</code></pre>

<p>Примечание. Тот факт, что при использовании в инициализаторе поля CallerMemberName возвращает имя этого поля (а не имя конструктора, который на самом деле является caller'ом), не документирован. Но это работает.</p>

<p><strong>Решение для более старых версий .NET</strong></p>

<pre><code>using System;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;

public static class MyName
{
    static OpCode FindOpCode(short val)
    {
        OpCode ret = OpCodes.Nop;
        FieldInfo[] mas = typeof(OpCodes).GetFields();
        for (int i = 0; i &lt; mas.Length; i++)
        {
            if (mas[i].FieldType == typeof(OpCode))
            {
                OpCode opcode = (OpCode)mas[i].GetValue(null);
                if (opcode.Value == val)
                {
                    ret = opcode;
                    break;
                }
            }
        }
        return ret;
    }

    static string GetFieldNameFromOffset(MethodBase mi, int offset)
    {
        MethodBody mb = null;
        string result = "";

        //получаем тело метода                
        mb = mi.GetMethodBody();
        if (mb == null) throw new ApplicationException("Fatal error: GetMethodBody failed!");

        //получаем IL-код
        var msil = mb.GetILAsByteArray();

        //получаем модуль, в котором расположен метод
        var module = mi.Module;

        short op;
        int n = offset;

        //парсим IL-код...
        while (true)
        {
            if (n &gt;= msil.Length) break;

            //получаем код операции
            if (msil[n] == 0xfe)
                op = (short)(msil[n + 1] | 0xfe00);
            else
                op = (short)(msil[n]);

            //найдем имя операции
            OpCode opcode = FindOpCode(op);
            string str = opcode.Name;

            int size = 0;

            //найдем размер операции
            switch (opcode.OperandType)
            {
                case OperandType.InlineBrTarget: size = 4; break;
                case OperandType.InlineField: size = 4; break;
                case OperandType.InlineMethod: size = 4; break;
                case OperandType.InlineSig: size = 4; break;
                case OperandType.InlineTok: size = 4; break;
                case OperandType.InlineType: size = 4; break;
                case OperandType.InlineI: size = 4; break;
                case OperandType.InlineI8: size = 8; break;
                case OperandType.InlineNone: size = 0; break;
                case OperandType.InlineR: size = 8; break;
                case OperandType.InlineString: size = 4; break;
                case OperandType.InlineSwitch: size = 4; break;
                case OperandType.InlineVar: size = 2; break;
                case OperandType.ShortInlineBrTarget: size = 1; break;
                case OperandType.ShortInlineI: size = 1; break;
                case OperandType.ShortInlineR: size = 4; break;
                case OperandType.ShortInlineVar: size = 1; break;
                default:
                    throw new Exception("Unknown operand type.");
            }
            size += opcode.Size;

            int token = 0;
            if (n &gt; offset &amp;&amp; (str == "stsfld" || str == "stfld"))
            {
                //найдем токен метаданных поля
                token = (((msil[n + 1] | (msil[n + 2] &lt;&lt; 8)) |
                    (msil[n + 3] &lt;&lt; 0x10)) | (msil[n + 4] &lt;&lt; 0x18));

                //найдем поле в модуле по токену
                var fi = module.ResolveField(token);
                result = fi.Name;
                return result;
            }

            n += size; //пропускаем нужное число байтов
        }

        return result;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static string Get()
    {               
        //найдем вызывающий метод
        var stack = new StackTrace(true);                
        var frame = stack.GetFrame(1);  
        var method = frame.GetMethod();

        //найдем имя поля по смещению в IL
        var name = GetFieldNameFromOffset(method, frame.GetILOffset());
        return name;
    }
}

public class Class1
{     
    public static string name1 = "name1";            
    public static string name2 = MyName.Get();            
}
</code></pre>

<p>Для инициализатора поля name2 в коде конструктора компилятор генерирует последовательность IL-инструкций call и stsfld. Метод StackFrame.GetILOffset позволяет нам получить смещение инструкции call в байтах относительно начала кода конструктора, а MethodInfo.GetMethodBody позволяет получить сам IL-код конструктора. Чтобы получить FieldInfo, достаточно найти инструкцию, следующую за call, вытащить токен метаданных поля и передать его в метод Module.ResolveField. Из FieldInfo уже легко получить имя поля.</p>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
