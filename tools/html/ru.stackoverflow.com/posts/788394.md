---
title: "Как напечатать стек вызовов в обработчике исключения?"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Как напечатать стек вызовов в обработчике исключения?</h1>
<p><a href="https://ru.stackoverflow.com/questions/788394/%d0%9a%d0%b0%d0%ba-%d0%bd%d0%b0%d0%bf%d0%b5%d1%87%d0%b0%d1%82%d0%b0%d1%82%d1%8c-%d1%81%d1%82%d0%b5%d0%ba-%d0%b2%d1%8b%d0%b7%d0%be%d0%b2%d0%be%d0%b2-%d0%b2-%d0%be%d0%b1%d1%80%d0%b0%d0%b1%d0%be%d1%82%d1%87%d0%b8%d0%ba%d0%b5-%d0%b8%d1%81%d0%ba%d0%bb%d1%8e%d1%87%d0%b5%d0%bd%d0%b8%d1%8f">Source</a> - by <a href="https://ru.stackoverflow.com/users/217357/lmtinytoon">LmTinyToon</a></p>
<blockquote>
<p>У меня есть c++ программа на Windows, в которой я хочу предусмотреть полный логгинг стека вызовов в случае возникновения ошибки (hardware, software). Возможно ли реализовать такую функциональность? Вот небольшой кусок кода, содержащий внешний seh обработчик:</p>

<pre><code>__try
{
     difficult_task();
}
__except(my_seh_filter(GetExceptionInformation()))
{
    // How to print full backtrace of exception here?
}
</code></pre>

<p>Что я знаю на данный момент:</p>

<ol>
<li>Поставляемая windows DbgHelp.dll позволяет получить информацию о стэке вызовов (распечатать стэк можно).</li>
<li>SEH обработка исключений позволяет получить контекст в котором возникло исключение. (Тип исключения, адресс возникновения исключения, регистры процессора на момент выброса исключения).</li>
</ol>

<p>Есть одно <strong>НО</strong>. Я хочу распечатать стек вызовов непосредственно в seh фильтре или соответсвующем catch блоке. И мне не совсем понятно, как можно используя эти два инструмента  распечатать backtrace (он ведь на момент раскрутки стэка может изменится). Одно дело когда я распечатываю стэк в момент выброса исключения. Другое когда в момент обработки (я предполагаю что на момент обработки исключения полной информации о стеке у меня уже не будет).</p>

</blockquote>
<h2>Answer 809888</h2>
<p><a href="https://ru.stackoverflow.com/a/809888/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<p>Стек вызовов проще всего вывести из SEH-фильтра, передавая в функцию <em>StackWalk64</em> указатель на контекст, возвращенный <em>GetExceptionInformation</em>. Как-то так:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;
#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;
#include "DbgHelp.h"
#pragma comment(lib, "Dbghelp.lib")

const int MaxNameLen = 256;

//выводит стек вызовов, соответствующий указанному контексту
void printStack( CONTEXT* ctx )
{
    BOOL    result;
    HANDLE  process;
    HANDLE  thread;
    HMODULE hModule;

    STACKFRAME64        stack;
    ULONG               frame;    
    DWORD64             displacement;

    char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)];
    char name[ MaxNameLen ];
    char module[MaxNameLen];
    PSYMBOL_INFO pSymbol = (PSYMBOL_INFO)buffer;

    memset( &amp;stack, 0, sizeof( STACKFRAME64 ) );

    process                = GetCurrentProcess();
    thread                 = GetCurrentThread();
    displacement           = 0;
#if !defined(_M_AMD64)
    stack.AddrPC.Offset    = (*ctx).Eip;
    stack.AddrPC.Mode      = AddrModeFlat;
    stack.AddrStack.Offset = (*ctx).Esp;
    stack.AddrStack.Mode   = AddrModeFlat;
    stack.AddrFrame.Offset = (*ctx).Ebp;
    stack.AddrFrame.Mode   = AddrModeFlat;
#endif

    SymInitialize( process, NULL, TRUE ); //загружаем символы

    for( frame = 0; ; frame++ )
    {
        //получаем следующий вызов из стека
        result = StackWalk64
        (
#if defined(_M_AMD64)
            IMAGE_FILE_MACHINE_AMD64
#else
            IMAGE_FILE_MACHINE_I386
#endif
            ,
            process,
            thread,
            &amp;stack,
            ctx,
            NULL,
            SymFunctionTableAccess64,
            SymGetModuleBase64,
            NULL
        );

        if( !result ) break;        

        //полчаем имя символа для адреса
        pSymbol-&gt;SizeOfStruct = sizeof(SYMBOL_INFO);
        pSymbol-&gt;MaxNameLen = MAX_SYM_NAME;
        SymFromAddr(process, ( ULONG64 )stack.AddrPC.Offset, &amp;displacement, pSymbol);

        hModule = NULL;
        lstrcpyA(module,"");        
        GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, 
            (LPCTSTR)(stack.AddrPC.Offset), &amp;hModule);

        //получаем имя модуля
        if(hModule != NULL)GetModuleFileNameA(hModule,module,MaxNameLen);       

        printf ("%lu: %s  (in %s)\n",frame,pSymbol-&gt;Name,module);       

    }
}



void BuggedFunction()
{
    int * p = NULL;
    *p = 5;
}

void bar()
{
    BuggedFunction();
}

void foo()
{    
     bar();    
}

int seh_filter(_EXCEPTION_POINTERS* ex)
{
    printf("Exception 0x%x occured\n",ex-&gt;ExceptionRecord-&gt;ExceptionCode);  
    printStack(ex-&gt;ContextRecord);

    return EXCEPTION_EXECUTE_HANDLER;
}

int main(void)
{
    setlocale(LC_ALL,"Russian");

    __try
    {
        foo();
    }
    __except(seh_filter(GetExceptionInformation()))
    {       
        printf("Exception \n");         
    }
    getchar();
    return 0;
}
</code></pre>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
