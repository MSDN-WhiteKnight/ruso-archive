---
title: "В чем разница в массивах IEnumerable&lt;T&gt; и List&lt;T&gt;?"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>В чем разница в массивах IEnumerable&lt;T&gt; и List&lt;T&gt;?</h1>
<p><a href="https://ru.stackoverflow.com/questions/969675/%d0%92-%d1%87%d0%b5%d0%bc-%d1%80%d0%b0%d0%b7%d0%bd%d0%b8%d1%86%d0%b0-%d0%b2-%d0%bc%d0%b0%d1%81%d1%81%d0%b8%d0%b2%d0%b0%d1%85-ienumerablet-%d0%b8-listt">Source</a> - by <a href="https://ru.stackoverflow.com/users/333909/vellfall">vellfall</a></p>
<blockquote>
<p>Возможно вопрос не совсем корректный.
Допустим у нас имеется следующий код:</p>

<pre><code>  List&lt;int&gt; listValues = new List&lt;int&gt; { 1, 2, 3 };
            var t1 = listValues.ToList();
</code></pre>

<p>В данном случае переменная t1 будет ссылаться на новый объект List с аналогичными значениями.</p>

<pre><code>IEnumerable&lt;int&gt; listValues2 = new List&lt;int&gt; { 1, 2, 3 };
        var t2 = listValues2.ToList();
</code></pre>

<p>Здесь, как я понял происходит то, что t2 ссылаться на новый объект IEnumerable с аналогичными значениями (массив t2 содержит 1,2,3).</p>

<p>Разнится в том, что при добавлении элементов во втором случае надо явно привести к типу List, так? </p>

<pre><code> ((List&lt;int&gt;)listValues2).Add(4);
</code></pre>

<p>И/или имеются еще различия в данном случае?</p>

</blockquote>
<h2>Answer 970139</h2>
<p><a href="https://ru.stackoverflow.com/a/970139/">Source</a> - by <a href="https://ru.stackoverflow.com/users/248343/cost">Cost</a></p>
<blockquote>
<p><code>t2</code>, как и <code>t1</code>, будет ссылаться на новый объект <code>List&lt;int&gt;</code>. <code>IEnumerable&lt;T&gt;</code> - интерфейс, создать экземпляр интерфейса нельзя. </p>

<p><code>listValues2</code> - интерфейсная ссылка. Она может указывать на любой экземпляр любого класса, реализующего <code>IEnumerable&lt;int&gt;</code>. Например, на экземпляр класса <code>Queue&lt;int&gt;</code> или <code>Stack&lt;int&gt;</code>.</p>

<p><code>IEnumerable&lt;T&gt;</code> необходим для оператора <code>foreach</code>, так как определяет метод <code>GetEnumerator()</code>. В этом интерфейсе не определяется метод <code>Add()</code>. Этот метод определен в интерфейсе <code>ICollection&lt;T&gt;</code>, который также реализуется классом <code>List&lt;T&gt;</code>. Именно поэтому для добавления элементов по ссылке <code>listValues2</code> приходится предварительно явно приводить типы. При этом, если ссылка <code>listValues2</code> указывала на экземпляр класса, отличного от <code>List&lt;int&gt;</code> произойдет исключение времени выполнения.</p>

</blockquote>
<h2>Answer 970141</h2>
<p><a href="https://ru.stackoverflow.com/a/970141/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<blockquote>
  <p>Здесь, как я понял происходит то, что t2 ссылаться на новый объект IEnumerable с аналогичными значениями</p>
</blockquote>

<p>Тип времени выполнения в обоих случаях одинаковый - List. Более того, даже если заменить <code>var ...</code> на <code>IEnumerable&lt;int&gt; ...</code>, ничего не изменится, тип времени выполнения останется тем же, так как метод ToList всегда возвращает объект типа List. (Кроме того, объект просто не может иметь тип IEnumerable, так как экземпляр интерфейса создать нельзя.)</p>

<p>Чтобы убедиться на практике, выполните код:</p>

<pre><code>List&lt;int&gt; listValues = new List&lt;int&gt; { 1, 2, 3 };
var t1 = listValues.ToList();
Console.WriteLine(t1.GetType());

IEnumerable&lt;int&gt; listValues2 = new List&lt;int&gt; { 1, 2, 3 };
var t2 = listValues2.ToList();
Console.WriteLine(t2.GetType());

IEnumerable&lt;int&gt; listValues3 = new List&lt;int&gt; { 1, 2, 3 };
IEnumerable&lt;int&gt; t3 = listValues3.ToList();
Console.WriteLine(t3.GetType()); 
</code></pre>

<p>Он выведет</p>

<pre class="lang-none prettyprint-override"><code>System.Collections.Generic.List`1[System.Int32]
System.Collections.Generic.List`1[System.Int32]
System.Collections.Generic.List`1[System.Int32]
</code></pre>

<hr>

<p>Чтобы все-таки получить тип времени выполнения, отличный от List, можно реализовать метод-итератор:</p>

<pre><code>static IEnumerable&lt;int&gt; Foo(List&lt;int&gt; list)
{
    for (int i = 0; i &lt; list.Count; i++) yield return list[i];
}
</code></pre>

<p>Тогда</p>

<pre><code>var t4 = Foo(listValues);
Console.WriteLine(t4.GetType());
</code></pre>

<p>Выведет имя автоматически сгенерированного компилятором типа-итератора (у меня <code>ConsoleApplication1.Program+&lt;Foo&gt;d__0</code>)</p>

</blockquote>
<h2>Answer 971989</h2>
<p><a href="https://ru.stackoverflow.com/a/971989/">Source</a> - by <a href="https://ru.stackoverflow.com/users/184217/alexander-petrov">Alexander Petrov</a></p>
<blockquote>
<p>Давайте я попробую немножко объяснить по-своему.</p>

<p>Зайду с другого конца: зачем на практике могут понадобиться интерфейсы?</p>

<p>Допустим, вам понадобилось выводить на консоль содержимое списка <code>List&lt;int&gt;</code> и вы написали такой метод для этого:</p>

<pre><code>static void Print(List&lt;int&gt; list)
{
    foreach (var n in list)
        Console.Write(n + " ");
    Console.WriteLine();
}
</code></pre>

<p>Теперь можно его использовать:</p>

<pre><code>List&lt;int&gt; list = new List&lt;int&gt; { 1, 2, 3 };
Print(list);
</code></pre>

<p>Удобно.</p>

<p>Но что, если нам понадобилось вывести массив? Пробуем использовать этот же метод:</p>

<pre><code>int[] array = new int[] { 4, 5, 6 };
Print(array);
</code></pre>

<p>Увы, это невозможно.</p>

<p>Как быть? Давайте разберёмся, что именно делается со списком в этом методе: он <em>перечисляется</em> (enumerate). В него ничего не добавляется, не изменяется, не удаляется. Всё, что от него требуется - позволить себя перечислять (проходить по нему).</p>

<p>Интерфейс <code>IEnumerable</code> как раз и означает, что тип, реализующий его, является <em>перечислым</em> - по нему можно пробежаться в цикле.</p>

<p>Изменим наш метод следующим образом:</p>

<pre><code>static void Print(IEnumerable&lt;int&gt; list)
{
    foreach (var n in list)
        Console.Write(n + " ");
    Console.WriteLine();
}
</code></pre>

<p>Теперь код <code>Print(array);</code> успешно компилируется и работает.</p>

<p>Теперь мы можем передавать в этот метод любой тип, реализующий интерфейс <code>IEnumerable&lt;int&gt;</code>. Конечно, здесь мы ограничены типом <code>int</code>, но оставим это за рамками обсуждения.</p>

<p>Более того, другой программист, использующий нашу библиотеку с этим методом, по одной лишь сигнатуре этого метода скажет, что может произойти с коллекцией, которую он подаст на вход: она будет перечислена и только. А если метод принимает <code>List&lt;int&gt;</code>, то внутри метода вполне может произойти добавление новых данных в список или их удаление, или другие нежелательные действия...</p>

<p>Таким образом, интерфейсы позволяют использовать не один жёстко заданный тип, а множество разных. А также интерфейсы дают понять, какие действия разрешены.</p>

<p>PS: ещё больше гарантий по неизменности данных дают интерфейсы <code>IReadOnly*</code>.</p>

</blockquote>
<h2>Answer 993724</h2>
<p><a href="https://ru.stackoverflow.com/a/993724/">Source</a> - by <a href="https://ru.stackoverflow.com/users/339485/mrfresnel">MrFresnel</a></p>
<blockquote>
<p>Ответ немного припоздал, но всё-же. Важно понимать, что тип переменной и тип её значения - не одно и то же. К примеру:</p>

<pre><code>using System;
using System.Collections.Generic;

namespace CSrharpApplicationTest
{
    internal class Program
    {
        private static void Main(string[] args)
        {
            IEnumerable&lt;int&gt; x = new List&lt;int&gt;();
            Console.WriteLine(x.GetType());
        }
    }
}

</code></pre>

<p>Тип переменной - <code>IEnumerable&lt;int&gt;</code>, тип её значения - <code>List&lt;int&gt;</code>. </p>

<p>В обоих случаях в Ваших примерах тип <code>t1</code> и <code>t2</code> - <code>List&lt;int&gt;</code>, благодаря вызову метода-расширения <code>ToList()</code>, реализация которого выглядит следующим образом:</p>

<pre><code>        [__DynamicallyInvokable]
        public static List&lt;TSource&gt; ToList&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source)
        {
            if (source == null)
            {
                throw Error.ArgumentNull("source");
            }
            return new List&lt;TSource&gt;(source);
        }
</code></pre>

<p>, где конструктор <code>List&lt;TSource&gt;</code> описывается так:</p>

<pre><code>        [__DynamicallyInvokable]
        public List(IEnumerable&lt;T&gt; collection)
        {
            if (collection == null)
            {
                ThrowHelper.ThrowArgumentNullException(ExceptionArgument.collection);
            }
            ICollection&lt;T&gt; collection2 = collection as ICollection&lt;T&gt;;
            if (collection2 != null)
            {
                int count = collection2.Count;
                if (count == 0)
                {
                    _items = _emptyArray;
                }
                else
                {
                    _items = new T[count];
                    collection2.CopyTo(_items, 0);
                    _size = count;
                }
            }
            else
            {
                _size = 0;
                _items = _emptyArray;
                foreach (T item in collection)
                {
                    Add(item);
                }
            }
        }
</code></pre>

<blockquote>
  <p>Разнится в том, что при добавлении элементов во втором случае надо явно привести к типу List, так?</p>
</blockquote>

<p>Да, во втором случае Вы указываете компилятору, что тип <code>listValues2</code> - любой тип, реализующий <code>IEnumerable&lt;int&gt;</code>. В интерфейсе <code>IEnumerable&lt;out T&gt;</code>, нет методов добавления/изменения/удаления элементов, ведь он описывает минимальный функционал для возможности <strong>перечисления</strong> по коллекции, соответственно компилятор не может дать гарантий, что то, что лежит внутри <code>listValues2</code> - коллекция, с методом <code>Add</code>. Поэтому требуется явное приведение типа к <code>List&lt;int&gt;</code>.</p>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
