---
title: "Можно ли на языках C/C++ определить целочисленное переполнение?"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Можно ли на языках C/C++ определить целочисленное переполнение?</h1>
<p><a href="https://ru.stackoverflow.com/questions/513736/%d0%9c%d0%be%d0%b6%d0%bd%d0%be-%d0%bb%d0%b8-%d0%bd%d0%b0-%d1%8f%d0%b7%d1%8b%d0%ba%d0%b0%d1%85-c-c-%d0%be%d0%bf%d1%80%d0%b5%d0%b4%d0%b5%d0%bb%d0%b8%d1%82%d1%8c-%d1%86%d0%b5%d0%bb%d0%be%d1%87%d0%b8%d1%81%d0%bb%d0%b5%d0%bd%d0%bd%d0%be%d0%b5-%d0%bf%d0%b5%d1%80%d0%b5%d0%bf%d0%be%d0%bb%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5">Source</a> - by <a href="https://ru.stackoverflow.com/users/17836/lxa">LXA</a></p>
<blockquote>
<p>Часто в контексте безопасного программирования упоминают проблему целочисленного переполнения (<strong>integer overflow</strong>). А возможно ли отловить эту ситуацию в C/C++ коде? Ведь процессоры (по крайней мере x86) имеют среди <code>EFLAGS</code> флаг <code>Overflow Flag</code>, получается, что чисто технически такая возможность имеется, да и оверхэд на проверку флага в регистре не должен быть большим (думается так). Либо проблема в постановке вопроса и переполнение нужно не отлавливать, а не допускать никогда? Значит ли последнее, что целочисленные типы принципиально не подходят для любых вычислений?</p>

<p>P.S. Вопрос возник в связи с тем, что в существующем коде (наблюдаемом мной) широко используется <code>int</code> для арифметических расчетов и ничто не защищает от переполнений, гипотетически они могут остаться незамеченными (логикой). И в большинстве случаев с большой вероятностью все в норме (реальные значения невелики), но иногда...</p>

</blockquote>
<h2>Answer 513775</h2>
<p><a href="https://ru.stackoverflow.com/a/513775/">Source</a> - by <a href="https://ru.stackoverflow.com/users/195342/harry">Harry</a></p>
<blockquote>
<p>Официально в стандарте языка записано, если я не путаю, что переполнение знаковых целочисленных типов зависит от реализации (может генерироваться исключение, может игнорироваться), а беззнаковых игнорируется - значение приводится в представимый диапазон.</p>

<p>Т.е. получается примерно так - сам C/C++ <strong>встроенных</strong> <strong>переносимых</strong> средств обнаружения переполнения не имеет.</p>

<p>Но всегда можно использовать дополнительные методы, которые позволят по данным операндам выяснить, будет ли переполнение при выполнении операции. Масса таких вещей описана в книге Г. Уоррена <em>Алгоритмические трюки для программистов</em>.</p>

<p>Ну и как иллюстрация, насколько легко пропустить это переполнение - у Страуструпа в <em>Программирование. Принципы и практика...</em> есть одна программка, в которой вычислялся ряд для e<sup>x</sup>, что ли - и она у него в разнос шла. Он честно написал, что раньше, мол, я думал, что это связано с потерей точности в <code>double</code>, и вроде даже так и написал в первом издании книги, а потом ко второму изданию дошло, что на самом деле это переполнение целочисленных значений при вычислении факториала. Если уж даже Страуструп... :)</p>

</blockquote>
<h2>Answer 513786</h2>
<p><a href="https://ru.stackoverflow.com/a/513786/">Source</a> - by <a href="https://ru.stackoverflow.com/users/193189/netch">Netch</a></p>
<blockquote>
<p>Действие по умолчанию зависит от процессора, компилятора и настроек. На MIPS, например, его "классические" компиляторы превращали сложение знаковых в команду add, которая генерирует исключение при переполнении, а беззнаковых - addu, которая не генерирует. Но gcc, clang уже такого не делали, всё через addu. На x86 - родные команды add, sub  игнорируют переполнение (точнее, ставят флаг CF или OF, но не генерируют исключение).<br>
Компиляторы современного типа считают, что переполнения в операциях с целыми со знаком не должно быть, иногда из-за этого возникают интересные эффекты - вот <a href="http://rsdn.org/forum/cpp/5654034.all" rel="nofollow noreferrer">самый убойный пример</a> из тех, что я видел. Стандарт тут действует по принципу "мы вам даём возможность писать максимально эффективно, потому что это C, а не учебный язык, а защита от кривостей - ваша проблема".</p>

<p>Для C++ есть, например, библиотечка (шаблонный заголовочный файл) <code>SafeInt3</code> от Microsoft, под свободной лицензией; ею можно покрыть все основные операции, хотя она не использует специфику процессоров (даже x86) и оттого во многих случаях неэффективна - там, где достаточно одного OF или CF, она городит много сложных расчётов.</p>

<p>Для C придётся всё писать вручную, заменяя обычные операции на свои эквиваленты функциями или макросами.</p>

<p>UPDATE: про новые встроенные функции последних gcc и clang (<code>__builtin_add_overflow</code>, <code>__builtin_mul_overflow</code> и вся группа)уже писали. Но и без них можно сделать достаточно неплохо. Например, в случае сложения двух int, проверка вида <code>a &gt; INT_MAX - b</code>, если b > 0, иначе <code>a &lt; INT_MIN - b</code>, достаточна, чтобы проверить разрешимость сложения.</p>

</blockquote>
<h2>Answer 514891</h2>
<p><a href="https://ru.stackoverflow.com/a/514891/">Source</a> - by <a href="https://ru.stackoverflow.com/users/232/avp">avp</a></p>
<blockquote>
<p>Хоть и не приветствуются ответы только из ссылок, но вот нашел хороший материал (в т.ч. там код проверок, вызовет ли переполнение (более обще -- безопасно ли) сложение, вычитание, умножение и деление целых):</p>

<p><a href="https://www.securecoding.cert.org/confluence/display/c/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow" rel="nofollow">https://www.securecoding.cert.org/confluence/display/c/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow</a></p>

<p>с обсуждениями и т.п. </p>

<p><strong>Update</strong></p>

<p>Поскольку при поиске ответа всегда хочется сразу увидеть конкретный код, помогающий в решении задачи (а не гадать, например, как правильно написать  условие проверки для вычитания, уже зная правильный ответ для сложения), приведу тут некоторые из материалов по этой ссылке, которые можно использовать как образцы  для своих программ.</p>

<p><strong>Проверка перед сложением:</strong></p>

<pre><code>#include &lt;limits.h&gt;

void f(signed int si_a, signed int si_b) {
  signed int sum;
  if (((si_b &gt; 0) &amp;&amp; (si_a &gt; (INT_MAX - si_b))) ||
      ((si_b &lt; 0) &amp;&amp; (si_a &lt; (INT_MIN - si_b)))) {
    /* Handle error */
  } else {
    sum = si_a + si_b;
  }
  /* ... */
}
</code></pre>

<p><strong>Проверка перед вычитанием:</strong></p>

<pre><code>#include &lt;limits.h&gt;

void func(signed int si_a, signed int si_b) {
  signed int diff;
  if ((si_b &gt; 0 &amp;&amp; si_a &lt; INT_MIN + si_b) ||
      (si_b &lt; 0 &amp;&amp; si_a &gt; INT_MAX + si_b)) {
    /* Handle error */
  } else {
    diff = si_a - si_b;
  }

  /* ... */
}
</code></pre>

<p><strong>Проверка перед умножением:</strong></p>

<pre><code>#include &lt;limits.h&gt;

void func(signed int si_a, signed int si_b) {
  signed int result; 
  if (si_a &gt; 0) {  /* si_a is positive */
    if (si_b &gt; 0) {  /* si_a and si_b are positive */
      if (si_a &gt; (INT_MAX / si_b)) {
        /* Handle error */
      }
    } else { /* si_a positive, si_b nonpositive */
      if (si_b &lt; (INT_MIN / si_a)) {
        /* Handle error */
      }
    } /* si_a positive, si_b nonpositive */
  } else { /* si_a is nonpositive */
    if (si_b &gt; 0) { /* si_a is nonpositive, si_b is positive */
      if (si_a &lt; (INT_MIN / si_b)) {
        /* Handle error */
      }
    } else { /* si_a and si_b are nonpositive */
      if ( (si_a != 0) &amp;&amp; (si_b &lt; (INT_MAX / si_a))) {
        /* Handle error */
      }
    } /* End if si_a and si_b are nonpositive */
  } /* End if si_a is nonpositive */

  result = si_a * si_b;
}
</code></pre>

<p><strong>Проверка перед делением:</strong><br>
(или вычислением остатка)</p>

<pre><code>#include &lt;limits.h&gt;

void func(signed long s_a, signed long s_b) {
  signed long result;
  if ((s_b == 0) || ((s_a == LONG_MIN) &amp;&amp; (s_b == -1))) {
    /* Handle error */
  } else {
    result = s_a / s_b;
  }
  /* ... */
}
</code></pre>

<p>Ну, если кому не лень вытащить оттуда остальной (относящийся к вопросу ТС) код (а также описание всех существенных моментов) сюда и аккуратно его оформить, милости просим.</p>

</blockquote>
<h2>Answer 515272</h2>
<p><a href="https://ru.stackoverflow.com/a/515272/">Source</a> - by <a href="https://ru.stackoverflow.com/users/17836/lxa">LXA</a></p>
<blockquote>
<p>Попробую резюмировать: легче избежать проблемы (продумав детально арифметику), чем потом ее (неприятно) обнаруживать и обрабатывать.</p>

<p>Решения с перехватом либо зависят от компилятора, либо представляют собой отказ от непосредственно встроенных типов. Полагаю, подходящим решением (кроме работы с памятью и коллекциями, разрешающими индексацию) может стать использование чисел с плавающей запятой, т.к. они более приближены к естественной арифметике (в плане бесконечностей, деления на 0).</p>

<p>В книге "24 смертных греха компьютерной безопасности" Ховарда, Лебланка, Вьеги встретил такое решение:</p>

<ul>
<li>учет размеров типов (см. другие ответы);</li>
<li>простота кода;</li>
<li>явное преобразование типов;</li>
<li>использование <a href="http://safeint.codeplex.com/" rel="nofollow">SafeInt</a> (by Дэвид Лебланк)</li>
<li>при использовании <code>gcc</code>, компилировать с флагом <code>-ftrapv</code> (при переполнении знаковых целочисленных вызывается <code>abort()</code>);</li>
<li>использование беззнаковых целых для работы с памятью и индексами массивов (слегка облегчает последствия);</li>
</ul>

</blockquote>
<h2>Answer 797965</h2>
<p><a href="https://ru.stackoverflow.com/a/797965/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<p>В Visual C++ можно использовать <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff516460%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396" rel="nofollow noreferrer">функции из Intsafe.h</a>, например для умножения:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;Intsafe.h&gt;

int _tmain(int argc, _TCHAR* argv[])
{
    ULONGLONG  a=100000000000, b=5000000000, c;

    HRESULT hr = ULongLongMult(a,b,&amp;c);

    if(SUCCEEDED(hr)) printf("Result is %llu",c);
    else if(hr == INTSAFE_E_ARITHMETIC_OVERFLOW) printf("Overflow");        

    return 0;
}
</code></pre>

<p>Данные функции определены как inline, и их реализация зависит от архитектуры. Функция <em>ULongLongMult</em>:</p>

<ul>
<li><p>На 64-битных архитектурах использует intrinsic-функцию компилятора <em>_umul128</em>, поэтому должна быть довольно эффективной.</p></li>
<li><p>На 32-битных архитектурах использует специальный алгоритм расчета с разбиением чисел на 2 32-битных части (результат вычисляется по формуле <code>a.b * c.d = (a*c*2^64) + (a*d*2^32) + (b*c*2^32) + (b*d)</code>), и переполнение обнаруживается проверкой определенных битов в промежуточных результатах.</p></li>
</ul>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
