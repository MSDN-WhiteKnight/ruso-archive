---
title: "c# Как правильно реализовать исключение"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>c# Как правильно реализовать исключение</h1>
<p><a href="https://ru.stackoverflow.com/questions/1034895/c-%d0%9a%d0%b0%d0%ba-%d0%bf%d1%80%d0%b0%d0%b2%d0%b8%d0%bb%d1%8c%d0%bd%d0%be-%d1%80%d0%b5%d0%b0%d0%bb%d0%b8%d0%b7%d0%be%d0%b2%d0%b0%d1%82%d1%8c-%d0%b8%d1%81%d0%ba%d0%bb%d1%8e%d1%87%d0%b5%d0%bd%d0%b8%d0%b5">Source</a> - by <a href="https://ru.stackoverflow.com/users/328043/%d0%94%d0%b0%d0%bd%d0%b8%d0%bb-%d0%91%d1%83%d0%bb%d0%ba%d0%b8%d0%bd">Данил Булкин</a></p>
<blockquote>
<p>Хочу научиться пользоваться исключениями. Пожалуйста скажите правильно ли я всё делаю? И как правильно это делать? (метод CheckMove) Как можно обработать?</p>

<pre><code>abstract class ChessPiece
{
    protected int x, y;
    public abstract void MakeMove(int x, int y);

    protected virtual bool CheckMove(int x, int y)
    {
        return x &gt;= 0 &amp;&amp; x &lt;= 8 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= 8;
    }
}

class Rock : ChessPiece
{
    public override void MakeMove(int x, int y)
    {
        if (!CheckMove(x, y))
        {
            throw new System.ArgumentException("Parametr cannot be less than 0 and greater than 8");
        }
        this.x = x;
        this.y = y;
    }

    protected override bool CheckMove(int x, int y)
    {
        return (this.x == x || this.y == y) &amp;&amp; base.CheckMove(x, y);
    }
}
</code></pre>

</blockquote>
<h2>Answer 1035112</h2>
<p><a href="https://ru.stackoverflow.com/a/1035112/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<blockquote>
  <p>Пожалуйста скажите правильно ли я всё делаю? </p>
</blockquote>

<p>Если я правильно понимаю смысл кода - нет, неправильно. Вы собираетесь бросать исключение ArgumentException, когда пользователь пытается выполнить ход, не соответствующий тому, как ходит фигура по правилам шахмат. Это не выглядит исключительной ситуацией. Зачем выполнять достаточно тяжелую для CLR операцию проброса исключения для того, что можно решить простым возвратом значения? Я понимаю проброс ArgumentException, когда координаты за пределами доски, так как это обычно означает баг в коде, в этом случае можно бросать исключение.</p>

<p>Другое замечание: CheckMove - неудачное наименование для метода проверки, неясно, что именно означает true - корректность или некорректность.</p>

<p>По мне должно быть как-то так:</p>

<pre><code>class MoveResult
{
    public bool IsValid { get; set; }
    public string Message { get; set; }
}

abstract class ChessPiece
{
    protected int x, y;
    public virtual MoveResult MakeMove(int x, int y)
    {
        AssertCoordinatesValid(x, y);

        if (!IsMoveValid(x, y))
        {
            return new MoveResult
            {
                IsValid = false,
                Message = "This move is not allowed for " + this.GetType().ToString()
            };
        }
        this.x = x;
        this.y = y;
        return new MoveResult { IsValid = true, Message = "" };
    }

    static void AssertCoordinatesValid(int x, int y)
    {        
        if (!(x &gt;= 0 &amp;&amp; x &lt;= 8 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= 8))
        {
            throw new ArgumentException("Coordinates cannot be less than 0 or greater than 8");
        }
    }

    protected abstract bool IsMoveValid(int x, int y);
}

class Rock : ChessPiece
{
    protected override bool IsMoveValid(int x, int y)
    {       
        return (this.x == x || this.y == y);
    }
}
</code></pre>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
