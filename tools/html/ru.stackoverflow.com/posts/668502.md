---
title: "После закрытия программы остаётся процесс в диспетчере задач"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>После закрытия программы остаётся процесс в диспетчере задач</h1>
<p><a href="https://ru.stackoverflow.com/questions/668502/%d0%9f%d0%be%d1%81%d0%bb%d0%b5-%d0%b7%d0%b0%d0%ba%d1%80%d1%8b%d1%82%d0%b8%d1%8f-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d1%8b-%d0%be%d1%81%d1%82%d0%b0%d1%91%d1%82%d1%81%d1%8f-%d0%bf%d1%80%d0%be%d1%86%d0%b5%d1%81%d1%81-%d0%b2-%d0%b4%d0%b8%d1%81%d0%bf%d0%b5%d1%82%d1%87%d0%b5%d1%80%d0%b5-%d0%b7%d0%b0%d0%b4%d0%b0%d1%87">Source</a> - by <a href="https://ru.stackoverflow.com/users/211218/codename0082016">codename0082016</a></p>
<blockquote>
<p>После закрытия программы остаётся процесс в диспетчере задач.</p>

<p>Как определить из-за чего это происходит?</p>

<p>При запуске программы через F5 программа после закрытия правильно завершается.</p>

<p>Но после закрития при запуске Alt F5 висит в диспетчере.</p>

</blockquote>
<h2>Answer 770375</h2>
<p><a href="https://ru.stackoverflow.com/a/770375/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<p>CLR завершает .NET-приложение тогда, когда все его не <a href="https://msdn.microsoft.com/ru-ru/library/system.threading.thread.isbackground(v=vs.110).aspx" rel="nofollow noreferrer">фоновые</a> потоки завершили работу. Поток завершает работу, когда его главная функция возвращает управление (или при вызове метода Abort). Для приложений WPF поведение основного потока определяется свойством <a href="https://msdn.microsoft.com/en-us/library/system.windows.application.shutdownmode.aspx?f=255&amp;MSPPError=-2147217396" rel="nofollow noreferrer">Application.ShutdownMode</a>, по умолчанию он завершается при закрытии всех окон.</p>

<p>Соответственно, методика отладки такой ситуации такова:</p>

<ul>
<li><p>Убедиться, что в программе не остается невидимых окон, мешающих закрытию основного потока.</p></li>
<li><p>Если приложение создает (явно) дополнительные потоки, которые бесконечно работают и никогда не возвращают управление, при их запуске нужно установить свойство <code>IsBackground = true</code>. </p></li>
<li><p>Если приложение не создает дополнительных не фоновых потоков, после завершения всех своих потоков нужно приостановить выполнение программы (<kbd>Отладка</kbd> - <kbd>Приостановить все</kbd>) и открыть окно потоков (<kbd>Отладка</kbd> - <kbd>Окна</kbd> - <kbd>Потоки</kbd>). В данном окне можно увидеть содержимое стека для каждого потока, и на основе этого понять источник проблемы. Если проблемный поток создает код сторонней библиотеки, нужно обратиться к ее документации и выяснить, как это исправить.</p></li>
<li><p>Если проблемным потоком оказался "GC Finalizer Thread", нужно убедиться, что для всех IDisposable-объектов вызывается метод <code>Dispose</code> или его аналог (для файловых потоков, соединений с БД и т.п. нужно <strong>всегда</strong> явно освобождать ресурсы, чтобы избежать проблем с буферизацией/кэшированием). </p></li>
</ul>

<p>Дело в том, что финализаторы - очень ненадежный метод освобождения ресурсов. В некоторых ситуациях они могут приводить к взаимоблокировке, если поток сборщика мусора пытается взять Lock или на объект, занятый другим потоком, выполнение которого было прервано сборкой мусора (см. например <a href="http://blogs.microsoft.co.il/sasha/2010/06/30/sta-objects-and-the-finalizer-thread-tale-of-a-deadlock/" rel="nofollow noreferrer">здесь</a> описание такой ситуации для STA COM-объектов). </p>

<p>Вызов метода <code>Environment.Exit</code> позволяет принудительно завершить программу (независимо от числа активных потоков), но так делать не следует. При этом не вызываются блоки finally в выполняющемся коде, как следствие - какие-то данные могут не дойти из промежуточных буферов до их места назначения (файл, БД, ...)</p>

<p><strong>Примечание</strong> - потоки из ThreadPool по умолчанию являются фоновыми, о них можно не заботиться, они никогда не предотвращают  завершение программы.</p>

<p><em>Руководство на основе обсуждения в недавнем вопросе "Консольное приложение не завершается", который почему-то снесли, поэтому оставляю информацию здесь.</em></p>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
