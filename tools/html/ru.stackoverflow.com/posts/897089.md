---
title: "Post 897089"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Post 897089</h1>
<h2>Answer 897089</h2>
<p><a href="https://ru.stackoverflow.com/a/897089/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<p>В вашем коде трудно разобраться, но выглядит как будто вы никак не используете CancellationToken и не реализуете таймаут для сетевых операций. Для асинхронных сетевых операций, в отличие от синхронных, Request.Timeout играет роль только на начальном этапе от отправки заголовка до получения первых байт ответа. При обрыве связи на последующей загрузке они просто тихо умирают (никогда не заканчиваются), поэтому таймаут нужно реализовать вручную, как-то так:</p>

<pre><code>static async Task&lt;string&gt; Download(string url)
{            
        HttpWebRequest Request = (HttpWebRequest)WebRequest.Create(url);
        var resp = await Request.GetResponseAsync();
        var stream = resp.GetResponseStream();
        MemoryStream ms = new MemoryStream();

        using (stream)
        using (ms)
        {
            await stream.CopyToAsync(ms);
            ms.Seek(0, SeekOrigin.Begin);

            var rd = new System.IO.StreamReader(ms);
            return await rd.ReadToEndAsync();
        }            
}

private async void button1_Click(object sender, EventArgs e)
{

    const string url = "http://example.com/";                    

    var res = await Task.WhenAny(Download(url),Task.Delay(10000));

    if (res is Task&lt;string&gt;) textBox1.Text = (res as Task&lt;string&gt;).Result;
    else textBox1.Text = "Timeout expired!";
}
</code></pre>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
