---
title: "Как узнать основные характеристики ПЭВМ?"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Как узнать основные характеристики ПЭВМ?</h1>
<p><a href="https://ru.stackoverflow.com/questions/753019/%d0%9a%d0%b0%d0%ba-%d1%83%d0%b7%d0%bd%d0%b0%d1%82%d1%8c-%d0%be%d1%81%d0%bd%d0%be%d0%b2%d0%bd%d1%8b%d0%b5-%d1%85%d0%b0%d1%80%d0%b0%d0%ba%d1%82%d0%b5%d1%80%d0%b8%d1%81%d1%82%d0%b8%d0%ba%d0%b8-%d0%9f%d0%ad%d0%92%d0%9c">Source</a> - by <a href="https://ru.stackoverflow.com/users/276501/%d0%92%d0%b8%d0%ba%d1%82%d0%be%d1%80%d0%b8%d1%8f">Виктория</a></p>
<blockquote>
<p>Очень нужна ваша помощь,столкнулась с таким заданием :
 Для компьютера на своем рабочем месте определить:</p>

<p>•   тип компьютера; </p>

<p>•   конфигурацию оборудования; </p>

<p>•   объем оперативной памяти; </p>

<p>•   наличие и объем расширенной памяти; </p>

<p>•   наличие дополнительных ПЗУ; </p>

<p>•   версию операционной системы. </p>

<p>Естественно, сразу начала искать примеры и способы решения данного задания(код пишу на СИ), нашла несколько примеров, но там была библиотека "sysp.h",попыталась скомпилить коды и выбило ошибку, что нету такого файла или библиотеки.  Пыталась самостоятельно подключить,нашла содержимое библиотеки, но все равно много ошибок появилось. </p>

<p>Вопрос вот в чем, может кто-нибудь подскажет как можно решить это задание, что использовать вместо данной библиотеки, может есть другие аналоги "sysp.h". Буду очень благодарна за любые советы,материалы по заданию, являюсь очень большим нубом, но пытаюсь наверстать все и исправить ситуацию :))</p>

</blockquote>
<h2>Answer 753163</h2>
<p><a href="https://ru.stackoverflow.com/a/753163/">Source</a> - by <a href="https://ru.stackoverflow.com/users/23044/jfs">jfs</a></p>
<blockquote>
<p>Каким образом информация о компьютере доступна обычным программам —  зависит от установленной операционной системы.</p>

<p>Чтобы получить информацию о железе на Linux, *BSD, etc, можно использовать <a href="http://www.nongnu.org/dmidecode/" rel="nofollow noreferrer"><code>dmidecode</code></a> утилиту (<a href="https://ru.wikipedia.org/wiki/SMBIOS" rel="nofollow noreferrer">SMBIOS/DMI</a>). С помощью опций легко выбрать только нужную для задачи информацию:</p>

<pre><code># dmidecode -s chassis-type
Desktop
</code></pre>

<p>Можно вызвать <code>dmidecode</code> как внешную программу и прочитать её вывод, используя <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html" rel="nofollow noreferrer"><code>popen()</code></a>.</p>

<p>На Windows, WMI может помочь:</p>

<pre><code>PS&gt; Get-WmiObject win32_systemenclosure | select chassistypes
</code></pre>

<p>Функции предоставляемые этими внешними командами можно и напрямую реализовать как на *nix (<code>/dev/mem</code>) так и на Windows (COM API for WMI), но это может быть сложнее чем просто вызвать внешнюю команду и прочитать её вывод.</p>

</blockquote>
<h2>Answer 753379</h2>
<p><a href="https://ru.stackoverflow.com/a/753379/">Source</a> - by <a href="https://ru.stackoverflow.com/users/213498/sergey">Sergey</a></p>
<blockquote>
<p>В Linux:</p>

<p>1) Про железо:</p>

<pre><code>$ lshw
    описание: Computer
    разрядность: 64 bits
    возможности: vsyscall32
  *-core
       описание: Motherboard
       физический ID: 0
     *-memory
          описание: Системная память
          физический ID: 0
          размер: 3951MiB
     *-cpu
          продукт: AMD Athlon(tm) II X2 260 Processor
          производитель: Advanced Micro Devices [AMD]
          физический ID: 1
          сведения о шине: cpu@0
          размер: 3200MHz
          capacity: 3200MHz
          разрядность: 64 bits
          возможности: fpu fpu_exception wp
</code></pre>

<p>Ну и там далее очень много чего и очень в больших подробностях.</p>

<p>2) Про OS:</p>

<pre><code>$ uname -a
Linux dtk58 4.4.0-98-generic #121-Ubuntu SMP Tue Oct 10 14:24:03 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
</code></pre>

</blockquote>
<h2>Answer 753935</h2>
<p><a href="https://ru.stackoverflow.com/a/753935/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<p>В языке С (без плюсов), для получения информации о железе наверное проще всего брать информацию прямо из таблицы SMBIOS, возвращаемой функцией <code>GetSystemFirmwareTable</code>. </p>

<p>Возьмем <a href="https://github.com/cavaliercoder/sysinv/blob/master/smbios.cpp" rel="nofollow noreferrer">отсюда</a> библиотеку для разбора SMBIOS:</p>

<pre><code>// SMBIOS Table Type numbers
#define SMB_TABLE_BIOS              0
#define SMB_TABLE_SYSTEM            1
#define SMB_TABLE_BASEBOARD         2
#define SMB_TABLE_CHASSIS           3
#define SMB_TABLE_PROCESSOR         4
#define SMB_TABLE_MEMCTRL           5
#define SMB_TABLE_MEMMODULES        6
#define SMB_TABLE_PORTS             8
#define SMB_TABLE_SLOTS             9
#define SMB_TABLE_OEM_STRINGS       11
#define SMB_TABLE_SYS_CFG_OPTIONS   12
#define SMB_TABLE_MEM_ARRAY         16
#define SMB_TABLE_MEM_DEVICE        17
#define SMB_TABLE_END_OF_TABLE      127

// CPU registers returned by __cpuid()
#define EAX                         0
#define EBX                         1
#define ECX                         2
#define EDX                         3

// Virtualization platform providers
#define VIRT_PLATFORM_NONE          0
#define VIRT_PLATFORM_VMWARE        1
#define VIRT_PLATFORM_VBOX          2
#define VIRT_PLATFORM_QEMU          3
#define VIRT_PLATFORM_KVM           4
#define VIRT_PLATFORM_MSVPC         5
#define VIRT_PLATFORM_HYPERV        6
#define VIRT_PLATFORM_XEN           7
#define VIRT_PLATFORM_VTZO          8
#define VIRT_PLATFORM_PARA          9

// 64bit Word type
typedef unsigned long long QWORD;

/*
* Structures
*/
typedef struct _RawSmbiosData
{
    BYTE    Used20CallingMethod;
    BYTE    SMBIOSMajorVersion;
    BYTE    SMBIOSMinorVersion;
    BYTE    DmiRevision;
    DWORD   Length;
    BYTE    SMBIOSTableData[1];
} RAW_SMBIOS_DATA, * PRAW_SMBIOS_DATA;

typedef struct _SmbiosStructHeader
{
    BYTE Type;
    BYTE Length;
    WORD Handle;
} SMBIOS_STRUCT_HEADER, *PSMBIOS_STRUCT_HEADER;

// Structures
typedef struct _NODE {
    wchar_t *Name;                      // Name of the node
    struct _NODE_ATT_LINK *Attributes;  // Array of attributes linked to the node
    struct _NODE *Parent;               // Parent node
    struct _NODE_LINK *Children;        // Array of linked child nodes
    int Flags;                          // Node configuration flags
} NODE, * PNODE;

typedef struct _NODE_LINK {
    struct _NODE *LinkedNode;           // Node attached to this node
} NODE_LINK, * PNODE_LINK;

typedef struct _NODE_ATT {
    wchar_t *Key;                       // Attribute name
    wchar_t *Value;                     // Attribute value string (may be null separated multistring if NAFLG_ARRAY is set)
    int Flags;                          // Attribute configuration flags
} NODE_ATT, *PNODE_ATT;

typedef struct _NODE_ATT_LINK {
    struct _NODE_ATT *LinkedAttribute;  // Attribute linked to this node
} NODE_ATT_LINK, *PNODE_ATT_LINK;


/********************************************************************/

PRAW_SMBIOS_DATA GetSmbiosData()
{
    DWORD bufferSize = 0;

    PRAW_SMBIOS_DATA smbios = NULL;

    // Get required buffer size
    bufferSize = GetSystemFirmwareTable('RSMB', 0, NULL, 0);
    if (bufferSize) {
        smbios = (PRAW_SMBIOS_DATA)LocalAlloc(LPTR, bufferSize);
        bufferSize = GetSystemFirmwareTable('RSMB', 0, (PVOID)smbios, bufferSize);
    }

    return smbios;
}

PSMBIOS_STRUCT_HEADER GetNextStructure(PRAW_SMBIOS_DATA smbios,PSMBIOS_STRUCT_HEADER previous)
{
    PSMBIOS_STRUCT_HEADER next = NULL;
    PBYTE c = NULL;



    // Return NULL is no data found
    if (NULL == smbios)
        return NULL;

    // Return first table if previous was NULL
    if (NULL == previous)
        return (PSMBIOS_STRUCT_HEADER)(&amp;smbios-&gt;SMBIOSTableData[0]);

    // Move to the end of the formatted structure
    c = ((PBYTE)previous) + previous-&gt;Length;

    // Search for the end of the unformatted structure (\0\0)
    while (true) {
        if ('\0' == *c &amp;&amp; '\0' == *(c + 1)) {
            /* Make sure next table is not beyond end of SMBIOS data
             * (Thankyou Microsoft for ommitting the structure count
             * in GetSystemFirmwareTable
             */
            if ((c + 2) &lt; ((PBYTE)smbios-&gt;SMBIOSTableData + smbios-&gt;Length))
                return (PSMBIOS_STRUCT_HEADER)(c + 2);
            else
                return NULL; // We reached the end
        }

        c++;
    }

    return NULL;
}

PSMBIOS_STRUCT_HEADER GetNextStructureOfType(PRAW_SMBIOS_DATA smbios,PSMBIOS_STRUCT_HEADER previous, DWORD type)
{
    PSMBIOS_STRUCT_HEADER next = previous;
    while (NULL != (next = GetNextStructure(smbios,next))) {
        if (type == next-&gt;Type)
            return next;
    }

    return NULL;
}

PSMBIOS_STRUCT_HEADER GetStructureByHandle(PRAW_SMBIOS_DATA smbios,WORD handle)
{
    PSMBIOS_STRUCT_HEADER header = NULL;

    while (NULL != (header = GetNextStructure(smbios,header)))
        if (handle == header-&gt;Handle)
            return header;

    return NULL;
}

LPTSTR GetSmbiosString(PSMBIOS_STRUCT_HEADER table, BYTE index)
{
    DWORD i = 0;
    DWORD len = 0;
    LPTSTR unicode = _wcsdup(_T(""));

    if (0 == index)
        return unicode;

    char *c = NULL;

    for (i = 1, c = (char *)table + table-&gt;Length; '\0' != *c; c += strlen(c) + 1, i++) {
        if (i == index) {
            LocalFree(unicode);

            len = MultiByteToWideChar(CP_UTF8, 0, c, -1, NULL, 0);
            unicode = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR)* len);

            MultiByteToWideChar(CP_UTF8, 0, c, -1, unicode, len);
            break;
        }
    }

    return unicode;
}
</code></pre>

<hr>

<p>Смастерим функции для получения значений по смещению:</p>

<pre><code>//вывод значения числового параметра таблицы SMBIOS по указанному смещению
void PrintBiosValue(PRAW_SMBIOS_DATA smbios,DWORD type,DWORD offset)
{

    PSMBIOS_STRUCT_HEADER head; 
    head=NULL;
    PBYTE cursor = NULL; 

    head = GetNextStructureOfType(smbios,head, type);
    if (NULL == head){printf("PrintString Error!\n");return;}
    cursor=((PBYTE)head+offset);

        //  value           
        printf("%d\n",(int)*cursor);        

}

//вывод значения строкового параметра таблицы SMBIOS по указанному смещению
void PrintBiosString(PRAW_SMBIOS_DATA smbios,DWORD type,DWORD offset)
{

    PSMBIOS_STRUCT_HEADER head; 
    head=NULL;
    PBYTE cursor = NULL;

    LPTSTR unicode = NULL;      

    head = GetNextStructureOfType(smbios,head, type);
    if (NULL == head){printf("PrintString Error!\n");return;}
    cursor=((PBYTE)head+offset);
    BYTE val=*cursor;

    unicode = GetSmbiosString((head), *cursor);
        //  value           
        wprintf(unicode);printf("\n");      
        LocalFree(unicode); 

}
</code></pre>

<hr>

<p>Значения смещений для конкретных параметров можно найти в <a href="http://www.dmtf.org/sites/default/files/standards/documents/DSP0134_2.8.0.pdf" rel="nofollow noreferrer">спецификации SMBIOS</a>.<br>
Для получения размера оперативной памяти, к счастью, есть готовая функция <code>GetPhysicallyInstalledSystemMemory</code>.</p>

<p>Пример использования:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;

int _tmain(int argc, _TCHAR* argv[])
{
    PRAW_SMBIOS_DATA data=GetSmbiosData();
    if(data==NULL){printf("Can't get data!");goto End;}

    printf("BIOS vendor: ");
    PrintBiosString(data,SMB_TABLE_BIOS,4);

    printf("Motherboard vendor: ");
    PrintBiosString(data,SMB_TABLE_SYSTEM,4);

    printf("CPU vendor: ");
    PrintBiosString(data,SMB_TABLE_PROCESSOR,7);

    printf("Type: ");
    PrintBiosValue(data,SMB_TABLE_CHASSIS,5);//Тип компьютера: 3=desktop,9=laptop,A=notebook, ...

    ULONGLONG memory=0;
    if(GetPhysicallyInstalledSystemMemory(&amp;memory)==FALSE)printf("Can't get memory!");
    else printf("Memory: %llu KB\n",memory);

    End:system("PAUSE");
    return 0;
}
</code></pre>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
