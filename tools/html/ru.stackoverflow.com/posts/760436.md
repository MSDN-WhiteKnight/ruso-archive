---
title: "Передача по ссылке с последующим копированием vs передача по значению"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Передача по ссылке с последующим копированием vs передача по значению</h1>
<p><a href="https://ru.stackoverflow.com/questions/760436/%d0%9f%d0%b5%d1%80%d0%b5%d0%b4%d0%b0%d1%87%d0%b0-%d0%bf%d0%be-%d1%81%d1%81%d1%8b%d0%bb%d0%ba%d0%b5-%d1%81-%d0%bf%d0%be%d1%81%d0%bb%d0%b5%d0%b4%d1%83%d1%8e%d1%89%d0%b8%d0%bc-%d0%ba%d0%be%d0%bf%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5%d0%bc-vs-%d0%bf%d0%b5%d1%80%d0%b5%d0%b4%d0%b0%d1%87%d0%b0-%d0%bf%d0%be-%d0%b7%d0%bd%d0%b0%d1%87%d0%b5%d0%bd%d0%b8%d1%8e">Source</a> - by <a href="https://ru.stackoverflow.com/users/176217/%ce%b1%ce%bb%ce%b5%cf%87%ce%bf%ce%bb%cf%85%cf%84">αλεχολυτ</a></p>
<blockquote>
<p>Есть некий тяжёлый для копирования тип, например:</p>

<pre><code>struct S 
{ 
    int a[100]; 
};
</code></pre>

<p>И стоит задача обработки значения переменной этого типа с возвратом изменённой копии, т.е. оригинал должен быть сохранён. Напрашиваются два подхода:</p>

<ol>
<li><pre><code>S test(const S&amp; s)
{
    S news = s;           // делаем копию
    news.a[42] = 100500;  // изменяем 
    return news;          // возвращаем
}
</code></pre></li>
<li><pre><code>S test(S s)               // делаем копию
{
    s.a[42] = 100500;     // изменяем
    return s;             // возвращаем
}
</code></pre></li>
</ol>

<p>Вариант 2 выглядит более коротким с точки зрения кода, однако, как показывает <a href="https://godbolt.org/g/G6UhMd" rel="noreferrer">сборка</a>, передача по ссылке даёт более короткий ассемблерный код.</p>

<p>Почему так происходит и какие есть ещё плюсы и минусы этих двух подходов, чтобы понимать, какой из них предпочесть? Может есть ещё какие-то варианты?</p>

</blockquote>
<h2>Answer 760442</h2>
<p><a href="https://ru.stackoverflow.com/a/760442/">Source</a> - by <a href="https://ru.stackoverflow.com/users/299519/yrhetatejlb">yrHeTateJlb</a></p>
<blockquote>
<p>Процитирую "Совершенный код" Макконела, глава 7.5:</p>

<blockquote>
  <p><strong>Не используйте параметры метода в качестве рабочих переменных</strong> </p>
  
  <p>Использовать передаваемые в метод параметры как рабочие переменные опасно. Создайте для этой цели локальные переменные. Так, в следующем фрагменте Java кода переменная inputVal некорректно служит для хранения промежуточных результатов вычислений: </p>
</blockquote>

<pre><code>int Sample(int inputVal) {
    inputVal = inputVal * CurrentMultiplier( inputVal );
    inputVal = inputVal + CurrentAdder( inputVal );

    //...

    //Переменная inputVal уже не содержит входного значения. 
    return inputVal; 
} 
</code></pre>

<blockquote>
  <p>В этом фрагменте переменная inputVal вводит в заблуждение, потому что при завершении метода она больше не содержит входного значения; она содержит результат вычисления, частично основанного на входном значении, и поэтому ее имя неудачно. Если позднее вам придется задействовать первоначальное входное значение в другом месте метода, вы, вероятно, задействуйте переменную inputVal, пред полагая, что она содержит первоначальное значение, но это предположение будет ошибочным.</p>
</blockquote>

<p><strong>ИМХО:</strong> Это почва для ошибок. Хотя сам лично писал: </p>

<pre><code>template&lt;class T&gt;
QVector&lt;T&gt; reversed(QVector&lt;T&gt; vector){
    std::reverse(vector.begin(), end.begin());
    return vector;
}
</code></pre>

<p>... и никакой вины не чувствую :)</p>

<p>Исходя из рассуждений Макконела разумнее передавать параметры по ссылке и делать локальную копию.</p>

</blockquote>
<h2>Answer 760460</h2>
<p><a href="https://ru.stackoverflow.com/a/760460/">Source</a> - by <a href="https://ru.stackoverflow.com/users/278482/user278482">user278482</a></p>
<blockquote>
<p>Как вариант подойдёт</p>

<pre><code>S* test(const S&amp; s)
{
S *news = new S;         // создаём новый элемент
*news = s;              // делаем копию
news-&gt;a[42] = 100500;  // изменяем 
return news;          // возвращаем
}
</code></pre>

</blockquote>
<h2>Answer 760502</h2>
<p><a href="https://ru.stackoverflow.com/a/760502/">Source</a> - by <a href="https://ru.stackoverflow.com/users/15146/ixsci">ixSci</a></p>
<blockquote>
<p>Первый вариант, очевидно, лучше, потому что подходит под понятие хорошего C++-кода, который <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-in" rel="nofollow noreferrer">пропагандируется</a> на протяжении многих лет. Такой код не вызывает вопросов, а вот структура, переданная не по ссылке, вызывает. И чем больше размер структуры, тем больше вопросов такое решение будет вызывать. А раз вызывает вопросы, значит требует комментария. Кроме того, как Вы сами указываете в своём вопросе, эффективность двух методов Вы не измерили (размер листинга ассемблера вообще ни о чём не говорит), поэтому и ссылаться не на что. </p>

<p>Этот вопрос, на мой взгляд, типичный пример попытки преждевременной оптимизации, которая, в целом, может вылиться в пессимизацию с отрицательным эффектом касательно читабельности кода. </p>

<hr>

<p>Написал довольно объёмный текст по данному вопросу. С ним можно ознакомиться по этой ссылке: <a href="http://scrutator.me/post/2018/07/30/value_vs_reference.aspx" rel="nofollow noreferrer">Передача по ссылке или по значению?</a></p>

</blockquote>
<h2>Answer 760563</h2>
<p><a href="https://ru.stackoverflow.com/a/760563/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<blockquote>
  <p>передача по ссылке даёт более короткий ассемблерный код</p>
</blockquote>

<p>В ассемблерном коде x86-64 clang, на который вы дали ссылку, разница между первым и вторым вариантом в следующем: </p>

<p>В первом варианте срабатывает оптимизация и структура копируется из переданного аргументом адреса сразу на место возвращаемого значения. При возврате не требуется дополнительных действий.</p>

<p>Во втором варианте такая оптимизация не применяется, и копирование структуры происходит два раза. Первый раз вызывающий код создает копию для передачи в функцию (за скобками данного кода), а второй раз - при возврате из функции.</p>

<p>Второй вариант длиннее на одну строку из-за оператора <code>lea rsi, [rsp + 16]</code>, который как раз и вычисляет аргумент <em>source</em> для вызова <em>memcpy</em> (в первом случае это не нужно, так как он явно передан вызывающей функцией). Таким образом, сферически в вакууме, второй вариант не эффективен, из-за двойного копирования структуры и лишнего вычисления аргумента для <em>memcpy</em>.</p>

<blockquote>
  <p>какие есть ещё плюсы и минусы этих двух подходов, чтобы понимать, какой из них предпочесть?</p>
</blockquote>

<p>Я полагаю, в реальных программах об этом не надо заботиться. Оптимизирующий компилятор будет рассматривать не отдельные функции, а программу в целом, и выберет лучший вариант. Хотя второй вариант теоретически "хуже", в реальности компилятор обе функции просто превратит в inline (если на них не берутся указатели), и разницы никакой не будет. </p>

</blockquote>
<h2>Answer 760685</h2>
<p><a href="https://ru.stackoverflow.com/a/760685/">Source</a> - by <a href="https://ru.stackoverflow.com/users/182825/ant">AnT</a></p>
<blockquote>
<p>В современном С++ более предпочтительным считается именно второй вариант. Т.е. если вы знаете, что вам в любом случае понадобится копия, то лучше чтобы эту копию для вас делал компилятор, а не вы сами.</p>

<p>Однако традиционное обоснование, приводящееся для этого утверждения, рассчитывает на типы, которые "тяжелы" для копирования не потому, что велики по размеру сами по себе, а потому, что требуют <em>глубокого</em> (deep) копирования. Т.е. речь идет о типах, которые являются компактными на <em>мелком</em> (shallow) уровне, но владеют дополнительными ресурсами через указатели/хендлы. Вся идея тут в том, что компилятор будет в состоянии заменить копирование на перемещение в ситуациях, когда исходное значение является временным/переместимым.</p>

<p>Например, если в вашем случае заменить <code>S</code> на <code>std::string</code>, то при вызове <code>test("abc")</code> второй вариант при подготовке аргументов обойдется без глубокого копирования вообще, в то время как в первом варианте вы сами безусловно выполните глубокое копирование.</p>

<p>(Еще более эффективным может быть вариант с двумя отдельными функциями - для параметра <code>const std::string &amp;</code> и для параметра <code>std::string &amp;&amp;</code>, но если вы не пытаетесь выжать последние такты процессора, то одна функция с параметром <code>std::string</code> часто выглядит привлекательнее.)</p>

<p>В случае же, когда "тяжесть" объекта встроена непосредственно в сам объект, как в вашем примере, сэкономить на копировании не удастся. Я бы ожидал одинаковой производительности от обоих вариантов. </p>

<p>Некоторым нюансом является то, что, согласно абстрактной семантике языка, создание копии во втором варианте делается в контексте <em>вызывающего</em> кода. Некоторые реализации следуют этой семантике буквально - они выполняют создание копии и резервирование памяти для нее в контексте вызывающего кода. При этом память может резервироваться заранее, независимо от того, будет ли фактически вызываться функция в процессе выполнения. Т.е. написав, скажем, вот такую рекурсивную функцию</p>

<pre><code>void recursive(unsigned n, const S &amp;s)
{
  if (n &gt; 0)
    recursive(n - 1, s);
  else
    test(s);
}
</code></pre>

<p>вы можете с удивлением обнаружить, что при использовании второго варианта функции <code>test</code> память в стеке для копии <code>s</code> выделяется на <em>каждом</em> уровне рекурсии, в то время как фактически эта память нужна только на самом дне рекурсии. Первый вариант <code>test</code> будет свободен от этого недостатка.</p>

<p>Другие реализации могут поступать более экономно: даже при использовании второго варианта <code>test</code> выполнять резервирование памяти только если функция действительно вызывается.</p>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
