---
title: "Что такое Опыт работы в системе CI/CD"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Что такое Опыт работы в системе CI/CD</h1>
<p><a href="https://ru.stackoverflow.com/questions/1053558/%d0%a7%d1%82%d0%be-%d1%82%d0%b0%d0%ba%d0%be%d0%b5-%d0%9e%d0%bf%d1%8b%d1%82-%d1%80%d0%b0%d0%b1%d0%be%d1%82%d1%8b-%d0%b2-%d1%81%d0%b8%d1%81%d1%82%d0%b5%d0%bc%d0%b5-ci-cd">Source</a> - by <a href="https://ru.stackoverflow.com/users/302509/vladimr-vladimirovoch">Vladimr Vladimirovoch</a></p>
<blockquote>
<p>Вопрос теоретический, что есть такое контейнер CI/CD и у некоторых работодателей требуется опыт работы в системе CI/CD? Что имеется ввиду?</p>

</blockquote>
<h2>Answer 1053564</h2>
<p><a href="https://ru.stackoverflow.com/a/1053564/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<p>CI - непрерывная интеграция, упрощенно говоря, это подход к разработке, при котором изменения в исходном коде часто отправляются на сервер и автоматизированно собираются и тестируются. CD (непрерывное развертывание), это аналогично, только помимо сборки код автоматизированно развертывается для конечного использования (например, выкладывается на веб-сервер для веб приложений, или пакуется в установочный пакет целевой ОС для десктопных приложений). Контейнер CI - видимо, просто Docker Container, в котором осуществляются эти действия, если используется <a href="https://docs.microsoft.com/ru-ru/dotnet/architecture/microservices/container-docker-introduction/docker-defined" rel="nofollow noreferrer">Docker</a>. Теория по CI описана по большей части здесь: <a href="https://ru.stackoverflow.com/questions/470453/">Что такое непрерывная интеграция?</a></p>

<p>В качестве практического примера CI можно привести использование GitHub Actions для автоматизированного построения приложения .NET Core.</p>

<p>Создадим репозиторий GitHub, и заполним его тестовым проектом C# .NET Core</p>

<p>Перейдем на вкладку GitHub Actions</p>

<p><a href="https://i.stack.imgur.com/3d0mc.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/3d0mc.png" alt="GitHub Actions"></a></p>

<p>Для проекта с кодом на C# система автоматически предлагает создать Workflow .NET Core. Нажмем кнопку "Set up this workflow". Система предложит создать шаблонный файл конфигурации dotnetcore.yml:</p>

<pre class="lang-none prettyprint-override"><code>name: .NET Core

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v1
    - name: Setup .NET Core
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 2.2.108
    - name: Build with dotnet
      run: dotnet build --configuration Release
</code></pre>

<p>Здесь мы видим два стандартных шага: установка .NET Core SDK нужной версии и запуск сборки с помощью команды dotnet build. Добавим два своих шага: архивацию результатов сборки и запуск получившегося приложения:</p>

<pre class="lang-none prettyprint-override"><code>name: .NET Core

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v1
    - name: Setup .NET Core
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 2.2.108
    - name: Build with dotnet
      run: dotnet build CoreTest.sln --configuration Release
    - name: Archive build results
      uses: actions/upload-artifact@v1
      with:
          name: Output
          path: NetCoreTest/bin/Release/
    - name: Run
      run: |        
        dotnet NetCoreTest/bin/Release/netcoreapp2.1/NetCoreTest.dll
</code></pre>

<p>Зафиксируем результат. Теперь после отправки каждого изменения в репозиторий мы можем автоматически видеть результаты сборки:</p>

<p><a href="https://i.stack.imgur.com/AQPip.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/AQPip.png" alt="build results"></a></p>

<p>Эти результаты фигурируют как проверка для Pull request (на вкладке Checks) - можно сделать проверку обязательной, и тогда нельзя будет выполнить слияние изменений, если сборка проходит с ошибкой. Серьезное преимущество в том, что мы всегда можем убедится, что приложение собирается допустим на Linux, даже не имея локальной машины с этой ОС. Под капотом в данном случае не Docker, а виртуальные машины Azure, так что контейнера CI нет (есть виртуальное окружение CI). </p>

<p>Пример репозитория с настроенным CI: <a href="https://github.com/MSDN-WhiteKnight/CoreTest" rel="nofollow noreferrer">https://github.com/MSDN-WhiteKnight/CoreTest</a></p>

</blockquote>
<h2>Answer 1053566</h2>
<p><a href="https://ru.stackoverflow.com/a/1053566/">Source</a> - by <a href="https://ru.stackoverflow.com/users/182162/mark-shevchenko">Mark Shevchenko</a></p>
<blockquote>
<p>Неизвестно, что имеется в виду работодателями, когда они требуют опыт работы с CI/CD. Обычный разработчик должен уметь работать с git или mercurial, больше ничего. Непосредственно интеграцию и развёртывание делают серверные скрипты, которые настраивают либо системные администраторы, либо опытные разработчики команды.</p>

<p>Разобраться с тем, как и что можно настраивать — дело нескольких дней. Можно что-то такое написать самому, опираясь на так называемые <em>хуки</em> систем контроля версий, но обычно сейчас используют билд-серверы с GUI.</p>

<p>Если речь заходит о <em>контейнере</em> CI/CD, то скорее всего имеют в виду Docker. Очень удобное решение, которое сильно упростило то, что скрывается за буквой D в CD, то есть <em>развёртывание</em>.</p>

<p>Пример. Чтобы убедиться, что новый код ничего не сломает, после сборки проекта и прогона <em>модульных тестов</em> можно развернуть контур интеграционного тестирования. Для этого надо запустить несколько контейнеров Docker с образами баз и новой сборкой. На тестовом контуре можно запускать скрипты, которые проверят, что система работает в сборе — от торчащего наружу API, и до сидящей внутри базы данных.</p>

<p>Ещё раз повторю, что никакой серьёзной магии за этим нет, всё осваивается за несколько дней.</p>

<p>На что хотел бы обратить внимание, так это на культуру <em>совместной разработки</em>. Выучить команды git не очень сложно, хотя они и запутаны немного. Гораздо сложнее приобрести полезные для командной работы привычки.</p>

<ul>
<li><p><strong>Короткие ветки</strong>. Неопытные разработчики часто сидят в своих ветках в течение нескольких дней. За это время код успевает убежать далеко вперёд. Даже если они забирают изменения, вероятность больших слияний возрастает. Правило здесь такое: разбивать задачи так, чтобы каждую задачу можно было решить в течение нескольких часов. Лучше не оставлять открытых задач на завтра.</p></li>
<li><p><strong>Микрофиксации</strong>, то есть micro commits. Каждый commit должен содержать немного файлов и его назначение должно описываться одним предложением. Это нужно для удобного code review. Во время работы у вас часто получается, что часть файлов содержит решение задачи, а часть — рефакторинг. git позволяет сначала добавить одни изменённые файлы в первый commit, и затем другие во второй.</p></li>
<li><p><strong>Названия фиксаций</strong>. При выполнении git commit обязательно заполнять комментарий осмысленным текстом. Многие не делают, и зря. Плохо для code review.</p></li>
</ul>

<p>Вот эти правила осваиваются долго и, как правило, сопровождаются чем-нибудь неприятным: сломанными слияниями, трудными обзорами кода, разборками в команде. Но когда всё это позади, работать становится проще и быстрее.</p>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
