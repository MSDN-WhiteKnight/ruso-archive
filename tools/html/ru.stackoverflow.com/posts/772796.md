---
title: "Обмен данными по ModBus"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Обмен данными по ModBus</h1>
<p><a href="https://ru.stackoverflow.com/questions/772796/%d0%9e%d0%b1%d0%bc%d0%b5%d0%bd-%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d0%bc%d0%b8-%d0%bf%d0%be-modbus">Source</a> - by <a href="https://ru.stackoverflow.com/users/281695/emin4ik">Emin4ik</a></p>
<blockquote>
<p><strong><em>Добрый день!</em></strong></p>

<p>Помогите с обменом данных по <strong>ModBus</strong>. При обращении к мультиметру <strong>PM1000</strong> я знаю что его <strong>ID = 123</strong> но возвращаемое значение приходит совсем другое например <strong>17589</strong> или что-то в этом роде и так со всеми параметрами(вольтаж,ампераж) практически все параметры возвращаются в пределах 
<strong><em>от 17000 до 18000</em></strong> и не важно какое значение ему присвоено будь то <strong>1</strong> может все равно вернуться <strong><em>17541</em></strong> и будь то <strong>12500</strong> может вернуться <strong><em>17444</em></strong>).<br>
В чем может быть проблема?<br>
Адаптер написан на <strong>C#</strong> с ним проблем нету. Этот же адаптер прекрасно работает с другими устройствами и правильно возвращает значения.
Уже около недели не могу разобраться.</p>

<p><strong>Заранее благодарю!</strong></p>

</blockquote>
<h2>Answer 777245</h2>
<p><a href="https://ru.stackoverflow.com/a/777245/">Source</a> - by <a href="https://ru.stackoverflow.com/users/283035/%d0%a1%d0%b2%d0%b5%d1%82%d0%bb%d0%b0%d0%bd%d0%b0">Светлана</a></p>
<blockquote>
<p>Здравствуйте.  </p>

<p>В вашем вопросе недостаточно данных для ответа.  </p>

<p>Во первых, нет гарантий, что адаптер правильный. В моей практике были случаи, когда код работал нормально, а на новом устройстве выдавал ошибку.<br>
Во вторых вы не указали функции, которые использовали для чтения и записи. Также было бы неплохо указать какие регистры устройства предназначены для записи, а какие для чтения (нет желания читать спецификацию указанного вами устройства и выдирать данные оттуда).<br>
И, соответственно, код, который пишет и читает данные.  </p>

<p>Так же есть ModBus RTU и ModBus TCP, вы не указали какой случай у вас. И еще ModBus поддерживает несколько устройств, соединенных шиной. Какие устройства и как подключены к порту не понятно, так как вы указываете только одно.</p>

</blockquote>
<h2>Answer 809297</h2>
<p><a href="https://ru.stackoverflow.com/a/809297/">Source</a> - by <a href="https://ru.stackoverflow.com/users/281695/emin4ik">Emin4ik</a></p>
<blockquote>
<p>Ребята проблема решилась оказывается данные приходили в виде стандарта IEEE</p>

<pre><code>char[] ch = new char[8];
        string s = Convert.ToString(Convert.ToInt32("43c8840e", 16), 2);
        double deci = 0;
        int b = 0;
        //Console.WriteLine(s);
        string dec = s.Substring(0, 8);
        // Console.WriteLine(dec);
        string frac = s.Substring(8, s.Length - 8);
        //Console.WriteLine(frac);
        int a = Convert.ToInt32(dec, 2);
        int exp = a - 127;
        double[] fracarray = new double[frac.Length];
        for (int i = 0; i &lt; frac.Length; i++)
        {
            b++;
            fracarray[i] = Convert.ToInt32(frac[i] - 48) * Math.Pow(2, -b);
            deci += fracarray[i];
        }
        double finala = Math.Pow(2, exp) * (1 + deci);
        Console.WriteLine(finala);
        Console.ReadKey();
</code></pre>

<p>вот этот кусочек кода помог во всем разобраться</p>

</blockquote>
<h2>Answer 809326</h2>
<p><a href="https://ru.stackoverflow.com/a/809326/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<blockquote>
  <p>Ребята проблема решилась оказывается данные приходили в виде стандарта IEEE</p>
</blockquote>

<p>Если нужно просто конвертировать Int32 в эквивалентное (по байтовому представлению) IEEE Float, это можно сделать проще:</p>

<pre><code>Int32 number = 0x43c8840e;
using (MemoryStream ms = new MemoryStream())
{
    using (BinaryWriter wr = new BinaryWriter(ms))
    using (BinaryReader rd = new BinaryReader(ms))
    {
        wr.Write(number);
        wr.Seek(0, SeekOrigin.Begin);
        float f = rd.ReadSingle();
        Console.WriteLine(f);
    }
}
</code></pre>

<p>Правда, не вижу особого смысла в этой операции. Если данные приходят во float надо и считывать сразу float. C# работу с ним полностью поддерживает.</p>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
