---
title: "Post 880893"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Post 880893</h1>
<h2>Answer 880893</h2>
<p><a href="https://ru.stackoverflow.com/a/880893/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<p>Несовместимость бинарных модулей (далее, для краткости, просто "модулей"), произведенных разными компиляторами, определяется в основном следующими тремя аспектами:</p>

<ol>
<li><p>Разные правила декорирования имен экспортируемых символов</p></li>
<li><p>Разное устройство объектов стандартной библиотеки</p></li>
<li><p>Разные правила расположения полей структур в памяти</p></li>
</ol>

<p>Первый пункт характерен фактически только для С++: в Си существует набор характерных для конкретной аппаратной платформы соглашений о вызове (например, stdcall, fastcall и cdecl для x86), которые довольно четко прописывают правила декорирования имен. Второй пункт относится и к Си и к С++, но в Си не очень много "объектов стандартной библиотеки" - в голову приходит только FILE*, и экспортировать его через границы модулей нет никакого смысла. </p>

<p>Таким образом да, действительно можно сказать, что С++ "хуже" чем Си в плане бинарной совместимости. Это разумеется не значит, что не нужно на нем писать, это лишь значит, что на границе модулей нужно использовать интерфейс в стиле Си (либо использовать стандартизированный объектно-ориентированный интерфейс, например Component Object Model в Windows). </p>

<blockquote>
  <p>Есть ли способы делать двоичные библиотеки максимально совместимыми? Чтобы написанная однажды библиотека dll могла быть подключена в самых разных языках без боли и страданий?</p>
</blockquote>

<p>Использование DLL на С/С++ в других языках это больше чем вопрос бинарного интерфейса (например, в них может просто не быть концепции заголовочных файлов, указателей и т.п.), но обычно да, библиотека с интерфейсом в стиле Си может быть использована и из других языков с тем или иным количеством дополнительных телодвижений. </p>

<p>Рекомендации для обеспечения максимальной бинарной совместимости: </p>

<ul>
<li><p>Экспортируйте через границы бинарного модуля только простые функции с припиской <code>extern "C"</code> (т.е, никаких классов, шаблонов, перегруженных функций, пространств имен и т.п.)</p></li>
<li><p>Передавайте через границы модулей только простые типы, указатели на них и указатели на функции.</p></li>
<li><p>Если все же передаете структуры, сделайте первым членом структуры ее размер. Это позволит, если вы натолкнетесь на различия по выравниванию полей, обнаружить несоответствие в общем размере структуры и хотя бы нормально вернуть ошибку. </p></li>
<li><p>Не передавайте через границы модулей объекты стандартной библиотеки, например указатели FILE*.</p></li>
<li><p>Блоки динамической памяти должны освобождаться всегда в том же модуле, в котором были выделены. Т.е., если библиотека возвращает программе-клиенту указатель на блок памяти, выделенный malloc внутри себя, она должна предоставлять специальную функцию для его освобождения (вызывающую внутри себя free), вместо того, чтобы полагаться на вызов free в программе-клиенте.</p></li>
</ul>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
