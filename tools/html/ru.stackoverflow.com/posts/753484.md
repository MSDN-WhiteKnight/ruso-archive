---
title: "Не отрабатывает событие нового кадра NewFrame Aforge"
---
<p><i><a href="https://github.com/MSDN-WhiteKnight/ruso-archive/">RuSO Archive</a></i></p>
<h1>Не отрабатывает событие нового кадра NewFrame Aforge</h1>
<p><a href="https://ru.stackoverflow.com/questions/753484/%d0%9d%d0%b5-%d0%be%d1%82%d1%80%d0%b0%d0%b1%d0%b0%d1%82%d1%8b%d0%b2%d0%b0%d0%b5%d1%82-%d1%81%d0%be%d0%b1%d1%8b%d1%82%d0%b8%d0%b5-%d0%bd%d0%be%d0%b2%d0%be%d0%b3%d0%be-%d0%ba%d0%b0%d0%b4%d1%80%d0%b0-newframe-aforge">Source</a> - by <a href="https://ru.stackoverflow.com/users/225774/roman-ieromenko">Roman Ieromenko</a></p>
<blockquote>
<p>Я сильно запутался. WinForms, использую библиотеку Afforge, их пространства имен - AForge.Video, AForge.Video.DirectShow, AForge.Controls и т. д. Используем control VideoSourcePlayer из библиотеки «Controls.dll». Ниже код:</p>

<pre><code>private void buttonVideo_Click(object sender, EventArgs e)
{
    //ourTimer.Enabled = true;
    //ourTimer.Start();
    //ourTimer.Interval = 1000 * checkedListBoxMedia.Items.Count * 12 * 3 / 25;
    progressBar1.Value = 0;
    progressBar1.Maximum = 100 * checkedListBoxMedia.Items.Count;
    progressBar1.Step = 25;
    //progressThread.Start();
    //ourTimer.Tick += new System.EventHandler(timer_Tick);           
    OpenVideoSource(medialist);
}
</code></pre>

<p>Далее:</p>

<pre><code>/ Open video source
private async void OpenVideoSource(List&lt;FileVideoSource&gt; source)
{
    // set busy cursor            
    this.Cursor = Cursors.WaitCursor;
    // start new video source
    videoNumber = 0;
    // Establish timer settings.
    System.Threading.Timer t = new System.Threading.Timer(
      timeCB,     // The TimerCallback delegate type.
      "Added a pgogress",       // Any info to pass into the called method (null for no info).
      0,          // Amount of time to wait before starting.
      2800);      // Interval of time between calls (in milliseconds).
    foreach (IVideoSource iv in source)
    {
        videoNumber++;
        //int x1 = 1;
        await VideoDisplay(iv);

    }

}

private async Task VideoDisplay(IVideoSource iv)
{
    await Task.Run(() =&gt;
    {                
        Invoke((MethodInvoker)
               delegate
               {
                   videoSourcePlayer.VideoSource = iv;                           
                   videoSourcePlayer.Start();                           
               });
    });
    //!!!12000
    Thread.Sleep(7000);
}
</code></pre>

<p>В конструкторе формы был установлен обработчик:</p>

<pre><code>public Form1()
{            
    this.videoSourcePlayer.NewFrame += new AForge.Controls.VideoSourcePlayer.NewFrameHandler(this.videoSourcePlayer_NewFrame);
    frameNumber = 0;           

}
</code></pre>

<p>Однако при запуске VideoSourcePlayer this.videoSourcePlayer.NewFrame - это событие не обрабатывается. Пожалуйста помогите. спасибо</p>

</blockquote>
<h2>Answer 762043</h2>
<p><a href="https://ru.stackoverflow.com/a/762043/">Source</a> - by <a href="https://ru.stackoverflow.com/users/222542/bulson">Bulson</a></p>
<blockquote>
<p>Как я понял вам важно сохранять видеокадры в файлы, причем желательно обрабатывать несколько видеофайлов одновременно. Потому, в данном случае, пришлось отказаться от <code>VideoSourcePlayer</code>, он ведь может работать только с одним файлом за раз. </p>

<p>У меня получилась такая программулина</p>

<p><a href="https://i.stack.imgur.com/l0jUn.gif" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/l0jUn.gif" alt="Пример работы программы"></a></p>

<p>Вот такой класс для работы с этой библиотекой пришлось написать</p>

<pre><code>public class AFService
{
    private readonly IVideoSource _fileVideoSource;
    private readonly string _savingDirectory;
    private readonly string _fileName;

    private int _skipFrames;
    private int _numberPassedFrames;
    private int _numberSavedFrames;

    //ctor
    public AFService(string pathToFile) : this(pathToFile, Path.GetDirectoryName(pathToFile))
    {}
    public AFService(string pathToFile, string dirToSave)
    {
        if (String.IsNullOrEmpty(pathToFile)) throw new ArgumentException(nameof(pathToFile));
        if (String.IsNullOrEmpty(dirToSave)) throw new ArgumentException(nameof(dirToSave));
        if (!File.Exists(pathToFile)) throw new FileNotFoundException(pathToFile);

        _savingDirectory = dirToSave;
        _fileName = Path.GetFileNameWithoutExtension(pathToFile);

        string extension = Path.GetExtension(pathToFile);
        if (extension.Contains("avi"))
        {
            _fileVideoSource = new AVIFileVideoSource(pathToFile);
        }
        else
        {
            _fileVideoSource = new FileVideoSource(pathToFile);
        }
    }

    /// &lt;summary&gt;
    /// Кадр захвачен и сохранен
    /// &lt;/summary&gt;
    public event EventHandler&lt;AFServiceEventArgs&gt; FrameCaptured;

    /// &lt;summary&gt;
    /// Захват кадров закончен
    /// &lt;/summary&gt;
    public event EventHandler&lt;AFServiceEventArgs&gt; CaptureFinished;

    /// &lt;summary&gt;
    /// Захват кадров видео файла в jpg файлы
    /// &lt;/summary&gt;
    /// &lt;param name="cancellationToken"&gt;токен отмены&lt;/param&gt;
    /// &lt;param name="skipFrames"&gt;шаг пропуска кадров, по-умолчанию равно 30&lt;/param&gt;
    /// &lt;returns&gt;количество сохраненных кадров&lt;/returns&gt;
    public async Task&lt;int&gt; CaptureFramesAsync(CancellationToken cancellationToken, int skipFrames = 30)
    {
        //запоминаем шаг пропуска
        _skipFrames = skipFrames;

        //готовимся
        AsyncVideoSource source = new AsyncVideoSource(_fileVideoSource, true);
        source.PlayingFinished += Source_PlayingFinished;
        source.NewFrame += Source_NewFrame;
        source.VideoSourceError += Source_VideoSourceError;

        //начинаем процесс
        await Task.Run(() =&gt;
        {
            source.Start();
            //ждем окончания прохода по всему видеофайлу
            while (source.IsRunning)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    source.Stop();
                    //выброс исключения в случае отмены задачи
                    cancellationToken.ThrowIfCancellationRequested();
                    break;
                }

                //Debug.WriteLine($"FramesReceived-{source.FramesReceived}");
                //Debug.WriteLine($"FramesProcessed-{source.FramesProcessed}");
                //Debug.WriteLine($"BytesReceived-{source.BytesReceived}");
            }
        });

        //отдаем результат
        return _numberSavedFrames;
    }

    private void Source_NewFrame(object sender, NewFrameEventArgs eventArgs)
    {
        AsyncVideoSource source = sender as AsyncVideoSource;
        _numberPassedFrames += source.FramesProcessed;
        Debug.WriteLine($"Поступил кадр: {_numberPassedFrames}");

        //пропускаем ненужные кадры
        if (_numberPassedFrames % _skipFrames != 0) return;

        Debug.WriteLine($"!&lt;-- Взят в обработку: {_numberPassedFrames}");

        //увеличиваем счетчик запоминаемых кадров
        _numberSavedFrames++;
        //формируем имя файла
        var file = Path.Combine(_savingDirectory, $"{_fileName}-{_numberSavedFrames}.jpg");

        //сохраняем кадр в файл
        Image img = eventArgs.Frame;
        img.Save(file, ImageFormat.Jpeg);
        Debug.WriteLine($"!&lt;-- cохраненен под именем: {file}");

        //вызываем событие сохранения кадра
        var evArg = new AFServiceEventArgs(String.Empty, file, _numberSavedFrames, _numberPassedFrames);
        FrameCaptured?.Invoke(this, evArg);
    }

    private void Source_PlayingFinished(object sender, ReasonToFinishPlaying reason)
    {
        Debug.WriteLine($"Захват отработал у файла: {_fileName}");

        //вызываем событие окончания работы над файлом
        var evArg = new AFServiceEventArgs(reason.ToString(), String.Empty, _numberSavedFrames, _numberPassedFrames);
        CaptureFinished?.Invoke(this, evArg);
    }

    private void Source_VideoSourceError(object sender, VideoSourceErrorEventArgs eventArgs)
    {
        //вызываем событие окончания работы над файлом
        var evArg = new AFServiceEventArgs(eventArgs.Description, String.Empty, 0, 0);
        CaptureFinished?.Invoke(this, evArg);
    }
}
</code></pre>

<p>Работа протестирована на файлах <code>wmv</code>, на <code>avi</code> почему-то вылезает ошибка, но я надеюсь, что вы далее сами поработайте и все наладите. Весь проект целиком можно скачать <a href="https://yadi.sk/d/M_T-37ZJ3QwVmA" rel="nofollow noreferrer">здесь</a>.</p>

</blockquote>
<h2>Answer 763170</h2>
<p><a href="https://ru.stackoverflow.com/a/763170/">Source</a> - by <a href="https://ru.stackoverflow.com/users/240512/msdn-whiteknight">MSDN.WhiteKnight</a></p>
<blockquote>
<blockquote>
  <p>На более мощном ПК не работает, на стареньком все отрабатывает</p>
</blockquote>

<p>Если проблема проявляется только на отдельных машинах, вам нужно смотреть, что отличается на проблемной машине в конфигурации DirectShow. Видимо какой-то кодек вызывает проблему, генерируя поток неподходящего формата. AForge использует DirectShow, беглый просмотр исходников <a href="https://github.com/cureos/aforge/blob/master/Sources/Video.DirectShow/FileVideoSource.cs" rel="nofollow noreferrer">FileVideoSource</a> показывает следующую методику построения графа:</p>

<ul>
<li><p>Автоматически вставляется выбранный системой source filter (через <code>AddSourceFilter</code>)</p></li>
<li><p>Создается Sample Grabber, настроенный на формат видео <code>MediaSubType.RGB24</code></p></li>
<li><p>Sample Grabber подцепляется к первому найденному видео-выходу source filter</p></li>
</ul>

<p>Слабое место в этой схеме - явное указание <code>MediaSubType</code>. Насколько я знаю, если в видеопотоке SubType будет несовместимым с RGB24 (например YUY2), ошибки не выведется, но событие нового кадра никогда не вызовется. Поэтому работоспособность этого класса полностью зависит от того, какой формат будет генерировать декодер видео для конкретного файла на целевой машине.</p>

<p>Вы можете попробовать следующее:</p>

<ul>
<li><p>Распространять вместе с программой кодеки, которые гарантированно выдают формат RGB для выходного потока видео, и настраивать их так, чтобы они автоматически выбирались системой (имели наивысший приоритет).</p></li>
<li><p>Вместо иcпользования AForge, напрямую использовать DirectShow.NET (или модифицировать AForge, пользуясь тем, что это Open Source), и исправить данный недостаток. Нужно при вызове <code>SetMediaType</code> вместо явного SubType указывать нулевой GUID - тогда Sample Grabber будет принимать все форматы. И, соответственно, нужно предусмотреть преобразование из других форматов в RGB.</p></li>
</ul>

</blockquote>
<hr/>
<p><i>Content is retrieved from StackExchange API. </i></p>
<p><i>Auto-generated by ruso-archive tools. </i></p>
